%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface for toGrin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs module {%{EH}Core.ToGrin} export(Inh_CodeAGItf(..),Syn_CodeAGItf(..),wrap_CodeAGItf,sem_CodeAGItf)
%%]
%%[(8 codegen grin).WRAPPER ag import({Core/AbsSyn},{Core/CommonLev},{Core/CommonToXX},{Core/CommonLamInfo})
WRAPPER CodeAGItf
%%]
%%[(8 codegen grin) hs import(Char, Data.Maybe, Data.List, qualified Data.Set as Set, qualified Data.Map as Map)
%%]
%%[(8 codegen grin) hs import(EH.Util.Utils, EH.Util.Pretty)
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common}, {%{EH}Base.Opts}, qualified {%{EH}Config} as Cfg, {%{EH}Base.Builtin},{%{EH}Base.Builtin2})
%%]
%%[(8 codegen grin) hs import({%{EH}LamInfo}, {%{EH}Core}, {%{EH}Ty}, {%{EH}Gam.Full}, {%{EH}GrinCode})
%%]

%%[(8 codegen grin) hs import(Debug.Trace)
%%]

%%[(94 codegen) hs import({%{EH}Foreign.Extract})
%%]

%%[(96 codegen grin) hs import({%{EH}BuiltinPrims})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

none, directly exports wrap_CodeAGItf,sem_CodeAGItf

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fake AG dependencies to avoid INDUCED cycles
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[99
SEM CBind
  | Bind      	lhs			.	opts				<	expr.gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type signatures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[99
SEM *
  | *      		loc			.	gUniq			: UID
  	      		loc			.	lUniq			: UID
  	      		loc			.	lUniq2			: UID
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Global info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllCodeNT CodeAGItf [ opts: EHCOpts | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% DataGam required for FFI possible tags
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllCodeNT CodeAGItf [ dataGam: DataGam | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllCodeNT - AllMeta [ | gUniq: UID | ]
ATTR CodeAGItf [ gUniq: UID | | ]

SEM CExpr
  | Var         (lhs.gUniq,loc.lUniq)       =   mkNewLevUID   @lhs.gUniq
  | TupIns TupUpd TupDel
                (expr.gUniq,loc.lUniq)      =   mkNewUID      @lhs.gUniq
  | Case        (expr.gUniq,loc.lUniq)      =   mkNewUID      @lhs.gUniq
  | App         (func.gUniq,loc.lUniq,loc.lUniq2)
                                            =   mkNewLevUID2  @lhs.gUniq

SEM CBind
%%[[(8 codegen grin)
  | FFI         (lhs.gUniq,loc.lUniq)       =   mkNewLevUID   @lhs.gUniq
%%][98
  | FFI         (lhs.gUniq,loc.lUniq,loc.lUniq2)
  											=   mkNewLevUID2  @lhs.gUniq
%%]]

SEM CPat
  | Con         (binds.gUniq,loc.lUniq)     =   mkNewLevUID   @lhs.gUniq
  | Int Char    (lhs.gUniq,loc.lUniq)       =   mkNewLevUID   @lhs.gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Level, let also one level higher
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
SEM CExpr
  | Let         binds       .   lev         =   @lhs.lev + 1
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Context: evaluation context (to replace isStrict)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

not used yet as it seems not to be equivalent to isStrict. Cannot find out why...

%%[(8 codegen)
%%]
SEM CExpr
  | Let         binds       .   evalCtx     =   if @isGlobal
                                                then EvalCtx_Eval
                                                else if @categ == CBindings_Strict
                                                    then EvalCtx_Eval
                                                    else EvalCtx_None

SEM CBind
  | Bind        expr        .   evalCtx     =   if not (null @expr.grLamArgL)
                                                then EvalCtx_Eval
                                                else @lhs.evalCtx

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Newly bound LamInfo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Here we only gather arity info, stack trace info is assumed to be gathered earlier,
and assumed to propagate correctly when merged with this info.

%%[(8 codegen grin)
SEM CBind
  | Bind        lhs         .   bindLamMp
                                            =   Map.singleton @nm
                                                              (LamInfo (length @expr.grLamArgL) StackTraceInfo_None Nothing)
  | FFI         lhs         .   bindLamMp
                                            =   Map.singleton @nm
                                                              (LamInfo (length @argTyL + length @argTyLExtra) StackTraceInfo_None Nothing)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Variables which are passed as parameter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllCodeNT [ | | asArgNmS USE {`Set.union`} {Set.empty}: FvS ]

SEM CExpr
  | Var         loc         .   mbLam       =   case lamMpLookupLam @nm @lhs.lamMp of
                                                    j@(Just arity) | @lhs.isTopApp
                                                        -> j
                                                    _   -> Nothing
                lhs         .   asArgNmS    =   maybe Set.empty (const (Set.singleton @nm)) @mbLam
  | App         loc         .   mbLam       =   lamMpLookupLam @grAppFun @lhs.lamMp
                            .   appArity    =   length @grAppArgL
                lhs         .   asArgNmS    =   @func.asArgNmS
                                                    `Set.union`  maybe @arg.asArgNmS Set.singleton @arg.mbVar
                                                    `Set.union`  (case @mbLam of
                                                                    Just a | @lhs.isTopApp && @appArity < a
                                                                      -> Set.singleton @grAppFun
                                                                    _ -> Set.empty
                                                                 )
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Grin code, top level
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR CodeAGItf CModule [ | | grMod: GrModule ]

SEM CModule
  | Mod         lhs         .   grMod       =   GrModule_Mod @moduleNm
                                                             @expr.grGlobalL
                                                             @expr.grBindL
                                                             (            primNmList2GrTagMap (grBuiltinTyNmL @lhs.opts)
                                                             `Map.union`  cTagsMp2GrTagMap @ctagsMp
                                                             )
%%]

%%[(8 codegen grin)
ATTR AllExpr [ modNm: HsName | | ]

SEM CModule
  | Mod         expr . gUniq < expr . modNm
                expr . modNm = @moduleNm

%%]


%%[(8 codegen grin) hs

primNmList2GrTagMap :: [HsName] -> Map.Map HsName [GrTag]
primNmList2GrTagMap = Map.fromList . map (\tn -> (tn, [tr tn]))
                where tr nm = let arity = if hsnIsProd nm then hsnProdArity nm else 1
                              in  GrTag_Con (mkGrTagAnn arity arity) 0 nm

cTagsMp2GrTagMap :: CTagsMp -> Map.Map HsName [GrTag]
cTagsMp2GrTagMap = Map.fromList . map (\(tn,ts) -> (tn, tr ts))
             where  tr = map (\(_,(CTag _ nm i a ma)) -> GrTag_Con (mkGrTagAnn a ma) i nm) 

%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Grin code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
grE2V :: GrExpr -> Maybe GrVal
grE2V e = case e of {GrExpr_Unit v -> Just v; _ -> Nothing}

grV2HNm :: GrVal -> Maybe HsName
grV2HNm v = case v of {GrVal_Var n -> Just n; _ -> Nothing}

emptyGrExpr = GrExpr_Unit GrVal_Empty

mbMkStrict :: HsName -> UID -> Bool -> GrVal -> GrExpr
mbMkStrict modNm u isStrict v
  = case v of
      GrVal_Node _ _ -> dflt
      _ | isStrict   -> GrExpr_Seq (GrExpr_Unit v) (GrPatLam_Var n) (GrExpr_Eval n)
        | otherwise  -> dflt
        where n = uidQualHNm modNm u
  where dflt = GrExpr_Unit v

retStrict :: Bool -> GrVal -> GrExpr
retStrict isStrict = if isStrict then (\v->GrExpr_Unit v) else GrExpr_Store
%%]

%%[(8 codegen grin) hs
mkNdPApp :: HsName -> Int -> GrValL -> GrVal
mkNdPApp f nMiss argL = GrVal_Node (GrTag_PApp nMiss f) argL

mkNdApp :: HsName -> GrValL -> GrVal
mkNdApp f argL = GrVal_Node (GrTag_App hsnWild) (GrVal_Var f : argL)

mkSq :: GrExpr -> HsName -> GrExpr -> GrExpr
mkSq e1 p e2 = GrExpr_Seq e1 (GrPatLam_Var p) e2
%%]

%%[(8 codegen grin) hs
simplArgL :: HsName -> UID -> LamMp -> GrValL -> (GrValL,GrExpr->GrExpr)
simplArgL modNm uniq lamMp vL
  =  let  nL = map (uidQualHNm modNm) . mkNewUIDL (length vL) $ uniq
     in   foldr  (\(n,a) (aL,wG)
                    ->  case a of
                            GrVal_Var v | isJust mbArity
                                -> (GrVal_Var n : aL,mkSq a' n . wG)
                                where mbArity = lamMpLookupLam v lamMp
                                      a' = GrExpr_Store (mkNdPApp v (fromJust mbArity) [])
                            GrVal_Node _ _
                                -> (GrVal_Var n : aL,mkSq (GrExpr_Store a) n . wG)
                            _   -> (a:aL,wG)
                 )
                 ([],id)
          $ zip nL vL

saturateAltL :: UID -> GrExpr -> GrAltL -> GrAltL
saturateAltL uniq dflt altL
  =  case altL of
       (GrAlt_Alt _ (GrPatAlt_LitInt _) _ : _)
         | null [ a | a@(GrAlt_Alt _ (GrPatAlt_Otherwise) _) <- altL ]
           -> altL ++ [GrAlt_Alt GrAltAnnNormal (GrPatAlt_Otherwise) dflt]
       _   -> altL
%%]

%%[(10 codegen grin) hs
unboxArg :: HsName -> UID -> HsName -> GrVal -> (GrVal,GrExpr->GrExpr)
unboxArg modNm uniq tyNm v
  =  case v of
       GrVal_LitInt _
           -> (v,id)
       _   -> (GrVal_Var n,GrExpr_Seq (GrExpr_Unit v) (mkGrUnbox tyNm n))
  where n = uidQualHNm modNm uniq

unboxArgL :: HsName -> UID -> HsName -> GrValL -> (GrValL,GrExpr->GrExpr)
unboxArgL modNm uniq tyNm vL
  =  let  uL = mkNewUIDL (length vL) $ uniq
     in   foldr  (\(u,a) (aL,wG)
                    ->  let (a',w) = unboxArg modNm u tyNm a
                        in  (a' : aL, w . wG)
                 )
                 ([],id)
          $ zip uL vL
%%]


%%[(8 codegen grin) hs

mkHole    (GrBind_Bind nm _ _ _)    rest  = GrExpr_Seq (GrExpr_Store (GrVal_Node GrTag_Hole [])) 
                                                       (GrPatLam_Var nm)
                                                       rest

mkVarBind (GrBind_Bind nm _ _ body) rest  = GrExpr_Seq body (GrPatLam_Var nm) rest

mkVarBindWithUpdate
          (GrBind_Bind nm _ _ body) rest  = let nm2 = hsnPrefix "_" nm
                                            in  GrExpr_Seq body 
                                                           (GrPatLam_Var nm2)
                                                           (GrExpr_Seq (GrExpr_FetchUpdate nm2 nm)
                                                                       GrPatLam_Empty 
                                                                       rest
                                                           )

mkHoles               bindL rest  = foldr mkHole              rest bindL
mkVarBindWithUpdates  bindL rest  = foldr mkVarBindWithUpdate rest bindL
mkVarBinds            bindL rest  = foldr mkVarBind           rest bindL

%%]


%%[(8 codegen grin)
ATTR CExpr   [ | | grExpr: GrExpr ]
ATTR CExpr   [ | | grBindL   USE {++} {[]}: GrBindL 
                   grGlobalL USE {++} {[]}: GrGlobalL 
             ]

SEM CExpr
  | Let         (loc.grExpr,lhs.grBindL)    =   if @isGlobal
                                                then  (emptyGrExpr
                                                      ,case @categ of
                                                         CBindings_Rec ->  [GrBind_Rec @binds.grBindL] ++ @body.grBindL
                                                         _             ->              @binds.grBindL  ++ @body.grBindL
                                                      )
                                                else  (case @categ of
                                                         CBindings_Rec ->  mkHoles @binds.grBindL
                                                                           $ mkVarBindWithUpdates @binds.grBindL
                                                                           $ @body.grExpr
                                                         _             ->  mkVarBinds @binds.grBindL @body.grExpr 
                                                      ,[]
                                                      )
  | Case        loc         .   grExpr      =   let  w1 = @alts.grWrapCase
                                                     (sel,w2) = @alts.grWrapCaseSel @expr.grVal
                                                in   w1 . w2 . GrExpr_Case sel . saturateAltL @lUniq @dflt.grExpr $ @alts.grAltL
  | App         loc         .   grExpr      =   let  argL = reverse @grAppArgL
                                                     funNm = @grAppFun
                                                     mkE  = retStrict @lhs.isStrict
                                                     n = uidQualHNm @lhs.modNm @lUniq
                                                     (argL',wrapGr) = simplArgL @lhs.modNm @lUniq2 @lhs.lamMp argL
                                                in   case @func.mbTupApp of
                                                       Just t
                                                         -> let v  =  case t of
                                                                        CTagRec         -> mkGrRecNode argL'
                                                                        CTag _ l t a ma -> mkGrConNode (mkGrTagAnn a ma) t l argL'
                                                            in  wrapGr (mkE v)
                                                       Nothing
                                                         -> let ap = case @mbLam of
                                                                        Just arity
                                                                          | arity == @appArity && @lhs.isStrict
                                                                              -> GrExpr_Call funNm argL'
                                                                          | arity == @appArity
                                                                              -> GrExpr_Store (GrVal_Node (GrTag_Fun funNm) argL')
                                                                          | arity > @appArity
                                                                              -> mkE (mkNdPApp funNm (arity - @appArity) argL')
                                                                          | arity < @appArity && @lhs.isStrict
                                                                              -> mkSq (GrExpr_Call funNm (take arity argL')) n (GrExpr_App n (drop arity argL'))
                                                                          | otherwise
                                                                              -> mkSq (GrExpr_Store (GrVal_Node (GrTag_Fun funNm) (take arity argL'))) n (GrExpr_Store (mkNdApp n (drop arity argL')))
                                                                              -- -> mkSq (GrExpr_Store (mkNdPApp funNm 0 (take arity argL'))) n (GrExpr_Store (mkNdApp n (drop arity argL')))
                                                                        Nothing
                                                                          | @lhs.isStrict
                                                                              -> mkSq (GrExpr_Eval funNm) n (GrExpr_App n argL')
                                                                          | otherwise
                                                                              -> GrExpr_Store (mkNdApp funNm argL')
                                                            in  wrapGr ap
  | Var         loc         .   grExpr      =   mbMkStrict @lhs.modNm @lUniq @lhs.isStrict @grVal
  | Tup Int Char
                loc         .   grExpr      =   retStrict @lhs.isStrict @grVal
  | Ann         loc         .   grExpr      =   @expr.grExpr
%%[[9
  | HoleLet     loc         .   grExpr      =   @body.grExpr	-- when this occurs, there were no bindings for the possible (caused by implicit parameters) bindings encoded by HoleLet
%%]]
%%[[10
  | TupIns TupUpd TupDel
                loc         .   grExpr      =   if @lhs.isTopTup
                                                then  mkGrAdapt @lhs.modNm @lUniq @lhs.lamMp @lhs.isStrict (reverse @grTupFldL) (maybe hsnUnknown id (grV2HNm @grTupRec))
                                                else  GrExpr_Unit GrVal_Empty
%%]]
  | * - Let Case App Var Tup Int Char Ann
%%[[9
    HoleLet
%%]]                                      
%%[[10
    TupIns TupUpd TupDel
%%]]                                      
                loc         .   grExpr      =   GrExpr_Unit @grVal
%%]

%%[(10 codegen grin) hs
type TupAdaptFldL = [(GrVal,GrVal,GrVal->GrVal->GrAdapt)]

mkGrAdapt :: HsName -> UID -> LamMp -> Bool -> TupAdaptFldL -> HsName -> GrExpr
mkGrAdapt modNm u lamMp isStrict tupFldL tupRecNm
  =  let  [u1,u2] = mkNewUIDL 2 (uidChild u)
          (oL,vL,mkAL) = unzip3 tupFldL
          (oL',wrO) = unboxArgL modNm u1 hsnInt oL
          (vL',wrV) = simplArgL modNm u2 lamMp vL
     in   wrV . wrO . retStrict isStrict
          . GrVal_NodeAdapt tupRecNm
          . zipWith3 ($) mkAL oL' $ vL'
%%]

%%[(8 codegen grin)
ATTR CExpr   [ | | grVal: GrVal ]

SEM CExpr
  | Tup         loc         .   grVal       =   ctag (mkGrRecNode []) (\_ l t a ma -> mkGrConNode (mkGrTagAnn a ma) t l []) @tag
  | Var         loc         .   grVal       =   maybe (GrVal_Var @nm) (\a -> mkNdPApp @nm a []) @mbLam
  | Int         loc         .   grVal       =   (if @lhs.doBox then mkGrBox hsnInt  else id)  (GrVal_LitInt @int)
  | Char        loc         .   grVal       =   (if @lhs.doBox then mkGrBox hsnChar else id)  (GrVal_LitInt (ord @char))
  | String      loc         .   grVal       =   (if @lhs.doBox then mkGrBox (ehbnPackedString $ ehcOptBuiltinNames @lhs.opts) else id)  (GrVal_LitStr @str)
  | Ann         loc         .   grVal       =   @expr.grVal
  | * - Int Char String Var Tup Ann
                loc         .   grVal       =   GrVal_Empty
%%]

%%[(97 codegen grin)
SEM CExpr
  | Integer     loc         .   grVal       :=  (if @lhs.doBox then mkGrBox hsnInt  else id)  (GrVal_LitInt $ fromInteger $ @integer)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Do boxing?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR CExpr [ doBox: Bool | | ]

SEM CExpr
  | TupUpd TupIns TupDel
                offset      .   doBox       =   False
                loc         .   doBox       =   True
  | * - TupUpd TupIns TupDel Ann
                loc         .   doBox       =   True

SEM CModule
  | Mod         expr        .   doBox       =   True

SEM CBind
  | Bind        expr        .   doBox       =   True

SEM CPatBind
  | Bind        offset      .   doBox       =   True

SEM CAlt
  | Alt         expr        .   doBox       =   True
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Normal bindings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR CBind CBindL  [ | | grBindL   USE {++} {[]}: GrBindL 
                         grGlobalL USE {++} {[]}: GrGlobalL 
                   ]

SEM CBind
  | Bind        (lhs.grBindL, lhs.grGlobalL)=   if   @bindMeta.isApply0
                                                then let nm2 = case @expr.whatBelow of
                                                                 ExprIsVar n -> n
                                                                 _           -> error "ToGrin: RHS of Apply0-bind is not a variable"
                                                     in  ( [], [GrGlobal_Global @nm (GrVal_Node (GrTag_Fun nm2) [])] )
                                                else ( [GrBind_Bind @nm @bindMeta.grBindAnn @expr.grLamArgL @expr.grLamBody], [] )
                bindMeta    .   lamArgDicts =   @expr.lamArgDicts

%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% FFI binding: IO, requires introduction behavior of EHC.Prelude.ioFromPrim:
%%% extra state param, extra state return (tupled with actual return value)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(98 codegen grin)
SEM CBind
  | FFI         loc         .   mbIORes     =   case tyAppConArgs @resTy of
                                                  Just (n,[a]) | ehbnIO (ehcOptBuiltinNames @lhs.opts) == n
                                                    -> Just a
                                                  _ -> Nothing
                            .   resIsIO     =   isJust @mbIORes
%%]

%%[(8 codegen grin)
SEM CBind
  | FFI         loc         .   resTyAdapted:   Ty
                loc         .   argTyLExtra :   {[Ty]}
                loc         .   nmArgLExtra :   {[HsName]}
                loc         .   wrapRes     :   {GrExpr -> GrExpr}
%%]

%%[(8 codegen grin).ioAdaption
SEM CBind
  | FFI         loc         .   resTyAdapted=   @resTy
                            .   argTyLExtra =   []
                            .   nmArgLExtra =   []
                            .   wrapRes     =   id
%%]

We deal with IO as follow:
- for f defined as FFI with type f :: a -> IO r, we transform the interface and internal wrapping of f = \a -> r into f2 = \a s -> (s, r),
  the wrapping is similar to the one done in EHC.Prelude.ioFromPrim.
- when f :: .. -> IO (), the ffi call result is discarded and () returned instead.
- the extra parameter s is left unevaluated.

%%[(98 codegen grin) -8.ioAdaption
SEM CBind
  | FFI         loc         .   (resTyAdapted,argTyLExtra,nmArgLExtra,wrapRes)
                                            =   case @mbIORes of
                                                  Just iores
                                                    -> (iores,[tyState],[nmState],wrapRes)
                                                    where tyState = Ty_Con $ ehbnRealWorld (ehcOptBuiltinNames @lhs.opts)
                                                          [nmState,nmRes,nmIgnoreRes] = take 3 (map (uidQualHNm @lhs.modNm) (iterate uidNext @lUniq2))
                                                          wrapRes = mkRes . dealWithUnitRes
                                                                  where mkRes r = GrExpr_Seq (unit2store r) (GrPatLam_Var nmRes) (GrExpr_Unit $ mkGrRecNode $ map GrVal_Var [nmState,nmRes])
                                                                        dealWithUnitRes
                                                                                = case tyMbRecExts iores of
                                                                                    Just (_,[]) -> \r -> GrExpr_Seq r (GrPatLam_Var nmIgnoreRes) (GrExpr_Unit $ mkGrRecNode [])
                                                                                    _           -> id
                                                  _ -> (@resTy,[],[],id)
                                                  
{
unit2store :: GrExpr -> GrExpr
unit2store (GrExpr_Seq e p (GrExpr_Unit x))  =  GrExpr_Seq e p (GrExpr_Store x)
unit2store e                                 =  error $ "unit2store applied to non-unit " ++ show e
}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% FFI binding: evaluation need
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The default is to evaluate arguments, and assume the primitive returns an evaluated result.
These defaults are overridden by a table in BuiltinPrims, used here.

%%[(99 codegen grin) hs
evalArg :: Bool -> HsName -> GrExpr
evalArg need nm = if need then GrExpr_Eval nm else GrExpr_Unit (GrVal_Var nm)

evalRes :: Bool -> HsName -> GrExpr -> GrExpr
evalRes need nm e = if need then GrExpr_Seq e (GrPatLam_Var nm) (GrExpr_Eval nm) else e
%%]

%%[(99 codegen grin)
SEM CBind
  | FFI         loc         .   mbPrimNeedEval
                                            =   lookupPrimNeedsEval @impEntNm
                            .   primArgNeedsEvalL
                                            =   maybe (repeat True) (\p -> primArgNeedEval p ++ repeat True) @mbPrimNeedEval
                            .   primResNeedsEval
                                            =   maybe False primResNeedEval @mbPrimNeedEval
%%]

%%[(8 codegen grin).evalRes
SEM CBind
  | FFI         loc         .   evalRes     =   id
%%]

%%[(99 codegen grin).evalRes -8.evalRes
SEM CBind
  | FFI         loc         .   evalRes     =   evalRes @primResNeedsEval @nmEvalRes
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% FFI binding: plain stuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
tyNmIsUnboxedForFFIRes :: EHCOpts -> HsName -> Maybe BasicAnnot
tyNmIsUnboxedForFFIRes opts
  = \n -> fmap biGrinBoxAnnot $ m n
  where m = builtinGrinInfo opts

tyNmMayLiveAsTaggedPtr :: EHCOpts -> HsName -> Maybe BuiltinInfo
tyNmMayLiveAsTaggedPtr opts
  | ehcOptFullProgAnalysis opts = const Nothing
  | otherwise                   = builtinGrinInfo opts
%%]

%%[(8 codegen grin)
SEM CBind
  | FFI         loc         .   (nmRes,nmEvalRes,nmArgL,nmArgPatL)
                                            =   let  (nmRes:nmEvalRes:nmArgL) = take (length @argTyL + 2) (map (uidQualHNm @lhs.modNm) (iterate uidNext @lUniq))
                                                     nmArgPatL = map (hsnPrefix "_") nmArgL
                                                in   (nmRes,nmEvalRes,nmArgL,nmArgPatL)
                lhs         .   grBindL     =   let  isOpaque tn   = maybe True null (dataGamTagsOfTy tn @lhs.dataGam)
                                                     isEnumable tn = maybe False dgiIsEnumable (dataGamLookup tn @lhs.dataGam)
                                                     mbAnnot tn    = tyNmIsUnboxedForFFIRes @lhs.opts tn
                                                     annotOfUnboxed box annot t
                                                       = case tyNmMayLiveAsTaggedPtr @lhs.opts t of
                                                              Just x  -> if biGbcMayLiveUnboxed x
                                                                         then (if   box 
                                                                               then BasicAnnot_ToTaggedPtr 
                                                                               else BasicAnnot_FromTaggedPtr) (biIsSigned x) (baTy annot)
                                                                         else annot
                                                              Nothing -> annot
                                                     mkPat ty n
                                                       =  let tyNm = maybe hsnWild id (@ffiMbTyConNm ty)
                                                              mbAnn = mbAnnot tyNm
                                                          in  --Basic
                                                              if   isJust mbAnn
                                                              then GrPatLam_BasicNode (annotOfUnboxed False (fromJust mbAnn) tyNm) n
                                                              -- Enumerable
                                                              else if isEnumable tyNm
                                                              then GrPatLam_EnumNode n
                                                              -- Record
                                                              else if isJust (tyMbRecRow ty)
                                                              then case tyRecExts ty of
                                                                          (_,exts) -> GrPatLam_Var n
                                                              -- Opaque
                                                              else if isOpaque ty
                                                              then GrPatLam_OpaqueNode n
                                                              -- Pointer
                                                              else GrPatLam_PtrNode n
                                                     mkRes resTy v e
                                                       =  let resTyNm  = maybe hsnWild id (@ffiMbTyConNm resTy)
                                                              mbResAnn = mbAnnot resTyNm
                                                          in  -- Basic
                                                              if isJust mbResAnn
                                                              then GrExpr_Seq e (GrPatLam_BasicAnnot (annotOfUnboxed True (fromJust mbResAnn) resTyNm) @nmRes)
                                                                                (GrExpr_Unit (GrVal_BasicNode (GrTag_Con (mkGrTagAnn 1 1) 0 resTyNm) v))
                                                              -- Enumerable
                                                              else if isEnumable resTyNm
                                                              then GrExpr_Seq e (GrPatLam_EnumAnnot resTyNm @nmRes)
                                                                                (GrExpr_Unit (GrVal_EnumNode v))
                                                              -- Record (which is Enumerable or Pointer)
                                                              else if isJust (tyMbRecRow resTy)
                                                              then let arity = length $ snd $ tyRecExts resTy
                                                                       nm    = builtinRecNm arity
                                                                       tag   = GrTag_Con (mkGrTagAnn arity arity) 0 nm
                                                                   in  if arity==0
                                                                       then GrExpr_Seq e (GrPatLam_EnumAnnot nm @nmRes)     -- 0-tuple is assumed to be Enumerable (change this here, and in the RTS, if the 0-tuple is to be regarded as a basis for extensible rows)
                                                                                         (GrExpr_Unit (GrVal_EnumNode v))
                                                                       else GrExpr_Seq e (GrPatLam_PtrAnnot nm @nmRes)
                                                                                         (GrExpr_Unit (GrVal_PtrNode v))
                                                              -- Opaque
                                                              else if isOpaque resTy
                                                              then GrExpr_Seq e (GrPatLam_OpaqueAnnot @nmRes)
                                                                                (GrExpr_Unit (GrVal_OpaqueNode v))
                                                              -- Pointer
                                                              else GrExpr_Seq e (GrPatLam_PtrAnnot resTyNm @nmRes)
                                                                                (GrExpr_Unit (GrVal_PtrNode v))
%%[[8
                                                     mkEval (n,p)
                                                       = GrExpr_Seq (GrExpr_Eval n) p
%%][96
                                                     mkEval (n,needEval,p)
                                                       = GrExpr_Seq (evalArg needEval n) p
%%]]
                                                in   [GrBind_Bind @nm GrBindAnnNormal (@nmArgL ++ @nmArgLExtra)
                                                        (foldr mkEval
                                                               (@evalRes
                                                                $ @wrapRes
                                                                $ mkRes @resTyAdapted @nmRes
%%[[8
                                                                        (GrExpr_FFI @impEnt
%%][94
                                                                        (GrExpr_FFI @callconv @impEnt
%%]]
%%[[99
                                                                                    (GrFFIAnnot_IsResEval (not @primResNeedsEval))
%%]]
                                                                                    (map GrVal_Var @nmArgPatL
                                                               )        )           )
%%[[8
                                                        $ zip @nmArgL
%%][96
                                                        $ zip3 @nmArgL @primArgNeedsEvalL
%%]]
                                                        $ zipWith mkPat @argTyL
                                                        $ @nmArgPatL
                                                        )
                                                     ]
%%]

%%[(94 codegen grin)
SEM CBind
  | FFE         lhs         .   grBindL     = 	[]	-- not implemented yet
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Case, pattern
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
idGrWrapCaseSel :: GrVal -> (GrVal,GrExpr->GrExpr)
idGrWrapCaseSel s = (s,id)
%%]

%%[(8 codegen grin)
ATTR CAlt    [ | | grAlt: GrAlt ]
ATTR CAltL   [ | | grAltL: GrAltL ]

SEM CAlt
  | Alt         lhs         .   grAlt       =   GrAlt_Alt GrAltAnnNormal @pat.grPat @expr.grExpr

SEM CAltL
  | Cons        lhs         .   grAltL      =   @hd.grAlt : @tl.grAltL
  | Nil         lhs         .   grAltL      =   []
%%]

%%[(8 codegen grin)
ATTR CPat    [ | | patNm: HsName ]

SEM CPat
  | Var Con Int Char
%%[[97
    BoolExpr
%%]]
                loc         .   patNm       =   @pnm
%%]
  | Undef       loc         .   patNm       =   hsnUnknown

%%[(8 codegen grin)
ATTR CPat    [ | | grPat: GrPatAlt ]
-- ATTR CPatL   [ | | grPatL: GrPatL ]    -- obsolete? (JF)

SEM CPat
  | Var         lhs         .   grPat       =   GrPatAlt_Otherwise   -- @patNm
  | Int         lhs         .   grPat       =   GrPatAlt_LitInt @int
  | Char        lhs         .   grPat       =   GrPatAlt_LitInt (ord @char)
  | Con         lhs         .   (grPat,grWrapCase)
                                            =   case @rest.self of
                                                   CPatRest_Empty
                                                     ->  (ctag mkGrPatRecNode (\_ l t a ma -> mkGrPatConNode (mkGrTagAnn a ma) t l) @tag @binds.patNmL,id)
%%[[10
                                                   CPatRest_Var r
                                                     ->  let  (oL,mkSL) = unzip @binds.grTupFldL
                                                              (oL',wrO) = unboxArgL @lhs.modNm @lUniq hsnInt oL
                                                         in   (ctag mkGrPatRecSplit (\_ l t a ma -> mkGrPatConSplit (mkGrTagAnn a ma) t l) @tag r . zipWith ($) mkSL $ oL',wrO)
%%]]                                                         

%%]

%%[(97 codegen grin)
SEM CPat
  | BoolExpr    lhs         .   grPat       =   GrPatAlt_Otherwise -- transformed into explicit if-then-else
                                                                   -- TODO: this is unfinished work, matching on literals does not work yet
%%]

%%[(8 codegen grin)
ATTR AllPatBind [ | | patNmL USE {++} {[]}: {[HsName]} ]

SEM CPatBind
  | Bind        lhs         .   patNmL      =   [@pat.patNm]
%%]

%%[(10 codegen grin)
ATTR AllPatBind [ | | grTupFldL USE {++} {[]}: {[(GrVal,GrVal->GrSplit)]} ]

SEM CPatBind
  | Bind        lhs         .   grTupFldL   =   [(@offset.grVal,\o -> GrSplit_Sel @pat.patNm o)]
%%]

%%[(8 codegen grin)
ATTR AllPat AllAlt [ | | grWrapCase USE {`const`} {id}: {GrExpr -> GrExpr} ]
ATTR AllPat AllAlt [ | | grWrapCaseSel USE {`const`} {idGrWrapCaseSel}: {GrVal -> (GrVal,GrExpr->GrExpr)} ]

SEM CPat
  | Int Char    lhs         .   grWrapCaseSel
                                            =   let n = uidQualHNm @lhs.modNm @lUniq
                                                in  \v -> (GrVal_Var n,GrExpr_Seq (GrExpr_Unit v) (mkGrUnbox hsnInt n))
%%]

%%[(8 codegen grin)
ATTR CPatRest [ | | self: SELF ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Record fields
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
%%]

%%[(8 codegen grin)
ATTR CExpr [ | | grTupRec: GrVal]

%%[[10
ATTR CExpr [ | | grTupFldL: TupAdaptFldL ]
%%]]

SEM CExpr
%%[[10
  | TupIns TupUpd TupDel
                loc         .   grTupRec    =   @expr.grTupRec
  | TupIns      loc         .   grTupFldL   =   (@offset.grVal,@fldExpr.grVal,\o v -> GrAdapt_Ins o v) : @expr.grTupFldL
  | TupUpd      loc         .   grTupFldL   =   (@offset.grVal,@fldExpr.grVal,\o v -> GrAdapt_Upd o v) : @expr.grTupFldL
  | TupDel      loc         .   grTupFldL   =   (@offset.grVal,GrVal_Empty   ,\o _ -> GrAdapt_Del o  ) : @expr.grTupFldL
%%]
  | *
%%[[10  
       - TupIns TupUpd TupDel Ann
                loc         .   grTupFldL   =   []
%%]]                            
                loc         .   grTupRec    =   @grVal
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Let body
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR CExpr [ | | grLetBody: GrExpr ]

SEM CExpr
  | Let         lhs         .   grLetBody   =   @body.grLetBody
  | * - Let Ann lhs         .   grLetBody   =   @grExpr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Lam arg/body info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR CExpr [ | | grLamArgL: {[HsName]}  grLamBody: GrExpr  ]
ATTR CExpr [ | | lamArgDicts: {[[Int]]} ]

SEM CExpr
  | Lam         lhs         .   grLamArgL   =   @arg : @body.grLamArgL
                lhs         .   lamArgDicts =   @argMeta.argDicts ++ @body.lamArgDicts
  | * - Lam Ann lhs         .   grLamArgL   =   []
                lhs         .   grLamBody   =   @grExpr
                lhs         .   lamArgDicts =   []

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% App func/args info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR CExpr [ | | grAppFun: HsName  grAppArgL: GrValL ]

SEM CExpr
  | App         loc         .   grAppFun    =   @func.grAppFun
                            .   grAppArgL   =   @arg.grVal : @func.grAppArgL
  | * - App Ann lhs         .   grAppFun    =   maybe hsnUnknown id . grV2HNm $ @grVal
                            .   grAppArgL   =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Bind meta
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%%[(8 codegen grin)
ATTR AllMetaVal [ lamArgDicts: {[[Int]]} | | ]
ATTR AllMetaVal [ | | grBindAnn : {GrBindAnn} argDicts: {[[Int]]} ]

SEM CMetaVal
  | Val          lhs          .   grBindAnn   =  if null @lhs.lamArgDicts
                                                 then GrBindAnnNormal
                                                 else GrBindAnnOverloaded @lhs.lamArgDicts
                 lhs          .   argDicts    =  []
%%[[9
  | Dict         lhs          .   grBindAnn   =  GrBindAnnNormal
                 lhs          .   argDicts    =  maybe [] (:[]) @mbPos
  | DictClass    lhs          .   grBindAnn   =  GrBindAnnClass @names
                 lhs          .   argDicts    =  []
  | DictInstance lhs          .   grBindAnn   =  GrBindAnnInstance @names
                 lhs          .   argDicts    =  []
%%]]

ATTR AllMetaBind [ | | isApply0 : Bool ]

SEM CMetaBind
  | Apply0       lhs . isApply0  =  True
  | * - Apply0   lhs . isApply0  =  False



-- The synthesized attribute grBindAnn is only needed for CMetaVal's occuring in a CBind_Bind,
-- not for CMetaVal's occuring in a CExpr_Lam.
-- Therefore the inherited attribute lamArgDict is only needed in CBind_Bind, not in CExpr_Lam.

SEM CExpr
  | Lam   argMeta.lamArgDicts = undefined

%%]


