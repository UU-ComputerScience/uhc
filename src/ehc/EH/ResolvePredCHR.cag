%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pred occurrence gathering
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR NTPrf [ | | gathCnstrMp USE {`cnstrMpUnion`} {Map.empty}: CHRPredOccCnstrMp ]

SEM Expr
  | IConst CConst Var Con
                loc         .   hereCnstrMp         =   foGathCnstrMp @fo_
                lhs         .   gathCnstrMp         =   @hereCnstrMp
  | App         loc         .   hereCnstrMp         =   gathPredLToProveCnstrMp @prOccL
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp, @func.gathCnstrMp, @arg.gathCnstrMp]
  | TypeAs      loc         .   hereCnstrMp         =   foGathCnstrMp @fo_
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp, foGathCnstrMp @fo_fitDown, @expr.gathCnstrMp]
  | Let         loc         .   gathCnstrMp         =   cnstrMpUnions [@toProveElsewhereCnstrMp,@body.gathCnstrMp]
  | Lam         loc         .   hereCnstrMp         =   gathPredLToAssumeCnstrMp @knPrL
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp,@arg.gathCnstrMp,@body.gathCnstrMp]
%%[[12
  | LamImpl     loc         .   hereCnstrMp         =   gathPredLToAssumeCnstrMp @knPrL
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp,@arg.gathCnstrMp,@body.gathCnstrMp]
%%]]
  | AppTop      loc         .   hereCnstrMp         =   gathPredLToAssumeCnstrMp @knPrL
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp,@expr.gathCnstrMp]
%%]

%%[10
SEM Expr
  | Sel         loc         .   hereCnstrMp         =   gathPredLToProveCnstrMp @prOccL
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp, @expr.gathCnstrMp]
  | Rec         loc         .   hereCnstrMp         =   foGathCnstrMp @fo_
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp, @recExpr.gathCnstrMp]

SEM RecExpr
  | Ext Upd     loc         .   hereCnstrMp         =   gathPredLToProveCnstrMp @prOccL
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp, @recExpr.gathCnstrMp, @expr.gathCnstrMp]

SEM RecPatExpr
  | Ext         loc         .   hereCnstrMp         =   gathPredLToProveCnstrMp @prOccL
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp, @recPatExpr.gathCnstrMp, @patExpr.gathCnstrMp]
%%]

%%[97
SEM PatExpr
  | Expr        loc         .   hereCnstrMp         =   foGathCnstrMp @fo_
                lhs         .   gathCnstrMp         =   cnstrMpUnions [@hereCnstrMp, @expr.gathCnstrMp]
%%]

%%[9
SEM Decl
  | Instance    loc         .   (chrCtxtAssumeCnstrMp,chrSuperProveCnstrMp,chrInstAssumeCnstrMp,chrCtxtArgUIDL,chrCtxtArgNmL,chrSuperProveUIDL,chrSuperProveNmL,chrInstArgUID,chrInstNm)
                                                    =   let (u:us) = mkNewUIDL (lc + ls + 1) @lUniq6
                                                            (usc,uss) = splitAt lc us
                                                            lc = length @ctxtPrFixL
                                                            ls = length @supPrTyL
                                                            mka p u = mkAssumeConstraint p u @predScope
                                                            mkp p u = mkProveConstraint  p u @predScope
                                                            (dNm,toAssume,toProve)
                                                               = case @instVariant of
                                                                   InstDefault -> ( @dictSelfNm
                                                                                  , emptyCnstrMp
                                                                                  , emptyCnstrMp -- cnstrMpFromList $ zipWith mkp @ctxtPrFixL            usc
                                                                                  )
                                                                   _           -> ( @dictBuildNm
                                                                                  , cnstrMpFromList $ zipWith mka @ctxtPrFixL            usc
                                                                                  , cnstrMpFromList $ zipWith mkp (map tyPred @supPrTyL) uss
                                                                                  )
                                                        in  ( toAssume, toProve
                                                            , cnstrMpFromList [mkAssumeConstraint' (tyPred @hdPrTyFix) u dNm @predScope]
                                                            , usc, map mkHNm usc
                                                            , uss, map mkHNm uss
                                                            , u, dNm
                                                            )
               lhs          .   gathCnstrMp         =   Map.empty
%%[[9
               loc          .	toProveGathCnstrMp	=	@decls.tyVarMp `chrAppSubst` @decls.gathCnstrMp
%%][95
               loc          .   (toProveGathCnstrMp,derivAltsPrOcc)
                                                    =   case @instVariant of
                                                          InstDeriving
                                                            -> ( gathPredLToProveCnstrMp $ foVarMp foDt |=> concat altsPrOcc
                                                               , altsPrOcc
                                                               )
                                                            where ([dataTy],dataAltTy) = tyArrowArgsRes $ dgiDataTy @derivDataDGI
                                                                  alts = tyRecExts2 dataAltTy
                                                                  altsPrOcc
                                                                       = [ [ mkPredOcc (Pred_Class (mkApp [@derivHdPrTyCon,t])) (mkPrId basePrfCtxtId u2) @predScope
                                                                           | ((_,t),u2) <- zip a1 (mkNewUIDL (length a1) u1)
                                                                           ]
                                                                         | ((_,a1),u1) <- zip alts (mkNewLevUIDL (length alts) @lUniq8)
                                                                         ]
                                                                  foDt = fitsIn unifyFIOpts @fe @lUniq9 emptyVarMp dataTy @derivHdDataTy
                                                          _ -> (@decls.tyVarMp `chrAppSubst` @decls.gathCnstrMp,[])
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Proving (predicates) via CHR's
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
simplify env chrStore heur toProveHereCnstrMpPrev toProveHereCnstrMp prevRes
  = ( toProveHereCnstrMpCanon, chrSolveRemCnstrMp2
    , chrSolveEvidMp2, chrSolveEvidBindMp, chrSolveScopeBindMp
    , cannotResCnstrMp
    , firstNotEmpty [chrSolveErrs,ambigErrs]
    , chrSimplifyResult
    , chrSolveEvidCoreMp
    )
  where (_,u1,u2,u3) = mkNewLevUID3 $ fiUniq env
        toProveHereCnstrMpCanon = Map.mapKeys mk toProveHereCnstrMp
          where mk (Prove p) = Prove $ p {cpoPr = predCanonic env $ cpoPr p}
                mk c         = c
        env' = env {fiFIOpts = (fiFIOpts env) {fioDontBind = fixedFtv toProveHereCnstrMpCanon}}
        ((chrSolveRemCnstrMp,chrSolveEvidMp,chrSolveErrs),chrSimplifyResult)
          = chrSimplifyToEvidence (env' {fiUniq = u1}) chrStore heur toProveHereCnstrMpPrev toProveHereCnstrMpCanon prevRes
        (chrSolveRemCnstrMp2,chrSolveEvidMp2,cannotResCnstrMp)
          = patchUnresolvedWithAssumption (env' {fiUniq = u2}) chrSolveRemCnstrMp chrSolveEvidMp
        (chrSolveEvidCoreMp,ambigEvids)
          = evidMpToCore (env' {fiUniq = u3}) chrSolveEvidMp2
        (chrSolveEvidBindMp,chrSolveScopeBindMp)
          = evidKeyCoreMpToBinds chrSolveEvidCoreMp
        ambigErrs = if null ambigEvids then [] else [rngLift range Err_OverlapPreds [ (cpoPr $ ambigevidPredOcc a,map pp $ ambigevidInfos a) | a <- ambigEvids]]
%%[[9
        range = emptyRange
%%][99
        range = feRange $ fiEnv env
%%]]
%%]

%%[9 hs
fixedFtv mp = ftvSet $ map cnstrPred $ Map.keys mp

debugInfo chrSimplifyResult
  = (s,rg,chrSolveStateDoneConstraints s,chrSolveStateTrace s)
  where s  = simpresSolveState chrSimplifyResult
        rg = simpresRedGraph chrSimplifyResult
%%]

%%[9
SEM AGItf
  | AGItf       loc         .   chrProveFIIn		=	@chrFIIn {fiVarMp = @expr.tyVarMp}
                            .   toProveCnstrMp      =   @expr.tyVarMp `chrAppSubst` @expr.gathCnstrMp
                            .   toProveHereCnstrMp  =   @toProveCnstrMp
                            .   (_,chrSolveMainRemCnstrMp,_,chrSolveMainEvidBindMp,chrSolveMainScopeBindMp,_,chrSolveMainErrs,chrSimplifyResult,chrSolveMainEvidCoreMp)
                                                    =   simplify (@chrProveFIIn {fiUniq = @lUniq2}) @chrStore (heurScopedEHC @chrProveFIIn) Map.empty @toProveHereCnstrMp emptySimplifyResult
                            .   (chrSolveMainState,chrSolveMainRedGraph,chrSolveMainDoneConstraints,chrSolveMainTrace)
                                                    =   debugInfo @chrSimplifyResult
                            .   cannotProveCnstrMp	=	@chrSolveMainRemCnstrMp
%%]

%%[9
SEM Expr
  | Let         loc         .   chrProveFIIn		=	@chrFIIn {fiVarMp = @decls.tyVarMp}
                            .   toProveCnstrMp      =   @decls.tyVarMp `chrAppSubst` @decls.gathCnstrMp
                            .   (toProveHereCnstrMp,toProveElsewhereCnstrMp)
                                                    =   Map.partitionWithKey (\k _ -> isLetProveCandidate (Set.fromList @gTyTvL) $ cnstrPred k) @toProveCnstrMp
                            .   (toProveHereCnstrMpCanon,chrSolve1RemCnstrMp,chrSolve1EvidMp,chrSolve1EvidBindMp,chrSolve1ScopeBindMp,cannotRes1CnstrMp,chrSolve1Errs,chrSimplifyResult1,chrSolve1EvidCoreMp)
                                                    =   simplify (@chrProveFIIn {fiUniq = @lUniq5}) @lhs.chrStore (heurScopedEHC @chrProveFIIn) Map.empty @toProveHereCnstrMp emptySimplifyResult
                            .   (chrSolve1State,chrSolve1RedGraph,chrSolve1DoneConstraints,chrSolve1Trace)
                                                    =   debugInfo @chrSimplifyResult1

                            .   (toAssumeNeverCnstrMp,_)
                                                    =   Map.partitionWithKey (\k _ -> isLetProveFailure (Set.fromList @gTyTvL) $ cnstrPred k) @chrSolve1RemCnstrMp
                            .   cannotProveCnstrMp	=	cnstrMpUnions [@toAssumeNeverCnstrMp,@cannotRes1CnstrMp]

                            .   (_,chrSolve2RemCnstrMp,_,chrSolve2EvidBindMp,chrSolve2ScopeBindMp,_,chrSolve2Errs,chrSimplifyResult2,chrSolve2EvidCoreMp)
                                                    =   simplify (@chrProveFIIn {fiUniq = @lUniq4}) @lhs.chrStore (heurScopedEHC @chrProveFIIn) @toProveHereCnstrMpCanon @quantCnstrMp
                                                        $ simplifyResultResetForAdditionalWork @chrSimplifyResult1
                            .   (chrSolve2State,chrSolve2RedGraph,chrSolve2DoneConstraints,chrSolve2Trace)
                                                    =   debugInfo @chrSimplifyResult2
%%]

%%[9
SEM Decl
  | Instance    loc         .   chrProveFIIn		=	@chrFIIn {fiVarMp = @decls.tyVarMp}
                            .   toProveDeclsCnstrMp =   cnstrMpUnions [@chrInstAssumeCnstrMp, @chrCtxtAssumeCnstrMp, @toProveGathCnstrMp]
                            .   (_,chrSolveDeclsRemCnstrMp,_,chrSolveDeclsEvidBindMp,chrSolveDeclsScopeBindMp,cannotResDeclsCnstrMp,chrSolveDeclsErrs,chrDeclsSimplifyResult,_)
                                                    =   simplify (@chrProveFIIn {fiUniq = @lUniq7}) @lhs.chrStore (heurScopedEHC @chrProveFIIn) Map.empty @toProveDeclsCnstrMp emptySimplifyResult
                            .   (chrSolveDeclsState,chrSolveDeclsRedGraph,chrSolveDeclsDoneConstraints,chrSolveDeclsTrace)
                                                    =   debugInfo @chrDeclsSimplifyResult

                            .   toProveSuperCnstrMp =   cnstrMpUnions [@chrCtxtAssumeCnstrMp,@chrSuperProveCnstrMp]
                            .   (_,chrSolveSuperRemCnstrMp,_,chrSolveSuperEvidBindMp,chrSolveSuperScopeBindMp,cannotResSuperCnstrMp,chrSolveSuperErrs,chrSuperSimplifyResult,_)
                                                    =   simplify (@chrProveFIIn {fiUniq = @lUniq5}) @lhs.chrStore (heurScopedEHC @chrProveFIIn) Map.empty @toProveSuperCnstrMp emptySimplifyResult
                            .   (chrSolveSuperState,chrSolveSuperRedGraph,chrSolveSuperDoneConstraints,chrSolveSuperTrace)
                                                    =   debugInfo @chrSuperSimplifyResult

                            .   (toAssumeNeverCnstrMp,_)
                                                    =   Map.partitionWithKey (\k _ -> isLetProveFailure Set.empty $ cnstrPred k)
                                                        $ cnstrMpUnions [@chrSolveDeclsRemCnstrMp,@chrSolveSuperRemCnstrMp]
                            .   cannotProveCnstrMp	=	cnstrMpUnions [@toAssumeNeverCnstrMp,@cannotResDeclsCnstrMp,@cannotResSuperCnstrMp]
%%]

Interaction with existing impl:

%%[9
SEM Expr
  | Let         loc         .   quantPrOccL         =   [ mkPredOcc (cpoPr o) (mkPrIdCHR $ vunmId i) sc
                                                        | (Assume o,[RedHow_Assumption i sc])
                                                            <- Map.toList $ @chrSolve1RemCnstrMp `Map.difference` @cannotProveCnstrMp
                                                        ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional prove requirements + assume introductions yielded by generalization
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
SEM Expr
  | Let         loc         .   (quantCnstrMp, coeArgIdMp)
                                                    =   let mk u nm tmpo
                                                              = (cnstrMpFromList ass `cnstrMpUnion` cnstrMpUnions (map cnstrMpFromList prvs), concat coeArgIds)
                                                              where assSc = maybe @predScope id $ gamLookup nm @decls.scopeGam
                                                                    (ass,prvs,coeArgIds)
                                                                      = unzip3 [ ( mkAssumeConstraint (poPr po) (poId po) assSc
                                                                                 , zipWith (\u i -> mkProveConstraint (poPr po) u (ipoScope i)) ups ipos
                                                                                 , zipWith (\i u -> (ipoId i,u)) ipos ups
                                                                                 )
                                                                               | ((po,ipos),u') <- zip impls $ mkNewLevUIDL (length impls) u
                                                                               , let ups = mkNewLevUIDL (length ipos) u'
                                                                               ]
                                                                      where impls = tmpoImplsPrvReq tmpo
                                                            tmpos = gamToAssocL @tqoGam
                                                            (quantCnstrMps, coeArgIds) = unzip $ zipWith (\(nm,tmpo) u -> mk u nm tmpo) tmpos (mkNewLevUIDL (length tmpos) @lUniq6)
                                                        in  ( cnstrMpUnions quantCnstrMps
                                                            , foldr (\(occ,arg) m -> Map.insertWith (++) occ [arg] m) Map.empty $ concat coeArgIds
                                                            )
                            .   prvArgCSubst        =   uidImplsLToCSubst [ (occ, ([mkAppCoe $ map (mkCExprHole @lhs.opts) args], [])) | (occ,args) <- Map.toList @coeArgIdMp ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Propagation of bindings resulting from assumptions downwards
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9
ATTR NTPrf [ chrEvidBindMp: EvidKeyToCBindMap   chrScopeBindMp: PredScopeToCBindMap | | ]

SEM AGItf
  | AGItf       loc         .   chrEvidBindMp       =   @chrSolveMainEvidBindMp
                            .   chrScopeBindMp      =   @chrSolveMainScopeBindMp

SEM Decl
  | Instance    loc         .   chrEvidBindMp       =   @chrSolveDeclsEvidBindMp `evidKeyToCBindMapUnion` @lhs.chrEvidBindMp
                            .   chrScopeBindMp      =   @chrSolveDeclsScopeBindMp `predScopeToCBindMapUnion` @lhs.chrScopeBindMp

SEM Expr
  | Let         loc         .   chrSolveEvidBindMp  =   @chrSolve2EvidBindMp
                            .   chrEvidBindMp       =   @chrSolveEvidBindMp `evidKeyToCBindMapUnion` @lhs.chrEvidBindMp
                            .   chrSolveScopeBindMp =   @chrSolve2ScopeBindMp
                            .   chrScopeBindMp      =   @chrSolveScopeBindMp `predScopeToCBindMapUnion` @lhs.chrScopeBindMp
%%]
  | Let         loc         .   chrSolveEvidBindMp  =   @chrSolve2EvidBindMp `evidKeyToCBindMapUnion` @chrSolve1EvidBindMp
                            .   chrEvidBindMp       =   @chrSolveEvidBindMp `evidKeyToCBindMapUnion` @lhs.chrEvidBindMp
                            .   chrSolveScopeBindMp =   @chrSolve2ScopeBindMp `predScopeToCBindMapUnion` @chrSolve1ScopeBindMp
                            .   chrScopeBindMp      =   @chrSolveScopeBindMp `predScopeToCBindMapUnion` @lhs.chrScopeBindMp

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Bindings depending on scope
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
mkScopeBindings :: Bool -> PredScope -> PredScopeToCBindMap -> [CBind]
mkScopeBindings alsoOuter sc mp
  = concatMap f scs
  where f sc = Map.findWithDefault [] sc mp
        scs  = if alsoOuter then sc : pscpParents sc else [sc]
%%]

%%[9
SEM AGItf
  | AGItf       loc         .   chrScopeMainBindL   =   mkScopeBindings True @predScope @chrScopeBindMp

SEM Decl
  | Instance    loc         .   chrScopeSuperBindL  =   mkScopeBindings True @predScope @chrSolveSuperScopeBindMp
                            .   chrScopeDeclsBindL  =   mkScopeBindings True @predScope @chrSolveDeclsScopeBindMp
  | Val         loc         .   chrScopeValBindL    =   mkScopeBindings False @predScope @lhs.chrScopeBindMp

SEM Expr
  | Let         loc         .   chrScopeBindL       =   mkScopeBindings True @predScope @chrSolveScopeBindMp
  | Lam AppTop
%%[[12
    LamImpl
%%]]
                loc         .   chrScopeBindL       =   mkScopeBindings False @predScope @lhs.chrScopeBindMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Bindings for assumed preds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[9 hs
mkAssumeBindings :: [UID] -> EvidKeyToCBindMap -> [CBind]
mkAssumeBindings ids mp
  = concat [ maybe [] id $ Map.lookup i mp | i <- ids ]
%%]

%%[9
SEM Decl
  | Instance    loc         .   chrAssumeSuperBindL     =   mkAssumeBindings @chrCtxtArgUIDL @chrSolveSuperEvidBindMp
                            .   chrAssumeDeclsInstBindL =   mkAssumeBindings [@chrInstArgUID] @chrEvidBindMp
                            .   chrAssumeDeclsCtxtBindL =   mkAssumeBindings @chrCtxtArgUIDL @chrEvidBindMp

SEM Expr
  | Lam AppTop
%%[[12
    LamImpl
%%]]
                loc         .   chrAssumeBindL      =   mkAssumeBindings (map poiId @poiL) @lhs.chrEvidBindMp
%%]
