%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 hs module {%{GRIN}Silly.PrettyLLVM} import(Char, Data.Maybe, Data.List, UU.Pretty, EH.Util.PPUtils,{%{GRIN}GRINCCommon},{%{GRIN}Silly}, {%{GRIN}Config}) export(prettyLL)
%%]

%%[8 import({Silly/AbsSyn})
%%]

%%[8 hs
prettyLL :: Bool -> Bool -> SilModule -> PP_Doc
prettyLL optTrace optDef silmod
  = let t = wrap_SilModule (sem_SilModule silmod) 
                           (Inh_SilModule { }
                           )
     in  code_Syn_SilModule t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Options to adapt the structure of the generated code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%[8

WRAPPER SilModule

ATTR SilModule Functions Function 
     Statements Statement Alternatives 
     Alternative Value Variable Constant
     
     [ | | code USE {>-<} {empty} : PP_Doc ]

ATTR Values [ | | codes : {[PP_Doc]} ]

--------------------------------------------------------------------------------
-- MODULE GENERATION
--------------------------------------------------------------------------------

SEM SilModule
  | SilModule   lhs.code  = header
                                >-< text ""
                                >-< comment "Constants"
                                >-< ppVertically (map constantDefinition @constants)
                                >-< text ""
                                >-< comment "Globals"
                                >-< ppVertically (map variableDeclaration @variables)
                                >-< text ""
                                >-< text ""
                                >-< "implementation"
                                >-< text ""
                                >-< text ""
                                >-< @functions.code

{
header :: PP_Doc
header = comment "LLVM Code Generated From Grin"
         >-< ""
         >-< comment "Platform Constants"
         >-< "target pointersize = 32"
         >-< "deplibs = [ \"c\" ]"
         >-< ""
         >-< comment "Runtime Library Functions"
         >-< "%thunk_type = type uint"
         >-< "declare void %main()"
         >-< "declare void %switch_trap()"
         >-< "declare %thunk_type* %heapalloc( uint )"
         >-< "declare uint %primGtInt( uint, uint)"
         >-< "declare uint %primAddInt( uint, uint)"
         >-< ""
         >-< comment "Runtime Library Constant Variables"
         >-< "%Heap       = external global %thunk_type*"
         >-< "%Stack      = external global %thunk_type*"
         >-< "%ReturnArea = external global %thunk_type*"
         >-< "%HeapLimit  = external global %thunk_type*"
         >-< ""
         >-< comment "Runtime Library Pointers"
         >-< "%HP = external global %thunk_type*"
         >-< "%SP = external global %thunk_type*"
         >-< "%RP = external global %thunk_type*"
         >-< "%BP = external global %thunk_type*"
         >-< ""

constantDefinition :: (String,Int) -> PP_Doc
constantDefinition (x,n) = ";" >#< x >#< "=" >#< show n

variableDeclaration :: String -> PP_Doc
variableDeclaration x = "%" >|< text x >#< "= global %thunk_type undef"
}

--------------------------------------------------------------------------------
-- FUNCTION DECLARATION GENERATION
--------------------------------------------------------------------------------
SEM Function
  | Function    lhs.code   = prefix >-< indent 3 
                                          (foldr (\x y -> localVarDecl x >-< y)
                                                 empty @locals)
                                    >-< indent 3 @body.code
                                    >-< indent 3 (text "ret void")
                                    >-< postfix
                                   where prefix  = "void %" >|< @name >#< "() {"
                                         postfix = "}" >-< text ""
{
localVarDecl :: String -> PP_Doc
localVarDecl x = "%" >|< x >#< "= alloca" >#< ptr Thunk
}
--------------------------------------------------------------------------------
-- PROPOGATION OF INFORMATION WITHIN FUNCTION
--------------------------------------------------------------------------------
ATTR Statements Statement  
     Alternatives Alternative 
     Variables Variable 
     Values Value
     [ islocal : {String -> Bool} | uniq : {Int} | ]

SEM Function
  | Function    body.islocal  = (\x -> x `elem` @locals)
                body.uniq     = 0

                
--------------------------------------------------------------------------------
-- PROPAGATING CONSTANT SUBSTITUTIONS
--------------------------------------------------------------------------------
ATTR Functions Function Statements Statement  Alternatives 
     Alternative  Variables Variable Values Value Constant
[ constants : {[(String,Int)]} | | ]

SEM SilModule
  | SilModule   functions.constants = @constants


--------------------------------------------------------------------------------
-- Function Entry / Exit
--------------------------------------------------------------------------------
{
enter :: Int -> Int -> PP_Doc
enter i j =  
             comment "Function Entry"
         >-< "; store current BasePointer value on Stack"
         >-< load' "BP.deref" "BP" ThunkPtrPtr
         >-< load' "SP.deref" "SP" ThunkPtrPtr
         >-< cast "BP.cast" ThunkPtr "BP.deref" Thunk
         >-< store "BP.cast" Thunk "SP.deref"
         >-< ""
         >-< "; Set BasePointer equal to StackPointer"
         >-< store "SP.deref" ThunkPtr "BP" 
         >-< ""
         >-< "; increment StackPointer"
         >-< ptrAdd "SP.incr" "SP.deref" ThunkPtr (i+1)
         >-< store "SP.incr" ThunkPtr "SP"
         >-< ""
         >-< ""

exit :: Int -> PP_Doc
exit i =  
          comment "Function Exit"
      >-< "; restore StackPointer and BasePointer"
      >-< store "SP.deref" ThunkPtr "SP"
      >-< cast "BP.recast" Thunk "BP.cast" ThunkPtr
      >-< store "BP.recast" ThunkPtr "BP"
      >-< if i /= 0 
          then ptrAdd "SP.incr_exit" "SP.deref" ThunkPtr i
               >-< store "SP.incr_exit" ThunkPtr "SP"
          else empty
      >-< ""
}


--------------------------------------------------------------------------------
-- Utility Functions
--------------------------------------------------------------------------------

{
comment :: String -> PP_Doc
comment s = "; ----" >#< s >#< "----"

get :: String -> [(String, Int)] -> Int
get name table = if null res then error msg else head res
   where res = [ b | (a,b) <- table, a == name]
         msg = "constant: " ++ name ++ " not found!"

p :: Show a => a -> PP_Doc
p x = text $ show x
}

--------------------------------------------------------------------------------
-- Code for Statements
--------------------------------------------------------------------------------

ATTR Variable Value [ | | resultName : {String} ]
ATTR Values [ | | resultNames : {[String]} ]

SEM Statement
  | Comment     lhs.code   = comment @comment
  {- Possible optimization: If a variable local to a function is defined only once
                            , then we can omit allocating a variable on the stack and
                            suffice giving it a name in an LLVM assignment. -}
  | Assignment  lhs.code   = ";------------------------------------------------------"
                             >-< (";" >#< @dest.descr >#< "=" >#< @source.descr)
                             >-< ";------------------------------------------------------"
                             >-< @source.code 
                             >-< @dest.code 
                             >-< (if @doCast
                                  then cast @storee @source.ty 
                                            @source.resultName @storety
                                  else empty
                                 )
                             >-< store @storee @storety @dest.resultName
                loc.doCast = not $ isPtrTypeOf @dest.ty @source.ty
                loc.storee = if @doCast 
                             then "cast." ++ show @uniq
                             else @source.resultName
                loc.storety = deref @dest.ty
                loc.uniq    = @lhs.uniq
                dest.uniq   = @uniq + 1
                source.uniq = @dest.uniq
                lhs.uniq    = @source.uniq

  | Switch      lhs.code       = @scrutinee.code
                                 >-< "switch uint" >#< pct @scrutinee.resultName
                                 >|< ", label %switch_trap." >|< @uniq 
                                 >-< "[" >-< @body.jmptbl >|< "]" 
                                 >-< @body.code >|< "switch_trap." >|< @uniq >|< ":"
                                 >-< indent 3 ("tail call void %switch_trap()" 
                                               >-< "ret void")
                                 >-< "switch_end." >|< @uniq >|< ":"
                loc.uniq       = @lhs.uniq
                scrutinee.uniq = @lhs.uniq + 1
                body.uniq      = @scrutinee.uniq
                lhs.uniq       = @body.uniq
                body.break     = "br label %switch_end." >|< @uniq

  | Call        lhs.code   = call @name -- explicit params never provided
  | Jump        lhs.code   = call @name
  | Enter       lhs.code   = enter @nLocal @nParam
  | Leave       lhs.code   = exit @diff


ATTR Alternatives Alternative [ break : {PP_Doc} | | jmptbl : {PP_Doc} ]
SEM Alternatives
  | Nil   lhs.jmptbl  = text ""
          lhs.code    = text ""
  | Cons  lhs.jmptbl  = @hd.jmptbl >-< @tl.jmptbl
          lhs.code    = @hd.code   >-< @tl.code

SEM Alternative
  | Alternative lhs.jmptbl     = indent 3 ("uint" >#< @when.code >|< ", label %" >|< @label)
                lhs.code       = @label >|< ":" >-< indent 3 (@body.code >-< @lhs.break)
                loc.label      = "case." >|< @uniq
                loc.uniq       = @lhs.uniq
                body.uniq      = @uniq + 1
                lhs.uniq       = @body.uniq

SEM Values
  | Nil         lhs.codes       = []
                lhs.resultNames = []
  | Cons        lhs.codes       = @hd.code : @tl.codes
                lhs.resultNames = @hd.resultName : @tl.resultNames

SEM Value
  | Con         lhs.code       = empty
                lhs.resultName = show @con.code
  | Var         lhs.code       = @var.code
                lhs.resultName = @var.resultName
  | Call        lhs.code       = (foldr (>-<) empty @args.codes)
                                 >-< "%" >|< @resultName >#< "=" >#< call' @name @args.resultNames @ty
                loc.resultName = "call." ++ show @uniq
                lhs.resultName = @resultName
                loc.uniq       = @lhs.uniq
                args.uniq      = @uniq + 1
                lhs.uniq       = @args.uniq
  | Alloc       lhs.code       = "%" >|< @result >#< "=" >#< heapalloc @size
                lhs.resultName = @result
                loc.result     = "alloc." ++ show @uniq
                loc.uniq       = @lhs.uniq
                lhs.uniq       = @uniq + 1



ATTR Constant [ | | value : {Int} ]
SEM Constant
  | LiteralInt  lhs.code   = text $ show @value
                lhs.value  = @value
  | LiteralStr  lhs.code   = error "Code generation for LiteralStr is not supported (yet)"
                lhs.value  = error "Code generation for LiteralStr is not supported (yet)"
  | Alias       lhs.code   = "" >|< get @name @lhs.constants
                lhs.value  = @val
                loc.val    = get @name @lhs.constants

SEM Variable
  {- Possible optimization: If a variable local to a function is defined only once
                            , then you can fetch a substitution here, instead of 
                            loading the variable
  -}
  | Var         lhs.code   = if isLHS @lhs.side
                             then empty
                             else load @name @uniq (ptrOf @ty)
                loc.uniq   = @lhs.uniq
                lhs.uniq   = @loc.uniq + 1
                lhs.resultName = if isLHS @lhs.side
                                 then @name
                                 else @name ++ "." ++ show @loc.uniq
  | SP          lhs.code       = if isLHS @lhs.side
                                 then empty
                                 else load "SP" @uniq ThunkPtrPtr
                lhs.resultName = if isLHS @lhs.side
                                 then "SP"
                                 else "SP." ++ show @uniq
                loc.uniq       = @lhs.uniq
                lhs.uniq       = @loc.uniq + 1
  | BP          lhs.code       = if isLHS @lhs.side
                                 then empty
                                 else load "BP" @uniq ThunkPtrPtr
                lhs.resultName = if isLHS @lhs.side
                                 then "BP"
                                 else "BP." ++ show @uniq
                loc.uniq       = @lhs.uniq
                lhs.uniq       = @loc.uniq + 1
  | RP          lhs.code       = if isLHS @lhs.side
                                 then empty
                                 else load "RP" @uniq ThunkPtrPtr
                lhs.resultName = if isLHS @lhs.side
                                 then "RP"
                                 else "RP." ++ show @uniq
                loc.uniq       = @lhs.uniq
                lhs.uniq       = @loc.uniq + 1
  | Subs        lhs.code       = @array.code
                                 >-<
                                 (if @array.ty /= ThunkPtr
                                  then (cast ("cast." ++ show @uniq) 
                                            @array.ty 
                                            @array.resultName 
                                            ThunkPtr
                                        >-< ptrAdd @arithName 
                                                   ("cast." ++ show @uniq)
                                                   ThunkPtr
                                                   @index.value
                                       )
                                  else ptrAdd @arithName 
                                              @array.resultName
                                              ThunkPtr
                                              @index.value                
                                 )
                                 >-<
                                 (if isLHS @lhs.side 
                                  then empty
                                  else load @arithName (@uniq + 1) ThunkPtr
                                 )
                loc.arithName  = "subs." ++ show (@uniq + 1)
                lhs.resultName = if isLHS @lhs.side
                                  then @arithName
                                  else @arithName ++ "." ++ (show $ @uniq + 1)
                loc.uniq       = @lhs.uniq
                array.uniq     = @uniq + 2
                lhs.uniq       = @array.uniq


--------------------------------------------------------------------------------
-- LHS/RHS ROLE	FOR VARIABLES
--------------------------------------------------------------------------------
{
data Side = LHS | RHS

isLHS :: Side -> Bool
isLHS LHS = True
isLHS _   = False

isRHS :: Side -> Bool
isRHS RHS = True
isRHS _   = False

}

ATTR Variables Variable [ side : {Side} | | ]

SEM Statement
  |  Assignment  dest.side   = LHS
SEM Variable
  |  Subs        array.side  = RHS
SEM Value
  | Var          var.side    = RHS
  

--------------------------------------------------------------------------------
-- VARIABLE/VALUE POINTER TYPES
--------------------------------------------------------------------------------
{
data PtrType = Thunk | ThunkPtr | ThunkPtrPtr deriving (Show,Eq,Enum)

ptr :: PtrType -> PP_Doc
ptr Thunk          = text "%thunk_type"
ptr ThunkPtr       = text "%thunk_type*"
ptr ThunkPtrPtr    = text "%thunk_type**"

deref :: PtrType -> PtrType
deref p = pred p

ptrOf :: PtrType -> PtrType
ptrOf p = succ p

ptrptr :: PtrType -> PP_Doc
ptrptr p = ptr p >|< "*"

isPtrTypeOf :: PtrType -> PtrType -> Bool
isPtrTypeOf ptr val = succ val == ptr
}

ATTR Variable Value [ | | ty : {PtrType}]
ATTR Variable [ | | local : {Bool}]

SEM Variable
  | Var         loc.ty    = if isLHS @lhs.side
                            then ThunkPtr
                            else Thunk
                lhs.ty    = @loc.ty
                lhs.local = @lhs.islocal @name
  | SP          loc.ty    = if isLHS @lhs.side 
                            then ThunkPtrPtr
                            else ThunkPtr
                lhs.ty    = @loc.ty
                lhs.local = False
  | BP          loc.ty    = if isLHS @lhs.side 
                            then ThunkPtrPtr
                            else ThunkPtr
                lhs.ty    = @loc.ty
                lhs.local = False
  | RP          loc.ty    = if isLHS @lhs.side 
                            then ThunkPtrPtr
                            else ThunkPtr
                lhs.ty    = @loc.ty
                lhs.local = False
  | Subs        loc.ty    = if isLHS @lhs.side
                            then ThunkPtr
                            else Thunk -- result of array access is always a thunk
                lhs.ty    = @loc.ty
                lhs.local = False

SEM Value
  | Con         loc.ty  = Thunk
                lhs.ty  = @loc.ty
  | Var         loc.ty  = @var.ty
                lhs.ty  = @loc.ty
  | Alloc       loc.ty  = ThunkPtr
                lhs.ty  = @loc.ty
  | Call        loc.ty  = Thunk
                lhs.ty  = @loc.ty


--------------------------------------------------------------------------------
-- COMMENTING CODE
--------------------------------------------------------------------------------
ATTR Variable Value Constant Values [ | | descr : {PP_Doc} ]

SEM Variable
  |  Var    lhs.descr = text @name
  |  Subs   lhs.descr = @array.descr >|< "[" >|< @index.descr >|< "]"
  |  SP     lhs.descr = text "SP"
  |  BP     lhs.descr = text "BP"
  |  RP     lhs.descr = text "RP"

SEM Value
  | Con     lhs.descr = @con.descr
  | Var     lhs.descr = @var.descr
  | Alloc   lhs.descr = "heapalloc(" >|< @size >|< ")"
  | Call    lhs.descr = @name >|< "(" >#< @args.descr >#< ")"

SEM Constant
  | LiteralStr lhs.descr = text @value
  | LiteralInt lhs.descr = "" >|< show @value
  | Alias      lhs.descr = text @name

SEM Values
  | Nil     lhs.descr = empty
  | Cons    lhs.descr = @hd.descr >#< "," >#< @tl.descr

--------------------------------------------------------------------------------
-- LL Primitives
--------------------------------------------------------------------------------

{
call :: String -> PP_Doc
call f = "tail call" >#< "void" >#< pct f >#< "()"

call' :: String -> [String] -> PtrType -> PP_Doc
call' f args rty = 
  let  pp_args = map (\x -> ptr Thunk >#< pct x) args
   in  "tail call" >#< ptr rty >#< pct f 
                   >#< "(" >#< (foldr1 (\x y -> x >#< "," >#< y) pp_args) >#< ")"
  
                     

ptrAdd :: String -> String -> PtrType -> Int -> PP_Doc
ptrAdd l r ty i = pct l >#< "= getelementptr" 
                        >#< ptr ty >#< pct r 
                        >|< ", int" >#< i

load :: String -> Int -> PtrType -> PP_Doc
load nm i p = pct nm >|< "." >|< i >#< "= load" >#< ptr p >#< pct nm

load' :: String -> String -> PtrType -> PP_Doc
load' dst src ty = pct dst >#< "= load" >#< ptr ty >#< pct src

store :: String -> PtrType -> String -> PP_Doc
store val ty adr = "store" >#< ptr ty >#< pct val 
                           >|< "," >#< ptrptr ty >#< pct adr

cast :: String -> PtrType -> String -> PtrType -> PP_Doc
cast lhs ty var ty' = pct lhs >#< "= cast" 
                              >#< ptr ty >#< pct var 
                              >#< "to" >#< ptr ty'

heapalloc :: Int -> PP_Doc
heapalloc ps = "tail call %thunk_type*" 
               >#< "%heapalloc (uint " 
               >|< ps 
               >|< ")"

pct :: String -> String
pct s = if isNumber s then s else "%" ++ s
   where isNumber s = foldr (&&) True $ map isDigit s

showSubs :: [(String,String)] -> String
showSubs []  = ""
showSubs xs  = "substitutions: " ++ show xs'
   where xs' = map (\(a,b) -> a ++ " -> " ++ b) xs
}

%%]
