% $Id$

Rename all identifiers to unique numbers. exceptions are the FFI names (and
primitives) as well as the eval and apply function names (which do not exist anymore).

To rename efficient we can use the fact that the scope of a variable is local
to a binding, but it's easier not to.

Note: after each binding we skip one number (binding needs two number in the HPTA)


%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[8 import("../GrinCodeAbsSyn")
%%]

%%[8.wrapper
WRAPPER GrAGItf
%%]

%%[8 hs module Trf.NumberIdents import(GRINCCommon, EHCommon, GrinCode, Data.Array.IArray, "qualified Data.Map as Map", Data.Maybe) export(numberIdents)

numberIdents :: Int -> HsName -> GrModule -> (Int, HsName, GrModule, IdentNameMap, Int)
numberIdents u entry grmod = let t          = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf grmod))
                                                           (Inh_GrAGItf { unique_Inh_GrAGItf = u, entry_Inh_GrAGItf = entry })
                                 nrOfBinds  = nrOfBinds_Syn_GrAGItf t
                                 newU       = unique_Syn_GrAGItf t
                                 newGrMod   = grTrf_Syn_GrAGItf  t
                                 varMap     = varMap_Syn_GrAGItf t
                                 newEntry   = entry_Syn_GrAGItf  t
                             in (newU, newEntry, newGrMod, varMap, newU - u - nrOfBinds)
%%]

%%[8.lookup hs
type LookupList = Map.Map HsName HsName

findNewVar fm e = Map.findWithDefault (error $ "undeclared variable " ++ show e) e fm

addMaybe u fm = maybe (fm, u) addName
	where
	addName e | e == wildcardNm  = (fm                       , u  )
	          | otherwise        = (Map.insert e (HNPos u) fm, u+1)

addList u fm = onFst (flip listInsert fm) . foldr addName ([], [], u)
	where
	onFst f (a, b, c)                       = (f a          , b             , c  )
	addName e (l, l2, u) | e == wildcardNm  = (l            , wildcardNr:l2 , u  )
	                     | otherwise        = ((e,HNPos u):l, ((HNPos u):l2), u+1)
%%]

%%[8.grTrf
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllGrNT [ | | grTrf: SELF     ]
%%]

%%[8.unique
ATTR GrAGItf          [ | unique: Int | ]
ATTR AllGrNT          [ | unique: Int | ]

SEM GrAGItf
  | AGItf  loc     .  low         = @lhs.unique
                   .  high        = @module.unique
%%]

%%[8.translateEntry
ATTR GrAGItf [ | entry: HsName | ]
SEM GrAGItf
  | AGItf  lhs . entry = fromJust $ Map.lookup @lhs.entry @bind2id
%%]

%%[8.maps
ATTR GrAGItf          [ | | varMap:  IdentNameMap ]
ATTR AllGrNT          [ bind2id: LookupList  | var2id: LookupList | ]
ATTR GrModule AllBind [ | bind2idFrag: LookupList | ]
ATTR GrModule         [ | | globalVars: LookupList ]

SEM GrAGItf
  | AGItf  module  .  bind2idFrag  = Map.empty
                   .  var2id       = Map.empty
           loc     .  bind2id      = @module.bind2idFrag
                   .  bind2idList  = Map.toList @module.bind2idFrag
                   .  var2idList   = Map.toList @module.var2id
                   .  bindMapping  = concat [ [(i, n), (i+1, n)] | (n, HNPos i) <- @bind2idList, not (n `elem` [applyNm, evalNm]) ] -- ugly
                   .  varMapping   = let changeCaf n = if Map.member n @module.globalVars then hsnSuffix n "$global" else n
                                     in [ (i, changeCaf n) | (n, HNPos i) <- @var2idList ]
                   .  varMap       = (array (@low, @high-1) (@bindMapping ++ @varMapping), Map.empty)

SEM GrModule
  | Mod  lhs  .  globalVars  =  @globalL.var2id
%%]

retrieving names and their mapping

%%[8.addMbFM hs import(Debug.Trace)
addMbToMap fm mbk mbv = maybe fm id mbMap
    where
    mbMap = do
        k <- mbk
        v <- mbv
        return $ Map.insert k v fm
%%]

%%[8.bindings
SEM GrBind
  | Bind  loc  .  (bindName, unique')  =  if @nm == applyNm
                                          then (applyNr          , @lhs.unique  )
                                          else if @nm == evalNm
                                          then (evalNr           , @lhs.unique  )
                                          else (HNPos @lhs.unique, @lhs.unique+2)
               .  bind2idFrag          = if isSpecialBind @nm
                                         then @lhs.bind2idFrag
                                         else Map.insert @nm @bindName @lhs.bind2idFrag
%%]

%%[8.TagName
SEM GrTag [ | | varName: {Maybe HsName} ]
  | Var       lhs  .  varName  =  Just @nm
  | * - Var   lhs  .  varName  =  Nothing
%%]

%%[8.GetDefinedNames
SEM GrGlobal
  | Global    loc   .  newName  = HNPos @lhs.unique
              lhs   .  var2id   = Map.insert @nm @newName @lhs.var2id
                    .  unique   = @lhs.unique + 1

SEM GrPat
  | Node       loc  .  (var2id', newNames, unique') = addList @lhs.unique @lhs.var2id @fldL
  | Tag        loc  .  var2id'  = @lhs.var2id
                    .  unique'  = @unique'
  | Var        lhs  .  var2id   = Map.insert @nm @newName @lhs.var2id
                    .  unique   = @lhs.unique + 1
               loc  .  newName  = HNPos @lhs.unique
  | Node Tag   loc  .  (var2id , unique )  = addMaybe @unique' @var2id' @tag.varName
               loc  .  newTag              = maybe @tag.grTrf GrTag_Var @tag.varName

SEM GrExpr
  | Catch      handler  .  var2id   = Map.insert @arg @newName @body.var2id
                        .  unique   = @body.unique + 1
               loc      .  newName  = HNPos @body.unique
 
SEM GrBind
  | Bind      loc   .  (var2id', newNames, unique'')  =  addList @unique' @lhs.var2id @argNmL
              expr  .  var2id                         =  @var2id'
                    .  unique                         =  @unique''
              lhs   .  unique                         =  @expr.unique
                    .  var2id                         =  @expr.var2id
%%]

replacing every identifier with a number

%%[8.ReplaceIdents
SEM GrGlobal
  | Global  lhs  .  grTrf  =  GrGlobal_Global @newName @val.grTrf

SEM GrPat
  | Node  lhs  .  grTrf  = GrPat_Node @newTag @newNames
  | Tag   lhs  .  grTrf  = GrPat_Tag  @newTag
  | Var   lhs  .  grTrf  = GrPat_Var  @newName

SEM GrBind
  | Bind  lhs  .  grTrf    = GrBind_Bind @bindName @newNames @newExpr
          loc  .  newExpr  = @expr.grTrf

SEM GrVal
  | Var  lhs  .  grTrf  = GrVal_Var (findNewVar @lhs.var2id @nm)

SEM GrTag
  | Var  lhs  .  grTrf  = GrTag_Var (findNewVar @lhs.var2id @nm)

SEM GrExpr
  | App Eval Fetch Update Throw  loc  .  newName  =  findNewVar @lhs.var2id @nm
  | App                          lhs  .  grTrf    =  GrExpr_App     @newName @argL.grTrf
  | Eval                         lhs  .  grTrf    =  GrExpr_Eval    @newName
  | Call                         loc  .  newName  =  findNewVar     @lhs.bind2id @nm
                                 lhs  .  grTrf    =  GrExpr_Call    @newName @argL.grTrf
  | Fetch                        lhs  .  grTrf    =  GrExpr_Fetch   @newName @mbOffset @mbTag
  | Update                       lhs  .  grTrf    =  GrExpr_Update  @newName @val.grTrf @mbTag
  | Throw                        lhs  .  grTrf    =  GrExpr_Throw   @newName
  | Catch                        lhs  .  grTrf    =  GrExpr_Catch   @body.grTrf @newName @handler.grTrf
  | FFI                          lhs  .  grTrf    =  GrExpr_FFI @nm (map (findNewVar @lhs.var2id) @argL)

SEM GrModule
  | Mod  lhs  . grTrf         = GrModule_Mod @baseName @globalL.grTrf @bindL.grTrf @ctagsMp @newEvalTagMp @newAppTagMp
         loc  . newEvalTagMp  = map (newMap @lhs.bind2id) @evalTagMp
              . newAppTagMp   = map (newMap @lhs.bind2id) @applyTagMp
%%]

%%[8.countBindings
ATTR GrAGItf GrModule AllBind [ | | nrOfBinds USE {+} {1}: {Int} ]
SEM GrBindL
  | Nil  lhs  .  nrOfBinds  =  0
%%]

%%[8 hs
newMap mp (k, EvApTagVar nm)  =  let newNm = if applyNm == nm
                                             then applyNr
                                             else if evalNm == nm
                                             then evalNr
                                             else findNewVar mp nm
                                 in (k, EvApTagVar newNm)
newMap mp x                   =  x
%%]

% vim:ts=4:et:ai:
