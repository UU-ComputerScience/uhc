%%[0 hs
{
{-| 
  This module transforms a 'SilModule' to a 'LLVMModule' via an AG
  transformation. TODO more about the transformation later.
-}
}
%%]
%%[(8 codegen grin) hs module {%{EH}Silly.ToLLVM}
%%]
%%[(8 codegen grin) hs import({%{EH}LLVM})
%%]
%%[(8 codegen grin) hs import({%{EH}Silly})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Common})
%%]
%%[(8 codegen grin) hs import({%{EH}Base.Opts})
%%]
%%[(8 codegen grin) hs import({%{EH}ConfigDefines})
%%]
%%[(8 codegen grin) import({Silly/AbsSyn})
%%]
%%[(8 codegen grin) hs import(qualified Data.Map)
%%]
%%[(8 codegen grin) hs import(qualified Data.List)
%%]
%%[(8 codegen grin) hs import(Data.Char)
%%]
%%[(8 codegen grin)
WRAPPER SilModule
%%]

%%[(8 codegen grin)
PRAGMA nocycle
%%]

%%[(8 codegen grin) hs export( silly2llvm )
{-|
  Transform a 'SilModule' to a 'LLVMModule'. In this module, we use cells which
  have the size @sizeof(intptr_t)@, so that we can store both integers and
  pointers in them and cast freely.
-} 
silly2llvm :: EHCOpts -> SilModule -> LLVMModule
silly2llvm opts silmod = 
  let -- LLVMType of integers
      intType    = if sizeofPointer == 8 
                   then i64
                   else i32
      -- LLVMType of pointers to integers.
      ptrType    = pLift intType
      -- Global variables are always pointers to pointers to integers.
      gblType    = pLift ptrType
      t = wrap_SilModule (sem_SilModule silmod)
                         (Inh_SilModule { intType_Inh_SilModule = intType 
                                        , pointerType_Inh_SilModule = ptrType
                                        , globalType_Inh_SilModule = gblType
                                        , gUniq_Inh_SilModule = uidStart
                                        } 
                         )
   in llvmCode_Syn_SilModule t
%%]

%%[(8 codegen grin)
ATTR SilModule
     [ | | llvmCode : {LLVMModule} ]

ATTR Functions
     [ | | llvmCode : {LLVMFunctions} ]

ATTR Function
     [ | | llvmCode : {LLVMFunction} ] 
   
ATTR Statements Statement Alternative
     Values Value Variable
     [ | | llvmCode : {LLVMStatements} ]
  
ATTR Alternatives
     [ | | llvmCode : {[LLVMStatements]} ]  
     
ATTR Values
     [ | | llvmVar : {[LLVMVar]} ]

ATTR Value Variable Constant
     [ | | llvmVar : {LLVMVar} ]   
 
ATTR Alternatives
     [ | | jumpTargets : {[(LLVMVar,LLVMVar)]} ]
     
ATTR Alternative
     [ | | jumpTarget : {(LLVMVar,LLVMVar)} ]  
     
SEM SilModule
  | SilModule   lhs.llvmCode = LLVMModule_LLVMModule @loc.comment
                                                     ( (@loc.globalResStr,@loc.resConst) : @functions.constants ) 
                                                     @loc.globals 
                                                     ( stdlibPrintfFuncDecl : gcInitFuncDecl
                                                     : gcPrintStatsFuncDecl
                                                     : gcMallocFuncDecl @lhs.intType
                                                     : gcMallocUncollectableFuncDecl @lhs.intType
                                                     : primPatternMatchFailureFuncDecl : @functions.externFuncs 
                                                     )
                                                     ( @loc.main : @functions.llvmCode )
                                                     
                loc.comment  = map (\(s,i) -> s ++ "->" ++ show i) @constants  
                loc.(globalResStr,resConst) = 
                                string2LLVMString @lhs.gUniq $
                                  if sizeofPointer == 8
                                  then "%lld\n"
                                  else "%d\n"
                loc.globals  = GlobalVar "RP" (@lhs.globalType) : mkVarList GlobalVar @variables @lhs.globalType                                                                          
                loc.main     = LLVMFunction_Func mainFuncDecl ExternallyVisible
                                 [ LLVMStatement_Call gcInitFuncDecl StdCall []
                                 , LLVMStatement_Assignment (LocalVar "rpArr" @lhs.pointerType)
                                     (mkMalloc NotManaged @lhs.intType (1 + @functions.maxRPIndex))
                                 , LLVMStatement_Store (LocalVar "rpArr" @lhs.pointerType) (GlobalVar "RP" @lhs.globalType)
                                 , LLVMStatement_Call initializeFuncDecl StdCall []
%%[[8
                                 , LLVMStatement_Call fun_mainFuncDecl StdCall []
                                 , LLVMStatement_Assignment (LocalVar "rp.1" @lhs.pointerType)
                                     (LLVMExpression_GetElemPtr (LocalVar "rpArr" @lhs.pointerType) [1] )
                                 , LLVMStatement_Assignment (LocalVar "rp.1.val" @lhs.intType)
                                     (LLVMExpression_Load (LocalVar "rp.1" @lhs.pointerType))
                                , LLVMStatement_Assignment (LocalVar "cast.str.res" (pLift i8))
                                     (LLVMExpression_GetElemPtr @loc.globalResStr [0,0])  
                                 , LLVMStatement_Call stdlibPrintfFuncDecl TailCall
                                     [ LocalVar "cast.str.res" (pLift i8), LocalVar "rp.1.val" @lhs.intType ]
%%][99
                                 , LLVMStatement_Call fun_mainFullProgFuncDecl StdCall []
%%]]                                 
                                 , LLVMStatement_Call gcPrintStatsFuncDecl StdCall []
                                 , LLVMStatement_Return (Constant 0 i32)  
                                 ]                    
                                 
SEM Functions
  | Cons        lhs.llvmCode = @hd.llvmCode : @tl.llvmCode
  | Nil         lhs.llvmCode = []
  
SEM Function
  | Function    lhs.llvmCode = let locals = map (\nm -> LLVMStatement_Assignment (LocalVar (hs2str nm) @lhs.pointerType)
                                                         (LLVMExpression_Alloca @lhs.intType 1) ) @locals
                                in LLVMFunction_Func @loc.fnDecl Internal $ locals ++ @body.llvmCode
 
SEM Statements
  | Cons        lhs.llvmCode = @hd.llvmCode ++ @tl.llvmCode
  | Nil         lhs.llvmCode = []
  
SEM Statement
  -- A Silly assign will translate to a store. We have the following steps
  --   * If the RHS is an expression, assign the RHS to a fresh var
  --   * Do the same for the LHS
  --   * check if the LHS is a pointertype, otherwise cast to pointer
  --   * check if the RHS type fits in the pointertype of the LHS, otherwise
  --     cast the LHS
  --   * Store
  | Assignment  lhs.llvmCode = @source.llvmCode ++ @dest.llvmCode ++ @loc.lhsptrCode ++ @loc.fitsCode ++
                               [LLVMStatement_Store @loc.fitsVar @loc.lhsptrVar] 
 
                loc.(uniqNr1,lhsptrVar,lhsptrCode) =
                               cast2ptr @dest.gUniq @dest.llvmVar @lhs.pointerType
                loc.(uniqNr2,fitsVar,fitsCode) =
                               makeFitting @loc.uniqNr1 @source.llvmVar @loc.lhsptrVar                                         

  | Assignment2 lhs.llvmCode = @source.llvmCode ++ @dest.llvmCode ++ @loc.destptrCode ++ @loc.fits1Code ++
                               [ LLVMStatement_Store @loc.fits1Var @loc.destptrVar ] ++
                               @dest2.llvmCode ++ @loc.dest2ptrCode ++ @loc.fits2Code ++
                               [ LLVMStatement_Store @loc.fits2Var @loc.dest2ptrVar] 
                
                loc.(uniqNr1,destptrVar,destptrCode) =
                               cast2ptr @dest2.gUniq @dest.llvmVar @lhs.pointerType
                loc.(uniqNr2,dest2ptrVar,dest2ptrCode) =
                               cast2ptr @loc.uniqNr1 @dest2.llvmVar @lhs.pointerType                                        
                loc.(uniqNr3,fits1Var,fits1Code) =
                               makeFitting @loc.uniqNr2 @source.llvmVar @loc.destptrVar
                loc.(uniqNr4,fits2Var,fits2Code) =
                               makeFitting @loc.uniqNr3 @source.llvmVar @loc.dest2ptrVar  

  | Call        lhs.llvmCode = let fDecl = Data.Map.findWithDefault 
                                             (error $ "No such function: " ++ hs2str @name)
                                             (hs2str @name) @lhs.fnAvailDecls
                                in @args.llvmCode ++
                                   @loc.castCode ++
                                   [ LLVMStatement_Call fDecl (bool2calltype @tailJumps) @loc.castVars ]
 
                -- Some arguments can be pointers and need to be casted
                -- to inttypes 
                loc.(uniqNr1,castVars,castCode) =  
                               foldr (\x xs -> let (nr,val,stmt) = cast2int (getUID xs) x @lhs.intType
                                                in ( nr, val : getVars xs, stmt ++ (getCode xs) ) ) 
                                     (@args.gUniq,[],[]) @args.llvmVar

                loc.(uniqNr2,fresh) = newFresh @loc.uniqNr1 (pLift i8)
               
  | Comment     lhs.llvmCode = [LLVMStatement_Comment @comment]

  | IfThenElse  lhs.llvmCode = @condition.llvmCode ++
                               [ LLVMStatement_BranchIf @condition.llvmVar @loc.thenLabel @loc.elseLabel
                               , LLVMStatement_Label @loc.thenLabel ] ++                               
                               @thenpart.llvmCode ++
                               [ LLVMStatement_Branch @loc.resumeLabel
                               , LLVMStatement_Label @loc.elseLabel ] ++
                               @elsepart.llvmCode ++
                               [ LLVMStatement_Branch @loc.resumeLabel
                               , LLVMStatement_Label @loc.resumeLabel]                        
                                                                    
                loc.(uniqNr1, thenLabel) =
                               newFresh @condition.gUniq Label
                loc.(uniqNr2, elseLabel) =
                               newFresh @thenpart.gUniq Label
                loc.(uniqNr3, resumeLabel) =
                               newFresh @elsepart.gUniq Label              

  | Switch      lhs.llvmCode = @scrutinee.llvmCode ++
                               [ LLVMStatement_Switch @scrutinee.llvmVar @loc.defaultLabel @body.jumpTargets ] ++ 
                               @loc.altLLVMStatements ++ @loc.defaultBody ++ 
                               [ LLVMStatement_Branch @loc.resumeLabel] ++
                               [ LLVMStatement_Label  @loc.resumeLabel ]
                    
                loc.altLLVMStatements = concatMap ( ++ [LLVMStatement_Branch @loc.resumeLabel] ) @body.llvmCode  
                
                loc.(uniqNr1, defaultLabel, defaultBody) =
                               defaultCase @body.gUniq   
                loc.(uniqNr2, resumeLabel) =
                               newFresh @loc.uniqNr1 Label

  | Label       lhs.llvmCode = error $ "Generated label instructions not"
                                     ++ " allowed in LLVM. Is -g set to 0?"
  
  | Return      lhs.llvmCode = [LLVMStatement_Return $ LocalVar (error "ReturnNoVar") Void ]  
                                    
  | * - Assignment Assignment2 Call Comment Jump Label Return Switch IfThenElse
                lhs.llvmCode = error "Unimplemented Statement"

SEM Alternatives
  | Cons        lhs.llvmCode    = @hd.llvmCode : @tl.llvmCode
                lhs.jumpTargets = @hd.jumpTarget : @tl.jumpTargets              
  | Nil         lhs.llvmCode    = []
                lhs.jumpTargets = []
                
SEM Alternative
  | Alternative lhs.llvmCode = LLVMStatement_Label @loc.label : @body.llvmCode
                lhs.jumpTarget = (@when.llvmVar, @loc.label)
                                        
                (loc.uniqNr1, loc.label) = 
                               newFresh @lhs.gUniq Label

SEM Values
  | Cons        lhs.llvmVar  = @hd.llvmVar : @tl.llvmVar
                lhs.llvmCode = @hd.llvmCode ++ @tl.llvmCode
  | Nil         lhs.llvmVar  = [] 
                lhs.llvmCode = []       
       
SEM Value
  {-|
    Assign a Malloc to a fresh variable
  -}
  | Alloc       lhs.llvmVar  = @loc.llvmVar
                lhs.llvmCode = @loc.llvmCode
                loc.(gUniq,llvmVar,llvmCode) =
                               assign2var @lhs.gUniq (mkMalloc @gcManaged @lhs.intType @size, @lhs.pointerType)

  {-|
    For a call we need to do the following steps:
      * Cast the parameter values to integers
      * Assign the result of the call to a fresh variable
  -}                             
  | Call        lhs.llvmVar  = @loc.llvmVar
                lhs.llvmCode = @args.llvmCode ++ @loc.castCode ++ @loc.llvmCode
 
                loc.fnDecl  = LLVMFunctionDecl_LLVMFunctionDecl @name @lhs.intType FixedArgs @loc.formalParams
                
                -- Some arguments can be pointers and need to be casted
                -- to inttypes 
                loc.(uniqNr1,castVars,castCode) =  
                               foldr (\x xs -> let (nr,val,stmt) = cast2int (getUID xs) x @lhs.intType
                                                in (nr, val : getVars xs, stmt ++ (getCode xs)) ) 
                                     (@args.gUniq,[],[]) @args.llvmVar 

                -- Assign the call expression to a fresh variable
                --                     
                loc.(uniqNr2,llvmVar,llvmCode) =
                               assign2var @loc.uniqNr1 (LLVMExpression_Call @loc.fnDecl StdCall @loc.castVars, @lhs.intType)
                                                   
                -- We generate the formal parameters by generating new names
                -- for the actual ones
                loc.(uniqNr3,formalParams) =  
                               foldr (\x xs -> let (nr,fresh) = newFresh (fst xs) (getType x)
                                                in (nr, fresh : (snd xs)) ) 
                                     (@loc.uniqNr2,[]) @loc.castVars                                

  {-|
    A Con just wraps a constant. No actions needed.
  -}
  | Con         lhs.llvmVar  = @con.llvmVar
                lhs.llvmCode = []
  
  {-|
    The llvmVar inherited from the @var child needs to be loaded to an integer value
  -}                                                                               
  | Var         lhs.llvmVar  = @loc.llvmVar
                lhs.llvmCode = @var.llvmCode ++ @loc.llvmCode                
                
                loc.(uniqNr1,llvmVar,llvmCode) =                
                               if getType @var.llvmVar /= @lhs.intType
                               then load @var.gUniq @var.llvmVar
                               else (@var.gUniq,@var.llvmVar,[])                              

  {-|
    Compare a value to a constant. The value is cast to an integer
  -}
  | CompareGT   lhs.llvmVar  = @loc.cmpRes
                lhs.llvmCode = @val.llvmCode ++ @loc.lhsToIntCode ++ @loc.cmpCode
                
                loc.(uniqNr1, lhsIntVar, lhsToIntCode) =
                              cast2int @val.gUniq @val.llvmVar @lhs.intType
                loc.(uniqNr2, cmpRes, cmpCode) =
                              assign2var @loc.uniqNr1 ( LLVMExpression_Compare CMPSGT @loc.lhsIntVar @con.llvmVar, i1)
                                                            
  | Offset      lhs.llvmVar  = @loc.offsetVar
                lhs.llvmCode = @var.llvmCode ++ @loc.loadCode ++
                               @loc.castCode ++ @loc.offsetCode

                loc.(uniqNr1,loadVar,loadCode) =
                              load @lhs.gUniq @var.llvmVar
                loc.(uniqNr2,castVar,castCode) =
                              cast2ptr @loc.uniqNr1 @loc.loadVar @lhs.pointerType
                loc.(uniqNr3,offsetVar,offsetCode) =
                              assign2var @loc.uniqNr2 ( LLVMExpression_GetElemPtr @loc.castVar [@off], getType @loc.castVar )

  | * - Alloc Call Con Var CompareGT Offset
                lhs.llvmVar  = error $ "No Label or Cast Value expected"
                lhs.llvmCode = error $ "No Label or Cast Value expected"       
 
SEM Variable
  | Global      lhs.llvmVar  = GlobalVar (hs2str @name) @lhs.globalType
                lhs.llvmCode = []
                
  | Local       lhs.llvmVar  = LocalVar (hs2str @name) @lhs.pointerType                                        
                lhs.llvmCode = []               
  
  | Param       lhs.llvmVar  = LocalVar (hs2str @name) @lhs.intType                                       
                lhs.llvmCode = []                                                    
                                               
  | RP          lhs.llvmVar  = GlobalVar "RP" @lhs.globalType 
                lhs.llvmCode = []
                
  | Subs        lhs.llvmVar  = @loc.offsetVar
                lhs.llvmCode = @array.llvmCode ++ @loc.loadCode ++ @loc.ptrCode ++ @loc.offsetCode 
                
                -- Tricky: The variable could be a global indirection or a indirection
                -- resulting from an alloca. If that is the case, then we need to
                -- resolve this redirection by loading.
                loc.(uniqNr1,loadVar,loadCode) =
                               if isGlobal @array.llvmVar || @array.isLocal
                               then load @array.gUniq @array.llvmVar
                               else (@array.gUniq, @array.llvmVar, []) 
                loc.(uniqNr2,ptrVar,ptrCode) =
                               cast2ptr @loc.uniqNr1 @loc.loadVar @lhs.pointerType  
                loc.(uniqNr3,offsetVar,offsetCode) =
                               assign2var @loc.uniqNr2 (LLVMExpression_GetElemPtr @loc.ptrVar [@index], getType @loc.ptrVar)
 
   | * - Global Local Param RP Subs
                lhs.llvmVar  = error "Variable contains an impossible construct"
                lhs.llvmCode = error "Variable contains an impossible construct"                                                                                                           
                
SEM Constant
  | LiteralInt  lhs.llvmVar  = Constant @value @lhs.intType
  | LiteralStr  lhs.llvmVar  = @loc.globStrVar
  | Alias       lhs.llvmVar  = let value = Data.Map.findWithDefault
                                             (error "Alias not in constantmap")
                                             @name @lhs.constantMap 
                                in Constant value @lhs.intType                                                                 
%%]

%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- Thread a UID through the program in a way that the numbering follow
-- the flow of the code.
--------------------------------------------------------------------------------
ATTR AllNT     [ | gUniq: UID | ]      
 
SEM SilModule
  -- The first UID is used by the string constant for the integer result
  -- (variant 8).
  | SilModule   functions.gUniq = uidNext @lhs.gUniq 

SEM Statement
  -- Set the order source -> dest -> local explicit, because this order is
  -- different from the data type definition.
  | Assignment  source.gUniq = @lhs.gUniq
                dest  .gUniq = @source.gUniq
                lhs   .gUniq = @loc.uniqNr2

  -- Set the order source -> dest -> dest2 explicit, because it is differs
  -- from the data type definition.
  | Assignment2 source.gUniq = @lhs.gUniq
                dest  .gUniq = @source.gUniq
                dest2 .gUniq = @dest.gUniq
                lhs   .gUniq = @loc.uniqNr4

  -- The passing down to the args is performed by the copy rules.
  | Call        lhs .gUniq   = @loc.uniqNr2

  -- Although the order condition -> thenpart -> elsepart is equal to the order
  -- set by the datatype, we have to intersperse the code with labels.
  | IfThenElse  condition.gUniq = @lhs.gUniq
                thenpart .gUniq = @loc.uniqNr1
                elsepart .gUniq = @loc.uniqNr2
                lhs      .gUniq = @loc.uniqNr3
                       
  -- The passing from scrutinee to the body is handled by the data type order.
  | Switch      lhs.      gUniq = @loc.uniqNr2

SEM Alternative
  -- The order is local (for the label) -> body
  | Alternative body.gUniq   = @loc.uniqNr1

SEM Value
  -- Passing to args via copy rule
  | Call        lhs .gUniq   = @loc.uniqNr3
  -- Passing to var via copy rule                         
  | Var         lhs.gUniq    = @loc.uniqNr1
  -- Passing to val via copy rule.
  | CompareGT   lhs.gUniq    = @loc.uniqNr2
  | Offset      lhs.gUniq    = @loc.uniqNr3
              
SEM Variable
  -- Passing to array via copy rule
  | Subs        lhs  .gUniq  = @loc.uniqNr3

                 
%%]

%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- Passing up the signatures of the functions declared and the functions 
-- defined in this module. If we have the set of these functions, we can 
-- query them for Calls and we can warn if undeclared/undefined functions are
-- called
--------------------------------------------------------------------------------
ATTR Functions Function
     Statements Statement
     Alternatives Alternative
     Values Value
     Variable
     [ fnAvailDecls : {Data.Map.Map String LLVMFunctionDecl} | | ]

ATTR Functions
     [ | | fnDecls : {[(String,LLVMFunctionDecl)]} ]

ATTR Function
     [ | | fnDecl : {(String,LLVMFunctionDecl)} ]

SEM SilModule
  | SilModule   functions.fnAvailDecls
                           = Data.Map.fromList @functions.fnDecls

SEM Functions
  | Cons        lhs.fnDecls
                           = @hd.fnDecl : @tl.fnDecls
  | Nil         lhs.fnDecls
                           = []

SEM Function
  | Function    lhs.fnDecl = (hs2str @name, @loc.fnDecl)
                loc.fnDecl : {LLVMFunctionDecl}
                loc.fnDecl = let prms = mkVarList LocalVar @parameters 
                                                           @lhs.intType
                              in LLVMFunctionDecl_LLVMFunctionDecl (hs2str @name) Void FixedArgs prms
%%]
  
%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- Passing up the string constants used in functions 
--------------------------------------------------------------------------------
ATTR Functions Function
     Statements Statement
     Alternatives Alternative
     Values Value
     Variable
     Constant
     [ | | constants USE {++} {[]}: {[(LLVMVar,LLVMVar)]} ]

SEM Constant
  | LiteralStr  lhs.constants = [ ( @loc.globStrVar , @loc.strConst) ]
                loc.(globStrVar,strConst) =
                                string2LLVMString @lhs.gUniq @value
  | * - LiteralStr
                lhs.constants = [ ]
%%]

%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- Passing down platform depended types.
--------------------------------------------------------------------------------

ATTR AllNT
     [ intType, pointerType, globalType : {LLVMType} | | ]
%%]

%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- We pass down a map, containing the alias name and the 
-- corresponding Int value of constructor tags
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variable
     Constant
     [ constantMap : {Data.Map.Map String Int} | | ]

SEM SilModule
  | SilModule   functions.constantMap = Data.Map.fromList @constants
%%]

%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- TODO: Bubble up if a variable is a Local variable. This is needed, because
-- those are implemented with an address on the stack.
--------------------------------------------------------------------------------
ATTR Variable
     [ | | isLocal : {Bool} ]
                          
SEM Variable
  | Local       lhs.isLocal  = True
  | * - Local
                lhs.isLocal  = False                           
%%]

%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- Pass the max size of the closure that is stored in RP up
-- so that we can initialize it at the start up.
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variable
     [ | | maxRPIndex USE {`max`} {0}: {Int} ]

SEM Variable
  | Subs        lhs.maxRPIndex =
                             if @array.isRP then @index else 0  

ATTR Variable
     [ | | isRP : {Bool} ]
                          
SEM Variable
  | RP          lhs.isRP   = True
  | * - RP
                lhs.isRP   = False                           
%%]

%%[(8 codegen grin)
--------------------------------------------------------------------------------
-- Pass function declarations that are defined extern
--------------------------------------------------------------------------------
ATTR Functions Function 
     Statements Statement
     Alternatives Alternative
     Values Value
     Variable
     [ | | externFuncs USE {++} {[]}: {[LLVMFunctionDecl]} ]
                       
SEM Value
  | Call        lhs.externFuncs = [@loc.fnDecl]                  
%%]

%%[(8 codegen grin)
{
-------------------------------------------------------------------------------
-- Functions for extraction of values from the (UID,[LLVMVar],LLVMStatements) 
-- tuples as used in 'LLVMExpression_Call' and 'LLVMStatement_Call' argument 
-- preparation.
-------------------------------------------------------------------------------
{-|
Return the 'UID' element from the tuple. 
-}
getUID :: (UID,[LLVMVar],LLVMStatements) -> UID
getUID (x,_,_) = x

{-|
Return the ['LLVMVar'] element from the tuple. 
-}
getVars :: (UID,[LLVMVar],LLVMStatements) -> [LLVMVar]
getVars (_,x,_) = x

{-|
Return the 'LLVMStatements' element from the tuple. 
-}
getCode :: (UID,[LLVMVar],LLVMStatements) -> LLVMStatements
getCode (_,_,x) = x
}
%%]

%%[(8 codegen grin)
{
-------------------------------------------------------------------------------
-- Some 'LLVMLLVMFunctionDecl_LLVMFunctionDecltionDecl's for usage in calls and forward declarations.
-------------------------------------------------------------------------------
{-|
Function declaration for the entry point of the binary.
-}
mainFuncDecl :: LLVMFunctionDecl
mainFuncDecl =
  LLVMFunctionDecl_LLVMFunctionDecl "main" i32 FixedArgs []

{-|
Function declaration for the Silly generated initialize function.
-}
initializeFuncDecl :: LLVMFunctionDecl
initializeFuncDecl =
  LLVMFunctionDecl_LLVMFunctionDecl "initialize" Void FixedArgs []

{-|
Function declaration for the GRIN generated fun_main function.
-}
fun_mainFuncDecl :: LLVMFunctionDecl
fun_mainFuncDecl =
  LLVMFunctionDecl_LLVMFunctionDecl "fun_fun0tildemain" Void FixedArgs []
  
fun_mainFullProgFuncDecl =  
  LLVMFunctionDecl_LLVMFunctionDecl "fun_mainFullProg" Void FixedArgs []

{-|
Function declaration of printf from the standard C library.
-}
stdlibPrintfFuncDecl :: LLVMFunctionDecl
stdlibPrintfFuncDecl = 
  LLVMFunctionDecl_LLVMFunctionDecl "printf" i32 VarArgs [(LocalVar "str" (pLift i8))]

{-|
Function declaration for a run-time function that reports an pattern match
failure and terminates the program.
-}
primPatternMatchFailureFuncDecl :: LLVMFunctionDecl
primPatternMatchFailureFuncDecl =
  LLVMFunctionDecl_LLVMFunctionDecl "primPatternMatchFailure" Void FixedArgs [] 

{-|
Function declaration for a run-time function that initializes the garbage
collector.
-}
gcInitFuncDecl :: LLVMFunctionDecl
gcInitFuncDecl =
  LLVMFunctionDecl_LLVMFunctionDecl "llvmgc_init" Void FixedArgs []
  
{-|
Function declaration for a run-time malloc function that is managed by the
garbage collector. The 'LLVMType' is used as argument type and for the
return type, supporting both 32 and 64 bit memory allocation.
-}  
gcMallocFuncDecl :: LLVMType -> LLVMFunctionDecl
gcMallocFuncDecl intType =
  LLVMFunctionDecl_LLVMFunctionDecl "llvmgc_malloc" (pLift intType) FixedArgs [(LocalVar "x" intType)] 

{-|
Function declaration for a run-time function that mallocs a piece of memory that
is added as root for garbage collection (in addition to the stack). The 'LLVMType' is used as 
argument type and for the return type, supporting both 32 and 64 bit memory allocation.
-}
gcMallocUncollectableFuncDecl :: LLVMType -> LLVMFunctionDecl
gcMallocUncollectableFuncDecl intType =
  LLVMFunctionDecl_LLVMFunctionDecl "llvmgc_malloc_uncollectable" (pLift intType) FixedArgs [(LocalVar "x" intType)] 

gcPrintStatsFuncDecl :: LLVMFunctionDecl
gcPrintStatsFuncDecl =
  LLVMFunctionDecl_LLVMFunctionDecl "llvmc_print_statistics" Void FixedArgs []
}
%%]

%%[(8 codegen grin)
{
-------------------------------------------------------------------------------
-- Cast functions
-------------------------------------------------------------------------------
{-|
Cast a 'LLVMVar' to the given 'LLVMType' 'LLVMInt' type. Note: There is no check
on the 'LLVMType' if it is an integer type. If you pass an non integer type,
then the result of the cast is undefined.
-}
cast2int :: UID -> LLVMVar -> LLVMType -> (UID,LLVMVar,LLVMStatements)   
cast2int nr var intType =
  if isInt (getType var)
  then (nr,var,[])
  else let (nr', fresh) = newFresh nr intType
        in (nr', fresh, [LLVMStatement_Assignment fresh $ LLVMExpression_Cast var intType])
 
{-|
Cast a 'LLVMVar' to the given 'LLVMType' 'Pointer' type. Note: There is no check
on the 'LLVMType' if it is a pointer type. If you pass an non pointer type,
then the result of the cast is undefined.
-}       
cast2ptr :: UID -> LLVMVar -> LLVMType -> (UID,LLVMVar,LLVMStatements)
cast2ptr nr var ptrType
  | isPointer (getType var) =
    (nr,var,[])
  | otherwise =
    let (nr', fresh) = newFresh nr ptrType
     in (nr', fresh, [LLVMStatement_Assignment fresh $ LLVMExpression_Cast var ptrType])         

{-|
Cast a 'LLVMVar' in such a way that is fits in the location as defined by the second
'LLVMVar'. For example, the first var is an i32 and the second var is an i32**. Then
a cast will be generated to transform the first var to an i32*.
-}   
makeFitting :: UID -> LLVMVar -> LLVMVar -> (UID,LLVMVar,LLVMStatements)
makeFitting nr what hole 
  -- Case 1 it already fits, no casting needed
  | getType what == pLower (getType hole) =
    (nr,what,[])
  -- Cast 'what' to the lowered type of 'hole'.
  | otherwise = 
    let targetType   = pLower $ getType hole 
        (nr', fresh) = newFresh nr targetType
     in (nr', fresh, [LLVMStatement_Assignment fresh $ LLVMExpression_Cast what targetType])
}
%%]

%%[(8 codegen grin)
{
-------------------------------------------------------------------------------
-- Variable loading functions.
-------------------------------------------------------------------------------
{-|
Load a 'LLVMVar'.
-}
load :: UID -> LLVMVar -> (UID,LLVMVar,LLVMStatements)
load nr var =
  let loadType     = pLower (getType var)
      (nr', fresh) = newFresh nr loadType
   in (nr', fresh, [LLVMStatement_Assignment fresh (LLVMExpression_Load var)])
   
{-|
Load a 'LLVMVar' to an integer.
-}   
load2value :: UID -> LLVMVar -> (UID,LLVMVar,LLVMStatements)
load2value nr var 
  | isInt (getType var) = (nr,var,[])
  | otherwise           =
    let (nr1,var1,stmts1) = load nr var
        (nr2,var2,stmts2) = load2value nr1 var1
     in (nr2,var2, stmts1 ++ stmts2)       
}
%%]

%%[(8 codegen grin)
{
-------------------------------------------------------------------------------
-- Assign an 'LLVMExpression' to a 'LLVMVar'.
-------------------------------------------------------------------------------
{-|
Return a fresh local variable of the requested 'LLVMType'
-}
newFresh :: UID -> LLVMType -> (UID,LLVMVar)
newFresh nr tp = 
  (uidNext nr, LocalVar ("fresh" ++ show nr) tp)

{-|
Assign the given 'LLVMExpression' with the given 'LLVMType' to 
a fresh local 'LLVMVar'.
-}
assign2var :: UID -> (LLVMExpression,LLVMType) -> (UID,LLVMVar,LLVMStatements)
assign2var nr (expr,tp) =
  let (nr', fresh) = newFresh nr tp
   in (nr', fresh, [LLVMStatement_Assignment fresh expr])
}
%%]

%%[(8 codegen grin)
{
-------------------------------------------------------------------------------
-- Often used constants.
-------------------------------------------------------------------------------
{-|
The default arm for a 'LLVMStatement_Switch'.
-}
defaultCase :: UID -> (UID,LLVMVar,LLVMStatements)
defaultCase nr =
  let (nr1, fresh1) = newFresh nr Label
   in (nr1, fresh1, [ LLVMStatement_Label fresh1, LLVMStatement_Call primPatternMatchFailureFuncDecl StdCall [] 
                    , LLVMStatement_Unreachable ])
}
%%]

%%[(8 codegen grin)
{
-------------------------------------------------------------------------------
-- Construct LLVM Data
-------------------------------------------------------------------------------
{-|
Create a 'LLVMExpression' that allocates @nr * sizeof( LLVMType )@ bytes.
-}
mkMalloc :: SillyAllocManageType -> LLVMType -> Int -> LLVMExpression
mkMalloc manageType intType nr =
  if rtsUseGC
  then let size = nr * sizeofPointer
        in case manageType of
           NotManaged -> LLVMExpression_Call (gcMallocUncollectableFuncDecl intType) StdCall [Constant size intType]
           GCManaged  -> LLVMExpression_Call (gcMallocFuncDecl intType) StdCall [Constant size intType]
  else LLVMExpression_Malloc intType nr
}
%%]

%%[(8 codegen grin)
{
-------------------------------------------------------------------------------
-- Auxiliary functions
-------------------------------------------------------------------------------
{-|
Fetch the string representation of a 'HsName'
-}
hs2str :: HsName -> String
hs2str = hsnShowAlphanumeric

{-|
Return a list of variables with a given constructor, a list of HsNames and
one type. used primary for parameter lists
-}
mkVarList :: (String -> LLVMType -> LLVMVar) -> [HsName] -> LLVMType -> [LLVMVar]
mkVarList constr names tp =
  zipWith (\x y -> constr (hs2str x) y) names (repeat tp)

{-|
Generate a valid global variable which contains a LLVM representation of a Haskell String. 
-}
string2LLVMString :: UID -> String -> (LLVMVar,LLVMVar)
string2LLVMString uid hsStr =
  let hsStr'       = concatMap escapeHex hsStr
      llvmType     = Array (length hsStr + 1) i8
      llvmStr      = "c\"" ++ hsStr' ++ "\\00\""
      (uid',fresh) = newFresh uid llvmType
   in (GlobalVar (getPlainName fresh) (pLift $ llvmType), StrConstant llvmStr llvmType)
  where escapeHex c | isAlphaNum c  = [c]
                    | otherwise     = "\\" ++ strHex 2 (ord c)
{-|
Convert a Bool to a 'LLVMCallType', True indicating a 'TailCall' while any other
value indicates 'StdCall'
-} 
bool2calltype :: Bool -> LLVMCallType
bool2calltype (True)  = TailCall
bool2calltype (False) = StdCall 
}
%%]

