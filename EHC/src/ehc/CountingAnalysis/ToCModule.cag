%%[(8 counting) hs module {%{EH}CountingAnalysis.ToCModule} import(Data.Maybe,Data.Set (Set),qualified Data.Set as S,Data.Map (Map),qualified Data.Map as M, qualified Data.Map as Data.Map)
%%]

%%[(8 counting) hs import({%{EH}LamInfo},{%{EH}Base.Common},{%{EH}Base.HsName.Builtin},{%{EH}Gam.DataGam},{%{EH}Core},{%{EH}Ty})
%%]

%%[(8 counting) hs import({%{EH}CountingAnalysis})
%%]

%%[(8 counting) hs import(UHC.Util.Utils)
%%]

%%[(8 counting) hs import(Data.List(foldl'))
%%]

%%[(8 counting) hs import({%{EH}Base.Target (FFIWay)}, {%{EH}Foreign (ForeignEnt)}, {%{EH}Ty (Ty)})
%%]

Debugging
%%[(8 counting) hs import(Debug.Trace)
%%]

%%[(8 counting).WRAPPER ag import({CountingAnalysis/AbsSynExpr})
WRAPPER Module
%%]


%%[(99 counting)
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) hs export(toCModule)
toCModule :: Module -> CModule
toCModule cmod
  =  let t = wrap_Module (sem_Module cmod) Inh_Module
     in trf_Syn_Module t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag

ATTR Module [ | | trf: {CModule} ]
ATTR Expr [ | | trf: {CExpr} ]
ATTR Const [ | | trf: {CExpr} ]
ATTR AltCons AltConsts [ | | trf : {CAltL}]
ATTR AltCon AltConst [ | | trf : {CAlt}]
ATTR Bindings [ | | trf : {CBindL}]
ATTR Binding [ | | trf : {CBind}]

SEM Module
  | Module
    lhs.trf = CModule_Mod @loc.moduleNm @loc.exports @loc.imports @loc.declMetas @e.trf
    loc.(moduleNm, exports, imports, declMetas) = @extra

SEM Expr
  | VarLocal
    lhs.trf = CExpr_Var @extra
  | VarImport
    lhs.trf = CExpr_Var @extra
  | Const
    -- copy rule
  | Abs
    lhs.trf = CExpr_Lam @extra @body.trf
  | AppLocal
    lhs.trf = CExpr_App @func.trf @extra
  | AppImport
    lhs.trf = CExpr_App @func.trf @extra
  | AppConst
    lhs.trf = CExpr_App @func.trf @extra
  | Let
    lhs.trf = CExpr_Let @extra @binds.trf @e.trf
  | LetBang
    lhs.trf = CExpr_Let CBindCateg_Strict [CBind_Bind @x [@loc.bound]] @e2.trf
    loc.bound = case @extra of
                  Nothing -> CBound_Bind @e1.trf
                  Just (aks,mlev,lbl) -> CBound_Val aks mlev lbl @e1.trf
  | Con Tup
    lhs.trf = foldl' CExpr_App @loc.base @loc.bounds
    loc.base = CExpr_Tup @loc.tag
    loc.(tag,bounds) = @extra
  | CaseCon CaseConst
    lhs.trf = CExpr_Case @e.trf @alts.trf @extra
  | CaseTup
    lhs.trf = CExpr_Case @e.trf [CAlt_Alt @loc.pat @e1.trf] @loc.dflt
    loc.(pat, dflt) = @extra
  | FFI
    lhs.trf = CExpr_FFI @loc.callConv @loc.safety @loc.empEnt @ty
    loc.(callConv, safety, empEnt) = @extra
  | Ann
    lhs.trf = CExpr_Ann (CExprAnn_CAType @ann) @e.trf
  | AnnCore
    lhs.trf = CExpr_Ann @ann @e.trf
  | Error
    lhs.trf = panic $ "Translating error expression: " ++ @e

SEM Const
  | Int
    lhs.trf = CExpr_Int @c
  | Char
    lhs.trf = CExpr_Char @c
  | String
    lhs.trf = CExpr_String @c
%%[[(97 core)
  | Integer
    lhs.trf = CExpr_Integer @c
%%]]

SEM AltCons AltConsts Bindings
  | Cons
    lhs.trf = @hd.trf : @tl.trf
  | Nil
    lhs.trf = []

SEM AltCon AltConst
  | *
    lhs.trf = CAlt_Alt @extra @e.trf

SEM Binding
  | Bind
    lhs.trf = CBind_Bind @n [@loc.bound]
    loc.bound = case @extra of
                  Nothing -> CBound_Bind @e.trf
                  Just (aks,mlev,lbl) -> CBound_Val aks mlev lbl @e.trf

%%]