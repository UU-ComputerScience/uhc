%%[(8 counting) hs module {%{EH}CountingAnalysis.AnnotateType} import(Data.Maybe,Data.Set (Set),qualified Data.Set as Set,Data.Map hiding (foldr),qualified Data.Map as Map)
%%]

%%[(8 counting) hs import({%{EH}Base.HsName},{%{EH}Base.Common})
%%]

%%[(8 counting) hs import(qualified {%{EH}CountingAnalysis} as CA)
%%]

%%[(8 counting) hs import({%{EH}Base.Target (FFIWay)}, {%{EH}Foreign (ForeignEnt)}, {%{EH}Ty}, {%{EH}Gam.DataGam})
%%]

%%[(8 counting) hs import(UHC.Util.Utils)
%%]

%%[(8 counting) hs import(Debug.Trace)
%%]

%%[(8 counting) hs import(UHC.Util.Pretty)
%%]

%%[(8 counting) ag import({Ty/AbsSyn})
WRAPPER Ty
%%]

%%[(99 counting)
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% access functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) hs export (annotate)
annotate :: DataGam -> Ty -> CA.Scheme
annotate d a = CA.Scheme_Forall Set.empty (tyVars_Syn_Ty syn) mempty (annTy_Syn_Ty syn)  
  where syn = wrap_Ty (sem_Ty a) (Inh_Ty d) 
  -- where syn = traceShow ("annotate", a, pp a) $ wrap_Ty (sem_Ty a) (Inh_Ty d) 

numAnns :: HsName -> DataGam -> Int
numAnns nm d 
  | show nm == "Char" = 0
  | show nm == "Int" = 0 
  | show nm == "Integer" = 0 
  | otherwise = length $ dgiAnnVars $ fromMaybe (error $ "annCon: " ++ show nm) $ nm `dataGamLookup` d
%%]


%%[(8 counting) ag

ATTR Ty [ dataEnv: {DataGam} | | annTy: {CA.Type} tyVars: {Set HsName} caIsFunc: {Maybe Bool} isRec: {Bool}]

SEM Ty
  | *
    loc.caIsFunc = Nothing
    loc.isRec = False
  | Con
    lhs.caIsFunc = @loc.ismFunc
    loc.ismFunc = case show @nm of
                    "->" -> Just True
                    _ -> Nothing
    loc.isFunc = fromMaybe False @loc.ismFunc
    loc.annTops = replicate (numAnns @nm @lhs.dataEnv) CA.annTop
    loc.dataTy = CA.Type_Data @nm @loc.annTops []
    lhs.annTy = if @loc.isFunc then panic "Function Constructor" else if @loc.isRec then panic (show ("Record type", @nm)) else @loc.dataTy
    lhs.tyVars = Set.empty
    loc.isRec := case hsnBaseUnpack @nm of
                    Just ("_Rec", _) -> True
                    Just ("{||}", _) -> True
                    _ -> False
  | App
    lhs.caIsFunc = case @func.caIsFunc of
                    Just True -> Just False
                    _ -> Nothing
    lhs.annTy = if @func.isRec && @arg.isRec then traceShow "doubleRec" $ CA.Type_Data (mkHNm "()") [] []
                else if @func.isRec then @arg.annTy else
                  case @func.caIsFunc of
                    Just True -> @arg.annTy
                    Just False -> CA.Type_Func (CA.RhoType_Rho (CA.EtaType_Eta @func.annTy CA.annTop) CA.annTop) $ CA.EtaType_Eta @arg.annTy CA.annTop
                    -- Assume type constructor application
                    _ -> case @func.annTy of 
                          CA.Type_Data n ann ty -> CA.Type_Data n ann (ty ++ [@arg.annTy])
                          _ -> panic "Unknown type in App" 
    lhs.tyVars = Set.empty
  | Ann
    -- copy rules
  | TBind Lam
    lhs.annTy =  @ty.annTy 
    lhs.tyVars = Set.insert (uidHNm @tv) @ty.tyVars
  | Var
    lhs.annTy = CA.Type_Var $ uidHNm @tv
    lhs.tyVars = Set.empty
  | Ext
    lhs.annTy = if @ty.isRec then @extTy.annTy else case @extTy.annTy of 
                  CA.Type_Tup xs -> CA.Type_Tup $ @loc.toRhoTy @ty.annTy : xs
                  _ -> CA.Type_Tup [@loc.toRhoTy @ty.annTy, @loc.toRhoTy @extTy.annTy]
    lhs.tyVars = Set.empty
    loc.toRhoTy = \x -> CA.RhoType_Rho (CA.EtaType_Eta x CA.annTop) CA.annTop
  | Any
    lhs.annTy = panic "Annotate: unsupported Ty Any"
    lhs.tyVars = Set.empty   
  | Dbg
    lhs.annTy = panic "Annotate: unsupported Ty Dbg"
    lhs.tyVars = Set.empty 
  | Pred
    lhs.annTy = panic "Annotate: unsupported Ty Pred"
    lhs.tyVars = Set.empty   
  | Impls
    lhs.annTy = panic "Annotate: unsupported Ty Impls"
    lhs.tyVars = Set.empty
    
SEM Pred TyAGItf
  | *
    loc.dataEnv = panic "dataEnv pred"
    
%%]