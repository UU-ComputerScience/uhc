%%[(8 counting) hs module {%{EH}CountingAnalysis.Substitution} import(Data.Maybe,Data.Set (Set),qualified Data.Set as Set,Data.Map.Strict (Map),qualified Data.Map.Strict as Map, qualified Data.Map.Strict as Data.Map)
%%]

%%[(8 counting) hs import({%{EH}Base.HsName (HsName)}, {%{EH}Gam.DataGam}, {%{EH}Core}, {%{EH}CodeGen.Tag (CTag)})
%%]

%%[(8 counting) hs import({%{EH}CountingAnalysis})
%%]

%%[(8 counting) hs import({%{EH}CountingAnalysis.Pretty}, UHC.Util.Pretty)
%%]

%%[(8 counting) hs import({%{EH}Base.Target (FFIWay)}, {%{EH}Foreign (ForeignEnt)}, {%{EH}Ty (Ty)})
%%]

%%[(8 counting) hs import({%{EH}Base.Common(CLbl)})
%%]

%%[(8 counting) hs import(UHC.Util.VarLookup(MetaLev))]
%%]

Debugging
%%[(8 counting) hs import(Debug.Trace)
%%]

%%[(8 counting) ag import({CountingAnalysis/AbsSyn}, {CountingAnalysis/AbsSynExpr})
WRAPPER *
%%]

%%[(99 counting)
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% access functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) hs export (Subst(..))
class Subst a where
  substAnn :: a -> AnnSol -> a
  substAnn a m = subst a m Map.empty Map.empty
  substTy :: a -> TySol -> a
  substTy a m =  subst a Map.empty m Map.empty
  substScheme :: a -> SchemeSol -> a
  substScheme a m = subst a Map.empty Map.empty m
  substSolution :: a -> Solution -> a
  substSolution a (Solution as ts ss) = subst a as ts ss

  subst :: a -> AnnSol -> TySol -> SchemeSol -> a
  subst = substM Set.empty

  substM :: Set HsName -> a -> AnnSol -> TySol -> SchemeSol -> a

instance Subst Expr where
  substM m a am tm sm = subst_Syn_Expr $ wrap_Expr (sem_Expr a) 
    (Inh_Expr am sm tm m)

instance Subst Annotation where
  substM m a am tm sm = subst_Syn_Annotation $ wrap_Annotation (sem_Annotation a) 
    (Inh_Annotation am sm tm m)

instance Subst Type where
  substM m a am tm sm = subst_Syn_Type $ wrap_Type (sem_Type a) 
    (Inh_Type am sm tm m)

instance Subst Constraint where
  substM m a am tm sm = subst_Syn_Constraint $ wrap_Constraint (sem_Constraint a) 
    (Inh_Constraint am sm tm m)

instance Subst Constraints where
  substM m a am tm sm = subst_Syn_Constraints $ wrap_Constraints (sem_Constraints a) 
    (Inh_Constraints am sm tm m)

instance Subst Field where
  substM m a am tm sm = subst_Syn_Field $ wrap_Field (sem_Field a) 
    (Inh_Field am sm tm m)

instance Subst EtaType where
  substM m a am tm sm = subst_Syn_EtaType $ wrap_EtaType (sem_EtaType a) 
    (Inh_EtaType am sm tm m)

instance Subst RhoType where
  substM m a am tm sm = subst_Syn_RhoType $ wrap_RhoType (sem_RhoType a) 
    (Inh_RhoType am sm tm m)

instance Subst RhoScheme where
  substM m a am tm sm = subst_Syn_RhoScheme $ wrap_RhoScheme (sem_RhoScheme a) 
    (Inh_RhoScheme am sm tm m)

instance Subst Env where
  substM m a am tm sm = subst_Syn_Env $ wrap_Env (sem_Env a) 
    (Inh_Env am sm tm m)

instance Subst Scheme where
  substM m a am tm sm = subst_Syn_Scheme $ wrap_Scheme (sem_Scheme a) 
    (Inh_Scheme am sm tm m)
    
instance Subst [Annotation] where
  substM m xs am tm sm = map (\x -> substM m x am tm sm) xs

instance Subst [Type] where
  substM m xs am tm sm = map (\x -> substM m x am tm sm) xs

instance Subst Fields where
  substM m xs am tm sm = map (\x -> substM m x am tm sm) xs
 
instance Subst [Fields] where
  substM m xss am tm sm = map (\xs -> substM m xs am tm sm) xss

instance Subst [RhoType] where
  substM m xs am tm sm = map (\x -> substM m x am tm sm) xs

instance Subst [[RhoType]] where
  substM m xss am tm sm = map (\xs -> substM m xs am tm sm) xss

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% substitition
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag

ATTR * [ substVars: {Set HsName} substAnnMap: AnnSol substTyMap: TySol substSchemeMap: SchemeSol | | subst: SELF ]

SEM Annotation Type Scheme
  | Var
    lhs.subst = maybe @loc.subst @loc.newSubst $ Map.lookup @v @loc.subMap
    loc.newSet = Set.insert @v @lhs.substVars
    loc.newSubst = \x -> if @v `Set.member` @lhs.substVars then traceShow ("recursive sub", @v, @lhs.substVars, @loc.subMap Map.! @v) $ @loc.fromVar @v else
                      substM @loc.newSet x @lhs.substAnnMap @lhs.substTyMap @lhs.substSchemeMap

SEM Annotation
  | Var
    loc.subMap = @lhs.substAnnMap
    loc.fromVar = Annotation_Var

SEM Type
  | Var
    loc.subMap = @lhs.substTyMap
    loc.fromVar = Type_Var

SEM Scheme
  | Var
    loc.subMap = @lhs.substSchemeMap
    loc.fromVar = Scheme_Var

%%]