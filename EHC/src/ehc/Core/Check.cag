%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Check core module when provided as source
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(50 codegen corein) hs module {%{EH}Core.Check} export(Syn_CodeAGItf(..))
%%]

%%[(50 codegen corein) hs import({%{EH}Base.Builtin},{%{EH}Base.Common},{%{EH}Opts},{%{EH}Ty},{%{EH}Error},{%{EH}Gam},{%{EH}Gam.DataGam})
%%]

%%[(50 codegen corein) hs import({%{EH}Base.TermLike},{%{EH}AbstractCore},{%{EH}Core})
%%]
%%[(8888 codegen corein) hs import({%{EH}LamInfo})
%%]
%%[(8888 codegen corein) hs import({%{EH}Core.BindExtract},qualified {%{EH}Core.SysF.AsTy} as SysF)
%%]

%%[(50 codegen corein) hs import(qualified UHC.Util.FastSeq as Seq)
%%]

%%[(50 codegen corein) hs import(Data.Maybe, qualified Data.Map as Map, Control.Applicative)
%%]

%%[(50 codegen corein) hs import(UHC.Util.Pretty)
%%]

%%[(50 codegen corein).WRAPPER ag import({Core/AbsSyn},{Core/CommonBindNm},{Core/CommonLev},{Core/CommonLevLet},{Core/CommonCtxtPred})
WRAPPER CodeAGItf
%%]

%%[(99 codegen corein)
-- PRAGMA strictcase
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(50 codegen corein) hs export(CheckEnv(..),emptyCheckEnv)
data CheckEnv
  = CheckEnv
      {- cenvLamMp       :: LamMp
      -}

emptyCheckEnv
  = CheckEnv
      -- emptyLamMp

%%]

%%[(50 codegen corein) hs export(cmodCheck')
cmodCheck'
  :: EHCOpts
     -> CheckEnv -> CModule
     -> Syn_CodeAGItf
cmodCheck' opts env cmod
  = t
  where t = wrap_CodeAGItf
              (sem_CodeAGItf (CodeAGItf_AGItf cmod))
              (Inh_CodeAGItf
                { opts_Inh_CodeAGItf = opts
                , env_Inh_CodeAGItf  = env
                })

cmodCheck
  :: EHCOpts
     -> CheckEnv -> CModule
     -> ( ErrL          -- check errors
        , HsName        -- the actual name of the module as used.
        , [HsName]      -- imported modules
        , Bool          -- has a main
        )
cmodCheck opts env cmod
  = ( Seq.toList $ errs_Syn_CodeAGItf t
    , realModuleNm_Syn_CodeAGItf t
    , []
    , True
    )
  where t = cmodCheck' opts env cmod
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Global info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(50 codegen corein)
ATTR
  AllCodeNT CodeAGItf
    [ opts: EHCOpts
      env : CheckEnv
    | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SELF
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen corein)
ATTR AllCodeNT [ | | self: SELF ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Module name
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(50 codegen corein)
ATTR CodeAGItf CModule [ | | realModuleNm: HsName ]

SEM CModule
  | Mod         lhs         .   realModuleNm        =   @moduleNm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Module has 'main'?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(50 codegen corein)
ATTR CodeAGItf CModule CExpr AllBindOnly [ | | hasMain USE {||} {False} : Bool ]

SEM CBind
  | Bind        lhs         .   hasMain             =   @nm == hsnMain

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Module is already lambda lifted?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(50 codegen corein)
ATTR AllCodeNT [ | | isFreeOfLam USE {&&} {True} : Bool ]
ATTR CExpr [ | | lamBodyIsFreeOfLam: Bool ]
ATTR CodeAGItf CModule CExpr AllBind [ | | isLamLifted USE {&&} {True} : Bool ]

SEM CExpr
  | Lam         lhs         .   isFreeOfLam         =   False
                            .   lamBodyIsFreeOfLam  =   if @body.whatBelow == ExprIsLam
                                                        then @body.lamBodyIsFreeOfLam
                                                        else @body.isFreeOfLam
  | * - Lam     lhs         .   lamBodyIsFreeOfLam  =   False

SEM CBound
  | Bind Val    loc         .   isLamLifted         =   if @expr.whatBelow == ExprIsLam
                                                        then @lhs.isGlobal && @expr.lamBodyIsFreeOfLam
                                                        else @expr.isFreeOfLam

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% DataGam
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen corein)
-- Gathering of dataGam
ATTR CodeAGItf CModule AllDeclMeta [ | | gathDataGam USE {`gamUnion`} {emptyGam} : DataGam ]

SEM CDeclMeta
  | Data		lhs			.	gathDataGam			=	gamSingleton @tyNm $ mkDGIForCodegenOnly @tyNm @dataCons.dataConstrTagMp

ATTR AllDataCon [ | | dataConstrTagMp USE {`Map.union`} {Map.empty}: DataConstrTagMp ]

SEM CDataCon
  | Con         loc         .   dti                 =   emptyDataTagInfo
                                                            { dtiConNm          = @conNm
                                                            , dtiCTag           = mkOnlyConInfoCTag @conNm @tagNr @arity
                                                            }
				lhs			.	dataConstrTagMp		=	Map.singleton @conNm @dti
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Lists of XX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen corein)
ATTR CAltL [ | | stL: {[SysF.Ty]} ]
%%]

%%[(8888 codegen corein)
SEM CAltL
  | Nil         lhs         .   stL                 =   []
  | Cons        lhs         .   stL                 =   @hd.st : @tl.stL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type checking: errors
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

No errors == ok

%%[(50 codegen corein) hs
type UndefNmMp = Map.Map MetaLev [ACoreBindRef]

undefmpUnion :: UndefNmMp -> UndefNmMp -> UndefNmMp
undefmpUnion = Map.unionWith (++)
%%]

%%[(50 codegen corein)
ATTR AllNT [ | | undefNmMp USE {`undefmpUnion`} {Map.empty} : UndefNmMp ]
%%]

%%[(50 codegen corein)
ATTR AllNT CodeAGItf [ | | errs USE {`Seq.union`} {Seq.empty} : ErrSq ]
%%]

%%[(8888 codegen corein)
SEM CBind
  | Bind        loc         .   nmErrs              =   Seq.unions
                                                            [ Seq.singleton $ rngLift emptyRange mkErr_NamesNotIntrod ("SysF@" ++ show l) (map mkHNm rs)
                                                            | (l,rs) <- Map.toList @bindAspects.undefNmMp
                                                            ]
                lhs         .   errs                =   if ehcOptCoreSysFCheckOnlyVal @lhs.opts && @bindAspects.gathMinMetaLev > @lhs.mlev
                                                        then Seq.empty
                                                        else let e = Seq.unions [@nmErrs,@bindAspects.errs]
                                                             in  Seq.fromList $ rngLift emptyRange mkNestErr (pp @nm) $ Seq.toList e
                            -- .   errs                =   Seq.empty
                            .   undefNmMp           =   Map.empty

SEM CExpr
  | App         lhs         .   errs                =   Seq.unions [@func.errs,@arg.errs,SysF.moutErrs @mout]
  | Case        lhs         .   errs                =   Seq.unions ([@expr.errs,@alts.errs] ++ map SysF.moutErrs @moutL)

%%]
SEM CExpr
  | Var         lhs         .   errs                =   @nmErrs
                                                        in  Seq.unions
                                                              [ @bind.errs, @l0.gathErrs
                                                              , Seq.fromList $ rngLift emptyRange mkNestErr (ppValBind @t) $ Seq.toList e
                                                              ]
SEM Expr
  | App         lhs         .   errs                =   Seq.unions [@func.errs,@arg.errs,moutErrs @mout]
  | Case        lhs         .   errs                =   Seq.unions ([@expr.errs,@alts.errs] ++ map moutErrs @moutL)
  | Cast        lhs         .   errs                =   Seq.unions [@expr.errs,@ty.errs,@castErrs]
  | Var Tup     lhs         .   errs                =   @nmErrs

