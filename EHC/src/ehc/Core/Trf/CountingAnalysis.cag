%%[0 lhs2tex
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Hidde's counting Analysis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Implementation of Hidde's counting Analysis

%%[(8 counting) hs module {%{EH}Core.Trf.CountingAnalysis} import(Data.Maybe,Data.Set (Set),qualified Data.Set as Set,Data.Map (Map),qualified Data.Map as Map,qualified Data.Map as Data.Map)
%%]

%%[(8 counting) hs import(qualified Data.Set as S,qualified Data.Map as M)
%%]

%%[(8 counting) hs import({%{EH}LamInfo},{%{EH}Base.Common},{%{EH}Base.HsName.Builtin},{%{EH}Gam.DataGam},{%{EH}Gam.Base},{%{EH}Core},{%{EH}Ty})
%%]

%%[(8 counting) hs import({%{EH}CountingAnalysis.ConstraintGeneration},{%{EH}CountingAnalysis.ConstraintSolver},{%{EH}CountingAnalysis},{%{EH}CountingAnalysis.Pretty})
%%]

%%[(8 counting) hs import({%{EH}CountingAnalysis.ToCAModule}, {%{EH}CountingAnalysis.ToCModule})
%%]

%%[(8 counting) hs import(qualified {%{EH}CountingAnalysis.Substitution} as S, {%{EH}CountingAnalysis.AnnotateType})
%%]

%%[(8 counting) hs import(UHC.Util.Utils, UHC.Util.Pretty)
%%]

%%[(8 counting) hs import(Control.Monad (foldM), Control.Monad.State)
%%]

%%[(8 counting) hs import(Data.Monoid ((<>)))
%%]

%%[(8 counting) hs import(Data.List (zipWith7), Control.Arrow(first))
%%]

Debugging
%%[(8 counting) hs import(Debug.Trace)
%%]

%%[(8 counting).WRAPPER ag import({CountingAnalysis/AbsSynExpr})
WRAPPER Expr
%%]

%%[(99 counting)
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) hs
cmodTrfAnalysis :: Bool -> DataGam -> LamMp -> CModule -> (CModule, LamMp)
cmodTrfAnalysis subeff d imps m = traceShow (pp e, e) $ traceShow (ppMap bi) $ test `seq` res
-- cmodTrfAnalysis subeff d imps m = traceShow (pp e, e, m) $ traceShow (ppMapAnnFree bi, ex) $ test `seq` res
-- cmodTrfAnalysis subeff d imps m = test `seq` res
-- cmodTrfAnalysis subeff d imps m = traceShow m (m,imps)
  where Module_Module e extra = toCAModule im m
        syn = wrap_Expr (sem_Expr e)
                Inh_Expr
                  { dataEnv_Inh_Expr = specialtrace d
                  , exports_Inh_Expr = ex
                  , importEnv_Inh_Expr = im
                  , subeffecting_Inh_Expr = if subeff then genSub else genEq
                  , toHsName_Inh_Expr = toHsName
                  , freshVar_Inh_Expr = 0
                  }
        im = toImports imps
        ex = traceShowId $ S.map (fixHsName modName) $ toExports d m
        c = toConstraints $ constraints_Syn_Expr syn
        conMap = constraintsMap_Syn_Expr syn
        e' = annCopy_Syn_Expr syn
        bindingEnv = bindingEnv_Syn_Expr syn
        finalBindEnv = S.substSolution bindingEnv s
        newLamMap = toLamMp finalBindEnv
        finalLamMap = lamMpMergeInto (\(LamInfo {laminfoCaType=a}) i -> i {laminfoCaType=a}) const newLamMap imps
        s = traceShow ("num constraints: ", countConstraints c conMap) $ printTrace c conMap $ solveDef c 
          (emptySolveState {_freshVar = freshVar_Syn_Expr syn, _toHsName = toHsName, _constraintMap = conMap})
        toHsName v = mkHNm $ show modName ++ ".CA@" ++ show v
        modName = moduleNm_CModule_Mod m
        bi = envFilterList finalBindEnv ex
        res = if M.size bi == S.size ex 
          then (toCModule $ Module_Module (S.substSolution e' s) extra, finalLamMap) 
          else panic $ "not all exported symbols have a type: " ++ show (ppMap finalBindEnv)
        test = if m /= toCModule (Module_Module e extra) then panic "toCModule . toCAModule /= id"  else ()

specialtrace :: DataGam -> DataGam
specialtrace = id
-- specialtrace dg = traceShow ("DataGamGen:", dgl) dg
  -- where dgl = map f $ gamToAssocL dg
  --       f (n, dgi) = (n, dgiAnnVars dgi, Map.map (\x -> dtiFldAnnTyL x) $ dgiConstrTagMp dgi) 

type DataEnv = DataGam

-- printTrace :: Constraints -> cm -> a -> a
printTrace c cm = if countConstraints c cm < 300 then printTraceShort (c,cm) else printTraceLong c

printTraceLong = flip const
-- printTraceLong = traceShow . vlist . map ppAnnFree . filterGen
-- printTraceLong [] = id
-- printTraceLong (x:xs) = traceShow x . printTraceLong xs

printTraceShort = flip const
-- printTraceShort = traceShow . pp

-- filterGen :: Constraints -> Constraints
-- filterGen [] = []
-- filterGen (Constraint_Gen t u d v0 d0 c e s : xs) = Constraint_Gen t u d v0 d0 (filterGen c) e s : filterGen xs
-- filterGen (_:xs) = filterGen xs

countConstraints :: Constraints -> Map a Constraints -> Int
countConstraints c cm = length c + sum (map length $ M.elems cm) 

toLamMp :: BindingEnv -> LamMp
toLamMp = M.map $ \x -> emptyLamInfo {laminfoCaType = x}

toImports :: LamMp -> Imports
toImports x = M.map getType $ M.filter (/= (RhoScheme_Rho (EtaScheme_Eta 
              (Scheme_Forall S.empty S.empty [] (Type_Error "Empty lamInfo")) $ Annotation_Val S.empty)
                 $ Annotation_Val S.empty)) $ M.map laminfoCaType x

toExports :: DataGam -> CModule -> Exports
toExports d (CModule_Mod _ exps _ _ _) = toExports' exps
  where toExports' [] = S.empty
        toExports' (CExport_Export n:xs) = S.insert n $ toExports' xs
        toExports' (CExport_ExportData n Nothing:xs) = Set.union cs $ toExports' xs
          where cs = Set.fromList $ Map.keys $ dgiConstrTagMp $ fromMaybe (panic "ex") $ n `dataGamLookup` d 
        toExports' (CExport_ExportData _ (Just cs):xs) = S.union (S.fromList cs) $ toExports' xs
        
annVars :: DataGamInfo -> HsNames
annVars = dgiAnnVars

tyVars :: DataGamInfo -> HsNames
tyVars = dgiTyVars

constrs :: DataGamInfo -> Map HsName Fields
constrs = Map.map dtiFldAnnTyL . dgiConstrTagMp

fromFields :: Fields -> [RhoType]
fromFields = map fromField

fromField :: Field -> RhoType
fromField (Field_Lazy t) = t
fromField (Field_Strict t) = t

-- temp

-- TODO ask atze as this is basically hope it works stuff
fixHsName :: HsName -> HsName -> HsName
fixHsName x hnm = mkHNm $ show x ++ "." ++ show hnm

traceShow2 :: (Show a, Show b) => a -> b -> b
traceShow2 x y = y
-- traceShow2 x y = traceShow ("***********",x,y,"$$$$$$$$$$$$$$") y

traceShow1 :: (Show a, Show b) => a -> b -> b
traceShow1 x y = y
-- traceShow1 x y = traceShow ("*********",x,y,"#########") y

%%]

%%[(8 counting) hs export(cmodTrfAnalysisCounting)
cmodTrfAnalysisCounting :: DataGam -> LamMp -> CModule -> (CModule, LamMp)
cmodTrfAnalysisCounting = cmodTrfAnalysis True
%%]

%%[(8 counting) hs export(cmodTrfAnalysisCountingUnique)
cmodTrfAnalysisCountingUnique :: DataGam -> LamMp -> CModule -> (CModule, LamMp)
cmodTrfAnalysisCountingUnique = cmodTrfAnalysis False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Global info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag
ATTR * [ toHsName: {Var -> HsName} importEnv: {Imports} exports: {Exports} dataEnv: {DataEnv} subeffecting: {Annotation -> Annotation -> GatherConstraints} | freshVar: {Var} | annCopy: SELF ]
ATTR * [ | | bindingEnv USE {M.union} {M.empty}: {BindingEnv} constraintsMap USE {M.union} {M.empty}: {Map Var Constraints}]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag
ATTR Expr AltCon AltConst AltCons AltConsts Binding [ | | env: {Env} etaTy: {EtaType} constraints: {GatherConstraints}]
ATTR ConVars [ | | env: {Env} rhoTypes: {[RhoType]} constraints: {GatherConstraints} ] -- doen
ATTR ConVar [ | | env: {Env} rhoTy: {RhoType} constraints: {GatherConstraints}] -- done
ATTR Const AltConsts AltConst [ | | ty: {Type}] -- done
ATTR AltCons AltCon [ | | tyNm: {HsName}] -- done
ATTR AltCons [ | | rhoSchemes: {Map HsName [RhoScheme]}] -- done
ATTR AltCon [ | | conNm: {HsName} rhoSchemes: {[RhoScheme]}] -- done
ATTR Bindings [ | | rhoSchemes: {[[RhoScheme]]}] -- done
ATTR Binding [ | | rhoSchemes: {[RhoScheme]}] -- done
ATTR Bindings [ | | constraints: {GatherConstraints} envs: {[Env]} bindingNames: {HsNames} etaTypes: {[EtaType]}]
ATTR ConVars AltCons AltConsts Bindings [ | | isNil: {Bool}] --done
ATTR Binding [ | | bindingName: {HsName} ]
ATTR Binding Bindings [ allBindingNames: {HsNames} | | ]
ATTR Expr [ | | maybeDemand: {Maybe Annotation}]

SEM Expr
  | VarLocal
    lhs.maybeDemand = Just @loc.delta
  | * - VarLocal Ann AnnCore
    lhs.maybeDemand = Nothing

SEM Expr
  | VarLocal
    loc.tau = Type_Var $ @lhs.toHsName @lhs.freshVar
    loc.sigma = Scheme_Var $ @lhs.toHsName $ @lhs.freshVar + 1
    loc.nu = Annotation_Var $ @lhs.toHsName $ @lhs.freshVar + 2
    loc.delta = Annotation_Var $ @lhs.toHsName $ @lhs.freshVar + 3
    loc.etaTy = EtaType_Eta @loc.tau @loc.nu
    lhs.freshVar = @lhs.freshVar + 4
    -- lhs.env = M.singleton @v $ RhoScheme_Rho (EtaScheme_Eta @loc.sigma @loc.nu) @loc.delta -- annOne
    lhs.env = M.singleton @v $ RhoScheme_Rho (EtaScheme_Eta @loc.sigma @loc.nu) annOne
    lhs.etaTy = @loc.etaTy
    lhs.constraints = singleGC $ Constraint_Inst @v @loc.sigma @loc.tau
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_VarLocal @v @extra
  | VarImport
    loc.tau = Type_Var $ @lhs.toHsName @lhs.freshVar
    loc.sigma = @lhs.importEnv M.! @v
    loc.etaTy = EtaType_Eta @loc.tau annTop
    lhs.freshVar = @lhs.freshVar + 1
    lhs.env = M.empty
    lhs.etaTy = @loc.etaTy
    lhs.constraints = singleGC $ Constraint_Inst @v @loc.sigma @loc.tau
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_VarImport @v @extra
  | Const
    loc.tau = @c.ty
    loc.nu = Annotation_Var $ @lhs.toHsName @lhs.freshVar
    loc.etaTy = EtaType_Eta @loc.tau @loc.nu
    lhs.freshVar = @lhs.freshVar + 1
    lhs.env = M.empty
    lhs.etaTy = @loc.etaTy
    lhs.constraints = mempty
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_Const @c.annCopy
  | Abs
    loc.env1 = M.delete @bind @body.env
    loc.(rho, fv) = envLookupFresh (@body.freshVar, @lhs.toHsName) @body.env @bind
    loc.sigma = getType @loc.rho
    loc.nu = getUsage @loc.rho
    loc.delta = getDemand @loc.rho
    loc.eta = @body.etaTy
    loc.c1 = @body.constraints 
    loc.nu2 = Annotation_Var $ @lhs.toHsName @loc.fv
    loc.tau = Type_Var $ @lhs.toHsName $ @loc.fv + 1
    loc.((env2, c2), fv2) = computeTimes (@loc.fv + 2, @lhs.toHsName) @loc.nu2 @loc.env1
    loc.etaTy = EtaType_Eta (Type_Func (RhoType_Rho (EtaType_Eta @loc.tau @loc.nu) @loc.delta) @loc.eta) @loc.nu2
    lhs.freshVar = @loc.fv2
    lhs.env = @loc.env2
    lhs.etaTy = @loc.etaTy
    lhs.constraints = @loc.c1 <> @loc.c2 <> genEq @loc.sigma (Scheme_Forall mempty mempty mempty @loc.tau)
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_Abs @bind @body.annCopy @extra
    +bindingEnv = M.insert @bind @loc.rho
  | AppLocal
    loc.env1 = @func.env
    loc.eta' = @func.etaTy
    loc.c1 = @func.constraints
    loc.delta2 = Annotation_Var $ @lhs.toHsName @func.freshVar
    loc.sigmax = Scheme_Var $ @lhs.toHsName $ @func.freshVar + 1
    loc.nux = Annotation_Var $ @lhs.toHsName $ @func.freshVar + 2
    loc.taux = Type_Var $ @lhs.toHsName $ @func.freshVar + 3
    loc.eta4 = EtaScheme_Eta @loc.sigmax @loc.nux
    loc.eta2' = EtaType_Eta @loc.taux @loc.nux
    loc.c2 = singleGC $ Constraint_Inst @arg @loc.sigmax @loc.taux
    loc.eta3 = EtaType_Eta (Type_Var $ @lhs.toHsName $ @func.freshVar + 4) $ Annotation_Var $ @lhs.toHsName $ @func.freshVar + 5
    loc.((eta2, c2'), fv) = sub (@func.freshVar + 6, @lhs.toHsName) @lhs.subeffecting @loc.eta2'
    loc.((etas', c1'), fv2) = sub (@loc.fv, @lhs.toHsName) genSub @loc.eta'
    loc.tau1 = getType @loc.etas'
    loc.nu1 = getUsage @loc.etas'
    loc.((env2, c3), fv3) = computePlus (@loc.fv2, @lhs.toHsName) @loc.env1 $ M.singleton @arg $ RhoScheme_Rho @loc.eta4 @loc.delta2
    loc.etaTy = @loc.eta3
    lhs.freshVar = @loc.fv3
    lhs.env = @loc.env2
    lhs.etaTy = @loc.etaTy
    lhs.constraints = mconcat [@loc.c1, @loc.c1', @loc.c2, @loc.c2', @loc.c3, 
                        genEq @loc.tau1 $ Type_Func (RhoType_Rho @loc.eta2 @loc.delta2) @loc.eta3, 
                        genEq @loc.nu1 annOne]
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_AppLocal @func.annCopy @arg @extra
  | AppImport
    loc.env = @func.env
    loc.eta' = @func.etaTy
    loc.c1 = @func.constraints
    loc.delta2 = Annotation_Var $ @lhs.toHsName @func.freshVar
    loc.sigmax = @lhs.importEnv M.! @arg
    loc.taux = Type_Var $ @lhs.toHsName $ @func.freshVar + 2
    loc.eta2' = EtaType_Eta @loc.taux annTop
    loc.c2 = singleGC $ Constraint_Inst @arg @loc.sigmax @loc.taux
    loc.eta3 = EtaType_Eta (Type_Var $ @lhs.toHsName $ @func.freshVar + 3) $ Annotation_Var $ @lhs.toHsName $ @func.freshVar + 4
    loc.((eta2, c2'), fv) = sub (@func.freshVar + 5, @lhs.toHsName) @lhs.subeffecting @loc.eta2'
    loc.((etas', c1'), fv2) = sub (@loc.fv, @lhs.toHsName) genSub @loc.eta'
    loc.tau1 = getType @loc.etas'
    loc.nu1 = getUsage @loc.etas'
    loc.etaTy = @loc.eta3
    lhs.freshVar = @loc.fv2
    lhs.env = @loc.env
    lhs.etaTy = @loc.etaTy
    lhs.constraints = mconcat [@loc.c1, @loc.c1', @loc.c2, @loc.c2', 
                        genEq @loc.tau1 $ Type_Func (RhoType_Rho @loc.eta2 @loc.delta2) @loc.eta3, 
                        genEq @loc.nu1 annOne]
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_AppImport @func.annCopy @arg @extra
  | AppConst
    loc.env = @func.env
    loc.eta' = @func.etaTy
    loc.c1 = @func.constraints
    loc.delta2 = Annotation_Var $ @lhs.toHsName @func.freshVar
    loc.eta2' = EtaType_Eta @arg.ty $ Annotation_Var $ @lhs.toHsName $ @func.freshVar + 1
    loc.eta3 = EtaType_Eta (Type_Var $ @lhs.toHsName $ @func.freshVar + 2) $ Annotation_Var $ @lhs.toHsName $ @func.freshVar + 3
    loc.((eta2, c2), fv) = sub (@func.freshVar + 4, @lhs.toHsName) @lhs.subeffecting @loc.eta2'
    loc.((etas', c1'), fv2) = sub (@loc.fv, @lhs.toHsName) genSub @loc.eta'
    loc.tau1 = getType @loc.etas'
    loc.nu1 = getUsage @loc.etas'
    loc.etaTy = @loc.eta3
    lhs.freshVar = @loc.fv2
    lhs.env = @loc.env
    lhs.etaTy = @loc.etaTy
    lhs.constraints = mconcat [@loc.c1, @loc.c1', @loc.c2, 
                        genEq @loc.tau1 $ Type_Func (RhoType_Rho @loc.eta2 @loc.delta2) @loc.eta3, 
                        genEq @loc.nu1 annOne]
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_AppConst @func.annCopy @arg.annCopy @extra
  | Let
    binds.allBindingNames = @binds.bindingNames
    loc.env0 = envDeleteList @e.env @binds.bindingNames
    loc.(rho0i, fvs) = envLookupFreshList (@e.freshVar, @lhs.toHsName) @e.env @binds.bindingNames
    loc.sigmai = map getType @loc.rho0i
    loc.nui = map (\(e, r, f) -> if e then Annotation_Var $ @lhs.toHsName f else getUsage r) $ zip3 @loc.boolExports @loc.rho0i [@loc.fvs + length @loc.rho0i ..]
    loc.boolExports = map (`S.member` @lhs.exports) @binds.bindingNames
    loc.delta0i = map (\(e, r, f) -> if e then Annotation_Var $ @lhs.toHsName f else getDemand r) $ zip3 @loc.boolExports @loc.rho0i [@loc.fvs ..]
    loc.fv = @loc.fvs + 2 * length @loc.rho0i
    loc.deltai = map (Annotation_Var . @lhs.toHsName) [@loc.fv .. @loc.fv + length @loc.delta0i - 1]
    loc.fv0 = @loc.fv + length @loc.delta0i
    loc.eta = @e.etaTy
    loc.c0 = @e.constraints
    loc.tauij = map (\x -> map (Type_Var . @lhs.toHsName) [@loc.fv0 + x * length @binds.bindingNames .. @loc.fv0 + (x + 1) * length @binds.bindingNames - 1]) [0 .. length @binds.bindingNames - 1]
    loc.fv1 = @loc.fv0 + length @binds.bindingNames * length @binds.bindingNames
    loc.sigmaij = map (map $ Scheme_Forall mempty mempty mempty) @loc.tauij
    loc.envi = @binds.envs
    loc.sigmaij' = map (map getType) @binds.rhoSchemes
    loc.nuij = map (map getUsage) @binds.rhoSchemes
    loc.deltaij = map (map getDemand) @binds.rhoSchemes
    loc.taui = map getType @binds.etaTypes
    loc.nuxi = map getUsage @binds.etaTypes
    loc.c0'= genEq @loc.nui @loc.nuxi
    loc.c1i = @binds.constraints
    loc.c1' = genEq @loc.sigmaij @loc.sigmaij'
    loc.c1 = @loc.c1' <> @loc.c1i
    
    loc.((envi', c2i), fv2) = computeCondList (@loc.fv1 + length @binds.bindingNames ^ 2, @lhs.toHsName) @loc.deltai @loc.envi
    loc.((env', c2), fv3) = bigPlus (@loc.fv2, @lhs.toHsName) @loc.envi'
    loc.((env, c2'), fv4) = computePlus (@loc.fv3, @lhs.toHsName) @loc.env0 @loc.env'
    
    loc.((deltaij', c3ij), fv5) = computeCondMatrix (@loc.fv4, @lhs.toHsName) @loc.deltai @loc.deltaij
    loc.((deltai', c3i), fv6) = bigPlusMatrix (@loc.fv5, @lhs.toHsName) @loc.deltaij'
    loc.((deltai'', c3i'), fv7) = computePlus (@loc.fv6, @lhs.toHsName) @loc.deltai @loc.deltai'
    loc.c3' = genEq @loc.deltai @loc.deltai''
    loc.c3 = @loc.c3' <> @loc.c3ij <> @loc.c3i <> @loc.c3i'
    
    loc.((nuij', c4ij), fv8) = computeCondMatrix (@loc.fv7, @lhs.toHsName) @loc.deltai @loc.nuij
    loc.((nui', c4i), fv9) = bigPlusMatrix (@loc.fv8, @lhs.toHsName) @loc.nuij'
    loc.((nu0i, c4i'), fv10) = computePlus (@loc.fv9, @lhs.toHsName) @loc.nui @loc.nui'
    loc.c4' = mempty
    -- loc.c4' = genEq @loc.nu0i @loc.nui
    loc.c4 = @loc.c4' <> @loc.c4ij <> @loc.c4i <> @loc.c4i'
    
    loc.((tauij', c5ij), fv11) = computeCondMatrix (@loc.fv10, @lhs.toHsName) @loc.deltai @loc.tauij
    loc.((taui', c5i), fv12) = bigPlusMatrix (@loc.fv11, @lhs.toHsName) @loc.tauij'
    loc.c5' = genEq @loc.taui' @loc.taui
    loc.c5 = @loc.c5' <> @loc.c5ij <> @loc.c5i
    
    loc.cGen = @loc.c1 <> @loc.c3 <> @loc.c4 <> @loc.c5
    loc.c6 = mconcat $ zipWith7 (\nm t n d n0 d0 s -> traceShow ("let:", nm, s) $ singleGC $ Constraint_Gen nm t n d n0 d0 @loc.fv12 @loc.env s) @binds.bindingNames @loc.taui @loc.nui @loc.deltai @loc.nu0i @loc.delta0i @loc.sigmai
    loc.c7i = zipWith3 (\x n d0 -> if x `S.member` @lhs.exports then genEq n annTop <> genEq d0 annTop else mempty) @binds.bindingNames @loc.nu0i @loc.deltai
    
    loc.etaTy = @loc.eta
    lhs.freshVar = @loc.fv12 + 1
    lhs.env = @loc.env
    lhs.etaTy = @loc.etaTy
    lhs.constraints = @loc.c6 <> @loc.c0 <> @loc.c0' <> @loc.c2 <> @loc.c2' <> @loc.c2i <> mconcat @loc.c7i
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_Let @binds.annCopy @e.annCopy @extra
    +bindingEnv = M.union (M.fromList $ zip @binds.bindingNames @loc.rho0i)
    +constraintsMap = M.insert @loc.fv12 $ toConstraints @loc.cGen
  | LetBang
    loc.env0 = M.delete @x @e2.env
    loc.(rho0, fv) = envLookupFresh (@e2.freshVar, @lhs.toHsName) @e2.env @x
    loc.sigma0 = getType @loc.rho0
    loc.nu = getUsage @loc.rho0
    loc.delta = getDemand @loc.rho0
    loc.eta = @e2.etaTy
    loc.c0 = @e2.constraints
    loc.env1 = M.delete @x @e1.env
    loc.(rho1, fv2) = envLookupFresh (@loc.fv, @lhs.toHsName) @e1.env @x
    loc.sigma' = getType @loc.rho1
    loc.nu1 = getUsage @loc.rho1
    loc.delta1 = getDemand @loc.rho1
    loc.tau = getType @e1.etaTy
    loc.nu2 = getUsage @e1.etaTy
    loc.c1 = @e1.constraints
    loc.c1' = genEq @loc.sigma' (Scheme_Forall mempty mempty mempty @loc.tau)-- <> genSub annZero @loc.nu2
    loc.((env, c2), fv3) = computePlus (@loc.fv2, @lhs.toHsName) @loc.env0 @loc.env1
    loc.((delta0, c3), fv4) = computePlus (@loc.fv3, @lhs.toHsName) annOne @loc.delta
    loc.((delta', c4), fv5) = computePlus (@loc.fv4, @lhs.toHsName) @loc.delta0 @loc.delta1
    -- loc.c4' = mempty 
    loc.c4' = genEq @loc.delta0 @loc.delta'
    -- loc.c4'' = mempty
    loc.c4'' = case @e1.maybeDemand of
                Nothing -> mempty
                Just d -> genEq d @loc.delta'
    loc.((nu', c5), fv6) = computePlus (@loc.fv5, @lhs.toHsName) @loc.nu @loc.nu1
    loc.c5' = mempty
    -- loc.c5' = genEq @loc.nu @loc.nu'
    loc.cGen = @loc.c1 <> @loc.c1' <> @loc.c3 <> @loc.c4 <> @loc.c4' <> @loc.c4'' <> @loc.c5 <> @loc.c5'
    loc.c6 = traceShow ("letBang:", @x, @loc.sigma0) $ singleGC $ Constraint_Gen @x @loc.tau @loc.nu @loc.delta0 @loc.nu' @loc.delta' @loc.fv6 @loc.env @loc.sigma0
    loc.etaTy = @loc.eta
    lhs.freshVar = @loc.fv6 + 1
    lhs.env = @loc.env
    lhs.etaTy = @loc.etaTy
    lhs.constraints = @loc.c6 <> @loc.c0 <> @loc.c2
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_LetBang @x @e1.annCopy @e2.annCopy @extra
    +bindingEnv = M.insert @x (RhoScheme_Rho (EtaScheme_Eta @loc.sigma0 @loc.nu') @loc.delta')
    +constraintsMap = M.insert @loc.fv6 $ toConstraints @loc.cGen
  | Con
    loc.env = @flds.env
    loc.rho' = @flds.rhoTypes
    loc.c1 = @flds.constraints
    loc.data = fromMaybe (error "con") $ @tyNm `dataGamLookup` @lhs.dataEnv
    loc.ul = annVars @loc.data
    loc.ak = tyVars @loc.data
    loc.rhoj = fromFields $ constrs @loc.data M.! @conNm
    loc.phil = map (Annotation_Var . @lhs.toHsName) [@flds.freshVar .. @flds.freshVar + length @loc.ul - 1]
    loc.tauk = map (Type_Var . @lhs.toHsName) [@flds.freshVar + length @loc.ul  .. @flds.freshVar + length @loc.ul + length @loc.ak - 1]
    loc.sol = Solution (M.fromList $ zip @loc.ul @loc.phil) (M.fromList $ zip @loc.ak @loc.tauk) M.empty
    loc.rhoj' = S.substSolution @loc.rhoj @loc.sol
    loc.c2 = genEq @loc.rhoj' @loc.rho'
    loc.nu = Annotation_Var $ @lhs.toHsName $ @flds.freshVar + length @loc.ul + length @loc.ak
    loc.etaTy = EtaType_Eta (Type_Data @tyNm @loc.phil @loc.tauk) @loc.nu
    lhs.freshVar = @flds.freshVar + length @loc.ul + length @loc.ak + 1
    lhs.env = @loc.env
    lhs.etaTy = @loc.etaTy
    lhs.constraints = @loc.c1 <> @loc.c2
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_Con @tyNm @conNm @flds.annCopy @extra
  | Tup
    -- copy rules
    loc.nu = Annotation_Var $ @lhs.toHsName @flds.freshVar
    loc.etaTy = EtaType_Eta (Type_Tup @flds.rhoTypes) @loc.nu
    lhs.freshVar = @flds.freshVar + 1
    lhs.etaTy = @loc.etaTy
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_Tup @flds.annCopy @extra
  | CaseCon
    loc.data = fromMaybe (error "CaseCon") $ @alts.tyNm `dataGamLookup` @lhs.dataEnv
    loc.ul = annVars @loc.data
    loc.ak = tyVars @loc.data
    loc.rhoijtau = map (fromFields . snd) $ M.toList $ constrs @loc.data
    loc.phil = map (Annotation_Var . @lhs.toHsName) [@alts.freshVar .. @alts.freshVar + length @loc.ul - 1]
    loc.tauk = map (Type_Var . @lhs.toHsName) [@alts.freshVar + length @loc.ul  .. @alts.freshVar + length @loc.ul + length @loc.ak - 1]
    loc.sol = Solution (M.fromList $ zip @loc.ul @loc.phil) (M.fromList $ zip @loc.ak @loc.tauk) M.empty
    loc.rhoijtau' = S.substSolution @loc.rhoijtau @loc.sol
    loc.rhoijsigma = map (map $ fromGRho . fmap (Scheme_Forall mempty mempty mempty) . toGRho) @loc.rhoijtau'
    loc.env0 = @e.env
    loc.tau0 = getType @e.etaTy
    loc.nu0 = getUsage @e.etaTy
    loc.c1 = @e.constraints
    loc.c1' = genEq @loc.tau0 (Type_Data @alts.tyNm @loc.phil @loc.tauk) <> genSub annOne @loc.nu0
    loc.env' = @alts.env
    loc.rhoij' = M.elems @alts.rhoSchemes
    loc.eta1 = @alts.etaTy
    loc.c2 = @alts.constraints
    loc.c2' = genEq @loc.rhoijsigma @loc.rhoij'
    loc.((env, c3'), fv) = computePlus (@alts.freshVar + length @loc.ul + length @loc.ak, @lhs.toHsName) @loc.env0 @loc.env'
    loc.etaTy = @loc.eta1
    lhs.freshVar = @loc.fv
    lhs.env = @loc.env
    lhs.etaTy = @loc.etaTy
    lhs.constraints = @loc.c1 <> @loc.c1' <> @loc.c2 <> @loc.c2' <> @loc.c3'
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_CaseCon @e.annCopy @alts.annCopy @extra
  | CaseTup
    loc.rhoitau = map (\n -> RhoType_Rho (EtaType_Eta (Type_Var $ @lhs.toHsName $ @e1.freshVar + 3 * n) $ Annotation_Var $ @lhs.toHsName $ @e1.freshVar + 1 + 3 * n) $ Annotation_Var $ @lhs.toHsName $ @e1.freshVar + 2 + 3 * n) [0 .. length @xs - 1]
    loc.rhoisigma = map (fromGRho . fmap (Scheme_Forall mempty mempty mempty) . toGRho) @loc.rhoitau
    loc.env0 = @e.env
    loc.tau0 = getType @e.etaTy
    loc.nu0 = getUsage @e.etaTy
    loc.c1 = @e.constraints
    loc.c1' = genEq @loc.tau0 (Type_Tup @loc.rhoitau) <> genSub annOne @loc.nu0
    loc.env1 = envDeleteList @e1.env @xs
    loc.(rhoi', fv) = envLookupFreshList (@e1.freshVar + 3 * length @xs, @lhs.toHsName) @e1.env @xs
    loc.eta = @e1.etaTy
    loc.c2 = @e1.constraints
    loc.c2' = genEq @loc.rhoisigma @loc.rhoi'
    loc.((env, c3), fv2) = computePlus (@loc.fv, @lhs.toHsName) @loc.env0 @loc.env1
    loc.etaTy = @loc.eta
    lhs.freshVar = @loc.fv2
    lhs.env = @loc.env
    lhs.etaTy = @loc.etaTy
    lhs.constraints = @loc.c1 <> @loc.c1' <> @loc.c2 <> @loc.c2' <> @loc.c3
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_CaseTup @e.annCopy @xs @e1.annCopy @extra
    +bindingEnv = M.union (M.fromList $ zip @xs @loc.rhoisigma)
  | CaseConst
    loc.tau = @alts.ty
    loc.env0 = @e.env
    loc.tau0 = getType @e.etaTy
    loc.nu0 = getUsage @e.etaTy
    loc.c1 = @e.constraints
    loc.c1' = genEq @loc.tau0 @loc.tau <> genSub annOne @loc.nu0
    loc.env' = @alts.env
    loc.eta1 = @alts.etaTy
    loc.c2 = @alts.constraints
    loc.((env, c3'), fv) = computePlus (@alts.freshVar, @lhs.toHsName) @loc.env0 @loc.env'
    loc.etaTy = @loc.eta1
    lhs.freshVar = @loc.fv
    lhs.env = @loc.env
    lhs.etaTy = @loc.etaTy
    lhs.constraints = @loc.c1 <> @loc.c1' <> @loc.c2 <> @loc.c3'
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_CaseConst @e.annCopy @alts.annCopy @extra
  | FFI
    loc.tau = Type_Var $ @lhs.toHsName @lhs.freshVar
    loc.sigma = annotate @lhs.dataEnv @ty
    loc.(_,_,ent) = @extra
    loc.etaTy = EtaType_Eta @loc.tau annTop
    lhs.freshVar = @lhs.freshVar + 1
    lhs.env = M.empty
    lhs.etaTy = @loc.etaTy
    lhs.constraints = singleGC $ Constraint_Inst (mkHNm $ "FFI: " ++ show @loc.ent) @loc.sigma @loc.tau
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_FFI @ty @extra
  | Error
    lhs.env = panic "Error expression" 
    lhs.constraints = panic "Error expression" 
    lhs.etaTy = panic "Error expression" 

SEM ConVars
  | Cons
    loc.((env, c'), fv) = if @tl.isNil then ((@hd.env, mempty), @tl.freshVar) else computePlus (@tl.freshVar, @lhs.toHsName) @hd.env @tl.env
    loc.c = @hd.constraints <> if @tl.isNil then mempty else @tl.constraints
    lhs.freshVar = @loc.fv
    lhs.env = @loc.env
    lhs.rhoTypes = @hd.rhoTy : if @tl.isNil then [] else @tl.rhoTypes
    lhs.constraints = @loc.c' <> @loc.c
  | Nil
    lhs.env = M.empty
    lhs.rhoTypes = []
    lhs.constraints = mempty
    
SEM ConVar
  | VarLocal
    loc.tau = Type_Var $ @lhs.toHsName @lhs.freshVar
    loc.sigma = Scheme_Var $ @lhs.toHsName $ @lhs.freshVar + 1
    loc.nu = Annotation_Var $ @lhs.toHsName $ @lhs.freshVar + 2
    loc.delta2 = Annotation_Var $ @lhs.toHsName $ @lhs.freshVar + 3
    lhs.freshVar = @lhs.freshVar + 4
    lhs.env = M.singleton @v $ RhoScheme_Rho (EtaScheme_Eta @loc.sigma @loc.nu) @loc.delta2 -- annOne
    lhs.rhoTy = RhoType_Rho (EtaType_Eta @loc.tau @loc.nu) @loc.delta2
    lhs.constraints = singleGC $ Constraint_Inst @v @loc.sigma @loc.tau
  | VarImport
    loc.tau = Type_Var $ @lhs.toHsName @lhs.freshVar
    loc.sigma = @lhs.importEnv M.! @v
    loc.delta2 = Annotation_Var $ @lhs.toHsName $ @lhs.freshVar + 1
    lhs.freshVar = @lhs.freshVar + 2
    lhs.env = M.empty
    lhs.rhoTy = RhoType_Rho (EtaType_Eta @loc.tau annTop) @loc.delta2
    lhs.constraints = singleGC $ Constraint_Inst @v @loc.sigma @loc.tau
  | Const
    loc.tau = @c.ty
    loc.nu = Annotation_Var $ @lhs.toHsName @lhs.freshVar
    loc.delta2 = Annotation_Var $ @lhs.toHsName $ @lhs.freshVar + 1
    lhs.freshVar = @lhs.freshVar + 2
    lhs.env = M.empty
    lhs.rhoTy = RhoType_Rho (EtaType_Eta @loc.tau @loc.nu) @loc.delta2
    lhs.constraints = mempty

SEM AltCons AltConsts
  | Cons
    loc.((env, c1), fv) = if @tl.isNil then ((@hd.env, mempty), @hd.freshVar) 
                            else computeUnion (@tl.freshVar, @lhs.toHsName) @hd.env @tl.env
    loc.c2 = if @tl.isNil then mempty else genEq @hd.etaTy @tl.etaTy
    lhs.freshVar = @loc.fv
    lhs.env = @loc.env
    lhs.etaTy = @hd.etaTy
    lhs.constraints = @loc.c1 <> @loc.c2 <> @hd.constraints <> (if @tl.isNil then mempty else @tl.constraints)
  | Nil
    lhs.env = panic "env"
    lhs.etaTy = panic "etaTy"
    lhs.constraints = panic "constraints"

SEM AltCon
  | Alt
    loc.env = envDeleteList @e.env @xs
    loc.(rhosigma, fv) = envLookupFreshList (@e.freshVar, @lhs.toHsName) @e.env @xs
    lhs.freshVar = @loc.fv
    lhs.env = @loc.env
    lhs.etaTy = @e.etaTy
    lhs.constraints = @e.constraints
    lhs.rhoSchemes = @loc.rhosigma
    lhs.conNm = @conNm
    +bindingEnv = M.union (M.fromList $ zip @xs @loc.rhosigma)
    
SEM AltConst
  -- copy rules

SEM AltCons AltConsts ConVars Bindings
  | Cons
    lhs.isNil = False
  | Nil
    lhs.isNil = True

SEM AltCons
  | Cons
    lhs.rhoSchemes = M.insert @hd.conNm @hd.rhoSchemes $ if @tl.isNil then M.empty else @tl.rhoSchemes
  | Nil
    lhs.rhoSchemes = panic "rhoSchemes"

SEM Const
  | String
    lhs.ty = Type_Data (mkHNm "UHC.Base.PackedString") [] []
    -- lhs.ty = Type_Data (mkHNm "UHC.Base.[]") (map (Annotation_Var . @lhs.toHsName) [@lhs.freshVar .. @lhs.freshVar + 3]) [Type_Data (mkHNm "Char") [] []]
    lhs.freshVar = @lhs.freshVar + 4
  | Integer
    lhs.ty = Type_Data (mkHNm "Integer") [] []


SEM AltConsts
  | Cons
    lhs.ty = @hd.ty
  | Nil
    lhs.ty = panic "ty"

SEM AltConst Const
  | Int
    lhs.ty = Type_Data (mkHNm "Int") [] []
  | Char
    lhs.ty = Type_Data (mkHNm "Char") [] []
  

SEM AltCons
  | Cons
    lhs.tyNm = @hd.tyNm
  | Nil
    lhs.tyNm = panic "tyNm"

SEM AltCon
  | Alt
    lhs.tyNm = @tyNm

SEM Bindings
  | Cons
    lhs.bindingNames = @hd.bindingName : (if @tl.isNil then [] else @tl.bindingNames) 
    lhs.envs = @hd.env : (if @tl.isNil then [] else @tl.envs) 
    lhs.etaTypes = @hd.etaTy : (if @tl.isNil then [] else @tl.etaTypes) 
    lhs.rhoSchemes = @hd.rhoSchemes : (if @tl.isNil then [] else @tl.rhoSchemes)
    lhs.constraints = @hd.constraints <> (if @tl.isNil then mempty else @tl.constraints)
  | Nil
    lhs.bindingNames = panic "bindingNames"
    lhs.constraints = panic "constraints"
    lhs.envs = panic "envs"
    lhs.etaTypes = panic "etaTypes"
    lhs.rhoSchemes = panic "rhoSchemes"

SEM Binding
  | Bind
    lhs.bindingName = @n
    loc.env = envDeleteList @e.env @lhs.allBindingNames
    loc.(rhosigma, fv) = envLookupFreshList (@e.freshVar, @lhs.toHsName) @e.env @lhs.allBindingNames
    lhs.freshVar = @loc.fv
    lhs.env = @loc.env
    lhs.etaTy = @e.etaTy
    lhs.rhoSchemes = @loc.rhosigma
    lhs.constraints = @e.constraints
  
%%]
