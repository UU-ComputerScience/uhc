%%[0 lhs2tex
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Hidde's counting Analysis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Implementation of Hidde's counting Analysis

%%[(8 counting) hs module {%{EH}Core.Trf.CountingAnalysis} import(Data.Maybe,Data.Set (Set),qualified Data.Set as Set,Data.Map (Map),qualified Data.Map as Map,qualified Data.Map as Data.Map)
%%]

%%[(8 counting) hs import(qualified Data.Set as S,qualified Data.Map as M)
%%]

%%[(8 counting) hs import({%{EH}LamInfo},{%{EH}Base.Common},{%{EH}Base.HsName.Builtin},{%{EH}Gam.DataGam},{%{EH}Gam.Base},{%{EH}Core},{%{EH}Ty})
%%]

%%[(8 counting) hs import({%{EH}CountingAnalysis.ConstraintGeneration},{%{EH}CountingAnalysis.ConstraintSolver},{%{EH}CountingAnalysis},{%{EH}CountingAnalysis.Pretty})
%%]

%%[(8 counting) hs import({%{EH}CountingAnalysis.ToCAModule}, {%{EH}CountingAnalysis.ToCModule})
%%]

%%[(8 counting) hs import(qualified {%{EH}CountingAnalysis.Substitution} as S, {%{EH}CountingAnalysis.AnnotateType})
%%]

%%[(8 counting) hs import(UHC.Util.Utils, UHC.Util.Pretty)
%%]

%%[(8 counting) hs import(Control.Monad (foldM), Control.Monad.State)
%%]

%%[(8 counting) hs import(Data.Monoid ((<>)))
%%]

%%[(8 counting) hs import(Data.List (zipWith7), Control.Arrow(first))
%%]

%%[(8 counting) hs import(Control.Applicative ((<|>)))
%%]

Debugging
%%[(8 counting) hs import(qualified Debug.Trace as T)
%%]

%%[(8 counting).WRAPPER ag import({CountingAnalysis/AbsSynExpr})
WRAPPER Expr
%%]

%%[(99 counting)
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) hs
traceShow :: Show a => a -> b -> b
traceShow x = id
-- traceShow x = seq (length $ show x)
-- traceShow = T.traceShow
-- traceShow x = T.traceShow (length $ show x)
-- traceShow x = T.traceShow (length $ show x, x)

traceShowId x = traceShow x x

traceShowTrip :: Show a => (String, a, String) -> b -> b
traceShowTrip (n, e, _) = seq (show (n, length $ show e, n))
-- traceShowTrip (n, e, _) = traceShow (n, length $ show e, n)
-- traceShowId :: Show a => a -> a
-- -- traceShowId x = T.traceShow (length $ show x) x
-- traceShowId = T.traceShowId

traceShowPair :: Show a => (String, a) -> b -> b
traceShowPair (n, e) = seq $ show (n, length $ show e, n)

cmodTrfAnalysis :: Bool -> DataGam -> LamMp -> CModule -> (CModule, LamMp)
cmodTrfAnalysis subeff d imps m = 
  -- seq (length $ show (pp e)) $
  -- T.traceShow (pp (c, conMap)) $
  T.traceShow (pp e) $
  T.traceShow e $
  traceShowPair ("subeff", subeff) $
  traceShowPair ("d", d) $
  traceShowPair ("imps", imps) $
  traceShowPair ("m", m) $
  traceShowPair ("im", im) $
  traceShowPair ("e", e) $
  traceShowPair ("extra", extra) $
  traceShowPair ("modName", modName) $
  traceShowPair ("ex", ex) $
  -- traceShowPair ("syn", syn) $
  traceShowPair ("c", c) $
  traceShowPair ("conMap", conMap) $
  traceShowPair ("e'", e') $
  traceShowPair ("bindingEnv", bindingEnv) $
  traceShowPair ("s", s) $
  traceShowPair ("finalBindEnv", finalBindEnv) $
  traceShowPair ("newLamMap", newLamMap) $
  traceShowPair ("finalLamMap", finalLamMap) $
  traceShowPair ("bi", bi) $
  traceShowPair ("test", test) $ 
  traceShowPair ("res", res) $
  seq "finished with everything" $
  T.traceShow (ppMap finalBindEnv) 
  res
  -- T.traceShow (ppMap bi) res
-- cmodTrfAnalysis subeff d imps m = T.traceShow (pp e) $ T.traceShow (ppMapAnnFree bi) $ test `seq` res
-- cmodTrfAnalysis subeff d imps m = traceShow (pp e, e, m) $ traceShow (ppMapAnnFree bi, ex) $ test `seq` res
-- cmodTrfAnalysis subeff d imps m = test `seq` res
-- cmodTrfAnalysis subeff d imps m = traceShow m (m,imps)
  where Module_Module e1 extra = toCAModule im m
        e = traceShowId $ scopeTest Nothing S.empty $ (\x -> traceShow (length $ show x) x) $ fixInstanceScopeFull $ (\x -> traceShow (length $ show x) x) $ scopeTest Nothing S.empty e1
        syn = wrap_Expr (sem_Expr e)
                Inh_Expr
                  { dataEnv_Inh_Expr = specialtrace d
                  , exports_Inh_Expr = ex
                  , importEnv_Inh_Expr = im
                  , subeffecting_Inh_Expr = if subeff then genSub else genEq
                  , toHsName_Inh_Expr = toHsName
                  , freshVar_Inh_Expr = 0
                  }
        im = toImports imps
        ex = S.map (fixHsName modName) $ toExports d m
        c = toConstraints $ constraints_Syn_Expr syn
        conMap = constraintsMap_Syn_Expr syn
        e' = annCopy_Syn_Expr syn
        bindingEnv = bindingEnv_Syn_Expr syn
        finalBindEnv = traceShow "subbind" $ S.substSolution bindingEnv s
        newLamMap = toLamMp finalBindEnv
        finalLamMap = lamMpMergeInto (\(LamInfo {laminfoCaType=a}) i -> i {laminfoCaType = a}) const newLamMap imps
        -- s = T.traceShow ("num constraints: ", countConstraints c conMap) $ error "finished generation" 
        s = T.traceShow ("num constraints: ", countConstraints c conMap) $ printTrace c conMap $ solveDef c 
          (emptySolveState {_freshVar = freshVar_Syn_Expr syn, _toHsName = toHsName}) conMap
        toHsName v = mkHNm $ show modName ++ ".CA@" ++ show v
        modName = moduleNm_CModule_Mod m
        bi = envFilterList finalBindEnv ex
        res = if M.size bi == S.size ex 
          then traceShowId $ (toCModule $ Module_Module (S.substSolution e' s) extra, finalLamMap) 
          else panic $ "not all exported symbols have a type: " ++ show (ppMap finalBindEnv)
        test = if m /= toCModule (Module_Module e1 extra) then panic "toCModule . toCAModule /= id"  else ()

specialtrace :: DataGam -> DataGam
specialtrace = id
-- specialtrace dg = traceShow ("DataGamGen:", dgl) dg
  -- where dgl = map f $ gamToAssocL dg
  --       f (n, dgi) = (n, dgiAnnVars dgi, Map.map (\x -> dtiFldAnnTyL x) $ dgiConstrTagMp dgi) 

traceRun :: Show a => String -> a -> a
-- traceRun m x = traceShow (m ++ ".start") $ seqForce x $ traceShow (m ++ ".end") x 
traceRun _ = id

seqForce :: Show a => a -> b -> b
-- seqForce x = seq (length $ show x)
seqForce _ = id


type DataEnv = DataGam

-- printTrace :: Constraints -> cm -> a -> a
printTrace c cm = if countConstraints c cm < 300 then printTraceShort (c,cm) else printTraceLong c

printTraceLong = flip const
-- printTraceLong = traceShow . vlist . map ppAnnFree . filterGen
-- printTraceLong [] = id
-- printTraceLong (x:xs) = traceShow x . printTraceLong xs

printTraceShort = flip const
-- printTraceShort = traceShow . pp

-- filterGen :: Constraints -> Constraints
-- filterGen [] = []
-- filterGen (Constraint_Gen t u d v0 d0 c e s : xs) = Constraint_Gen t u d v0 d0 (filterGen c) e s : filterGen xs
-- filterGen (_:xs) = filterGen xs

countConstraints :: Constraints -> Map a Constraints -> Int
countConstraints c cm = length c + sum (map length $ M.elems cm) 

toLamMp :: BindingEnv -> LamMp
toLamMp = M.map $ \x -> emptyLamInfo {laminfoCaType = x}

toImports :: LamMp -> Imports
toImports x = M.map getType $ M.filter (/= (RhoScheme_Rho (EtaScheme_Eta 
              (Scheme_Forall S.empty S.empty [] (Type_Error "Empty lamInfo")) $ Annotation_Val S.empty)
                 $ Annotation_Val S.empty)) $ M.map laminfoCaType x

toExports :: DataGam -> CModule -> Exports
toExports d (CModule_Mod _ exps _ _ _) = toExports' exps
  where toExports' [] = S.empty
        toExports' (CExport_Export n:xs) = S.insert n $ toExports' xs
        toExports' (CExport_ExportData n Nothing:xs) = Set.union cs $ toExports' xs
          where cs = Set.fromList $ Map.keys $ dgiConstrTagMp $ fromMaybe (panic "ex") $ n `dataGamLookup` d 
        toExports' (CExport_ExportData _ (Just cs):xs) = S.union (S.fromList cs) $ toExports' xs
        
annVars :: DataGamInfo -> HsNames
annVars = dgiAnnVars

tyVars :: DataGamInfo -> HsNames
tyVars = dgiTyVars

exTyVars :: DataGamInfo -> HsNames
exTyVars = dgiExTyVars

constrs :: DataGamInfo -> Map HsName Fields
constrs = Map.map dtiFldAnnTyL . dgiConstrTagMp

fromFields :: Fields -> [RhoType]
fromFields = map fromField

fromField :: Field -> RhoType
fromField (Field_Lazy t) = t
fromField (Field_Strict t) = t

seqUnion :: (Ord a, Show a, Show b) => Map a b -> Map a b -> Map a b
seqUnion m1 m2 = traceShow (m1,m2) $ M.union m1 m2

-- temp
class ScopeTest a where
  scopeTest :: Maybe HsName -> Set HsName -> a -> a

instance ScopeTest Expr where
  scopeTest b i e@(Expr_VarLocal v ex) = (if S.member v i then id else traceShow ("Out of scope", v, "in binding", b)) e
  scopeTest b i e@(Expr_VarImport v ex) = (if S.member v i then id else traceShow ("Out of scope", v, "in binding", b)) e
  scopeTest b i e@(Expr_Const c) = e
  scopeTest b i e@(Expr_Abs n e1 ex) = Expr_Abs n (scopeTest b (S.insert n i) e1) ex
  scopeTest b i e@(Expr_AppLocal e1 n ex) = (if S.member n i then id else traceShow ("Out of scope", n, "in binding", b)) $ Expr_AppLocal (scopeTest b i e1) n ex
  scopeTest b i e@(Expr_AppImport e1 n ex) = (if S.member n i then id else traceShow ("Out of scope", n, "in binding", b)) $ Expr_AppImport (scopeTest b i e1) n ex
  scopeTest b i e@(Expr_AppConst e1 c ex) = Expr_AppConst (scopeTest b i e1) c ex
  scopeTest b i e@(Expr_Let bs e1 ex) = Expr_Let (scopeTest b (S.union i $ definedVars bs) bs) (scopeTest b (S.union i $ definedVars bs) e1) ex
  scopeTest b i e@(Expr_LetBang x e1 e2 ex) = Expr_LetBang x (scopeTest (b <|> Just x) (S.insert x i) e1) (scopeTest b (S.insert x i) e2) ex
  scopeTest b i e@(Expr_Con tn cn flds ex) = Expr_Con tn cn (scopeTest b i flds) ex
  scopeTest b i e@(Expr_Tup flds ex) = Expr_Tup (scopeTest b i flds) ex
  scopeTest b i e@(Expr_CaseCon e1 alts ex) = Expr_CaseCon (scopeTest b i e1) (scopeTest b i alts) ex
  scopeTest b i e@(Expr_CaseTup e1 xs e2 ex) = Expr_CaseTup (scopeTest b i e1) xs (scopeTest b (S.union i $ S.fromList xs) e2) ex
  scopeTest b i e@(Expr_CaseConst e1 alts ex) = Expr_CaseConst (scopeTest b i e1) (scopeTest b i alts) ex
  scopeTest b i e@(Expr_FFI{}) = e 
  scopeTest b i e@(Expr_Ann a e1) = Expr_Ann a $ scopeTest b i e1
  scopeTest b i e@(Expr_AnnCore a e1) = Expr_AnnCore a $ scopeTest b i e1

instance ScopeTest a => ScopeTest [a] where
  scopeTest b = map . scopeTest b

instance ScopeTest ConVar where
  scopeTest b i e@(ConVar_VarLocal v) = (if S.member v i then id else traceShow ("Out of scope", v, "in binding", b)) e
  scopeTest b i e@(ConVar_VarImport v) = (if S.member v i then id else traceShow ("Out of scope", v, "in binding", b)) e
  scopeTest b i e@(ConVar_Const c) = e

instance ScopeTest Binding where
  scopeTest b i (Binding_Bind n e ex) = Binding_Bind n (scopeTest (b <|> Just n) (S.insert n i) e) ex

instance ScopeTest AltCon where
  scopeTest b i (AltCon_Alt yn cn xs e ex) = AltCon_Alt yn cn xs (scopeTest b (S.union i $ S.fromList xs) e) ex

instance ScopeTest AltConst where
  scopeTest b i (AltConst_Int c e ex) = AltConst_Int c (scopeTest b i e) ex
  scopeTest b i (AltConst_Char c e ex) = AltConst_Char c (scopeTest b i e) ex
  

force :: Show a => a -> a
force x = traceShow ("forced", length $ show x) x

fixInstanceScopeFull :: Expr -> Expr
fixInstanceScopeFull e = traceShow ("start fixScope", length bs) $ fromBindingList $ force (fixInstanceScope $ force bs, ex)
  where (bs,ex) = toBindingList e

toBindingList :: Expr -> ([(Bindings, CBindCateg)], Expr)
toBindingList (Expr_Let b e extra) = ((b,extra):bs,ex)
  where (bs, ex) = toBindingList e
toBindingList e = ([],e)

fromBindingList :: ([(Bindings, CBindCateg)], Expr) -> Expr
fromBindingList (bs, e) = foldr (\(b,extra) ex -> Expr_Let b ex extra) e bs


splitWhile2 :: (a -> a -> Bool) -> [a] -> ([a],[a])
splitWhile2 f ys@(x:xs@(y:_))
  | b && null fs = ([x,y], tail zs)
  | b = (x:fs,zs)
  | otherwise = ([],ys)
  where (fs,zs) = splitWhile2 f $ xs
        b = f x y
splitWhile2 f x = (x, []) -- sinleton or empty

fixInstanceScopeSingle :: [(Bindings, CBindCateg)] -> [(Bindings, CBindCateg)]
fixInstanceScopeSingle ys@(x:xs@(y:zss)) 
  | hasScopeError x y && hasScopeError y x = traceShow "merged" $ fixInstanceScopeSingle $ merge x y : zss
  | hasScopeError x y = traceShow ("swapped", length fs) $ reverse fs ++ fixInstanceScopeSingle zs
  | otherwise = x:fixInstanceScopeSingle xs
  where (fs,zs) = splitWhile2 hasScopeError ys
        merge (bs1,_) (bs2,_) = (bs1 ++ bs2, CBindCateg_Rec)
fixInstanceScopeSingle x = x

hasScopeError :: (Bindings, CBindCateg) -> (Bindings, CBindCateg) -> Bool
hasScopeError (bs1,c1) (bs2,c2) = not $ S.null $ S.intersection defVars scopeVars
  where defVars = definedVars bs2
        scopeVars = usedVars bs1

fixInstanceScope :: [(Bindings, CBindCateg)] -> [(Bindings, CBindCateg)]
fixInstanceScope xs = traceShow (length xs, length xs') $ if xs == xs' then xs' else fixInstanceScope ((\x -> traceShow (length $ show x) $ traceShow "ScopRec" x) xs')
  where xs' = fixInstanceScopeSingle xs

-- fixInstanceScopeSingle  :: [(Bindings, CBindCateg)] -> [(Bindings, CBindCateg)]
-- fixInstanceScopeSingle (x@(bs1,c1):y@(bs2,c2):z@(bs3, c3):xs)
--   | scopeError12 && scopeError23 = 
--     T.traceShow ("Swapped123", definedVars bs1, definedVars bs2, definedVars bs3) $ z:fixInstanceScopeSingle (y:x:xs)
--   | scopeError12 = 
--     T.traceShow ("Swapped12", definedVars bs1, definedVars bs2) $ y:fixInstanceScopeSingle (x:z:xs)
--   | scopeError23 = 
--     T.traceShow ("Swapped23", definedVars bs2, definedVars bs3) $ x:z:fixInstanceScopeSingle (y:xs)
--   | otherwise = 
--     x : fixInstanceScopeSingle (y:z:xs) 
--   where scopeError12 = not $ S.null $ S.intersection defVars2 scopeVars1
--         defVars2 = definedVars bs2
--         scopeVars1 = usedVars bs1
--         scopeError23 = not $ S.null $ S.intersection defVars3 scopeVars2
--         defVars3 = definedVars bs3
--         scopeVars2 = usedVars bs2
-- fixInstanceScopeSingle [x@(bs1,c1),y@(bs2,c2)]
--   | scopeError = 
--     T.traceShow ("Swapped", definedVars bs1, definedVars bs2) $ [y,x]
--   | otherwise = [x,y]
--   where scopeError = not $ S.null $ S.intersection defVars scopeVars
--         defVars = definedVars bs2
--         scopeVars = usedVars bs1
-- fixInstanceScopeSingle x = x
-- -- fixInstanceScope [] = []

-- fixInstanceScopeFull :: Expr -> Expr
-- fixInstanceScopeFull e = fromBindingList (force $ reverse $ force $ fromScopeMap $ force $ toScopeMap $ force bs, ex)
--   where (bs,ex) = toBindingList e

-- toScopeMap :: [(Bindings, CBindCateg)] -> Map (Set HsName) [(Bindings, CBindCateg)]
-- toScopeMap [] = M.empty
-- toScopeMap (x@(bs,_):xs) = T.traceShow (definedVars bs, usedVars bs S.\\ definedVars bs) $  M.insertWith (++) (usedVars bs S.\\ definedVars bs) [x] $ toScopeMap xs

-- fromScopeMap :: Map (Set HsName) [(Bindings, CBindCateg)] -> [(Bindings, CBindCateg)]
-- fromScopeMap m 
--   | M.null m = []
--   | otherwise = bs ++ (fromScopeMap $ force $ M.mapKeysWith (++) (\x -> x S.\\ definedVarsList bs) m')
--   where m' = M.delete S.empty m
--         bs = m M.! S.empty

definedVars :: Bindings -> Set HsName
definedVars [] = S.empty
definedVars (Binding_Bind n _ _:xs) = S.insert n $ definedVars xs

definedVarsList :: [(Bindings, CBindCateg)] -> Set HsName
definedVarsList = S.unions . map (definedVars . fst)

class ExtractExprVar a where
  usedVars :: a -> Set HsName
  usedVars _ = S.empty

instance ExtractExprVar a => ExtractExprVar [a] where
  usedVars [] = S.empty
  usedVars (x:xs) = S.union (usedVars x) $ usedVars xs

instance ExtractExprVar Binding where
  usedVars (Binding_Bind n e _) = usedVars e
  -- usedVars (Binding_Bind n e _) = traceShow ("UsedVars:",n, usedVars e) usedVars e

instance ExtractExprVar Expr where
  usedVars (Expr_VarLocal v _) = S.singleton v
  usedVars (Expr_VarImport v _) = S.singleton v 
  usedVars (Expr_Const _) = S.empty 
  usedVars (Expr_Abs n e _) = S.delete n $ usedVars e
  usedVars (Expr_AppLocal e n _) = S.insert n $ usedVars e 
  usedVars (Expr_AppImport e n _) = S.insert n $ usedVars e
  usedVars (Expr_AppConst e _ _) = usedVars e 
  usedVars (Expr_Let bs e _) = S.union (usedVars e) (usedVars bs) S.\\ definedVars bs
  -- usedVars (Expr_Let bs e _) = traceShow ("letVars:", usedVars e, definedVars bs) $ S.union (usedVars e) (usedVars bs) S.\\ definedVars bs
  usedVars (Expr_LetBang x e1 e2 _) = S.delete x $ S.union (usedVars e1) $ usedVars e2 
  usedVars (Expr_Con _ _ flds _) = usedVars flds
  usedVars (Expr_Tup flds _) = usedVars flds 
  usedVars (Expr_CaseCon e alts _) = S.union (usedVars e) $ usedVars alts
  usedVars (Expr_CaseTup e xs e1 _) = S.unions [usedVars e, usedVars e1] S.\\ S.fromList xs 
  usedVars (Expr_CaseConst e alts _) = S.union (usedVars e) $ usedVars alts
  usedVars (Expr_FFI{}) = S.empty 
  usedVars (Expr_Ann _ e) = usedVars e 
  usedVars (Expr_AnnCore _ e) = usedVars e

instance ExtractExprVar ConVar where
  usedVars (ConVar_VarLocal v) = S.singleton v
  usedVars (ConVar_VarImport v) = S.singleton v
  usedVars (ConVar_Const v) = S.empty

instance ExtractExprVar AltCon where
  usedVars (AltCon_Alt _ _ xs e _) = usedVars e S.\\ S.fromList xs

instance ExtractExprVar AltConst where
  usedVars (AltConst_Int _ e _) = usedVars e
  usedVars (AltConst_Char _ e _) = usedVars e

-- TODO ask atze as this is basically hope it works stuff
fixHsName :: HsName -> HsName -> HsName
fixHsName x hnm = mkHNm $ show x ++ "." ++ show hnm

traceShow2 :: (Show a, Show b) => a -> b -> b
traceShow2 x y = y
-- traceShow2 x y = traceShow ("***********",x,y,"$$$$$$$$$$$$$$") y

traceShow1 :: (Show a, Show b) => a -> b -> b
traceShow1 x y = y
-- traceShow1 x y = traceShow ("*********",x,y,"#########") y

%%]

%%[(8 counting) hs export(cmodTrfAnalysisCounting)
cmodTrfAnalysisCounting :: DataGam -> LamMp -> CModule -> (CModule, LamMp)
cmodTrfAnalysisCounting = cmodTrfAnalysis True
%%]

%%[(8 counting) hs export(cmodTrfAnalysisCountingUnique)
cmodTrfAnalysisCountingUnique :: DataGam -> LamMp -> CModule -> (CModule, LamMp)
cmodTrfAnalysisCountingUnique = cmodTrfAnalysis False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Global info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag
ATTR * [ toHsName: {Var -> HsName} importEnv: {Imports} exports: {Exports} dataEnv: {DataEnv} subeffecting: {Annotation -> Annotation -> GatherConstraints} | freshVar: {Var} | annCopy: SELF ]
ATTR * [ | | bindingEnv USE {M.union} {M.empty}: {BindingEnv} constraintsMap USE {seqUnion} {M.empty}: {Map Var Constraints}]
ATTR * [ | | copy: SELF]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 counting) ag
ATTR Expr AltCon AltConst AltCons AltConsts Binding [ | | env: {Env} etaTy: {EtaType} constraints: {GatherConstraints}]
ATTR ConVars [ | | env: {Env} rhoTypes: {[RhoType]} constraints: {GatherConstraints} ] -- doen
ATTR ConVar [ | | env: {Env} rhoTy: {RhoType} constraints: {GatherConstraints}] -- done
ATTR Const AltConsts AltConst [ | | ty: {Type}] -- done
ATTR AltCons AltCon [ | | tyNm: {HsName}] -- done
ATTR AltCons [ | | rhoSchemes: {Map HsName [RhoScheme]}] -- done
ATTR AltCon [ | | conNm: {HsName} rhoSchemes: {[RhoScheme]}] -- done
ATTR Bindings [ | | rhoSchemes: {[[RhoScheme]]}] -- done
ATTR Binding [ | | rhoSchemes: {[RhoScheme]}] -- done
ATTR Bindings [ | | constraints: {GatherConstraints} envs: {[Env]} bindingNames: {HsNames} etaTypes: {[EtaType]}]
ATTR ConVars AltCons AltConsts Bindings [ | | isNil: {Bool}] --done
ATTR Binding [ | | bindingName: {HsName} ]
ATTR Binding Bindings [ allBindingNames: {HsNames} | | ]
ATTR Expr [ | | maybeDemand: {Maybe Annotation}]

SEM Expr
  | VarLocal
    lhs.maybeDemand = Just @loc.delta
  | * - VarLocal Ann AnnCore
    lhs.maybeDemand = Nothing

SEM Expr
  | VarLocal
    loc.tau = Type_Var $ @lhs.toHsName @lhs.freshVar
    loc.sigma = Scheme_Var $ @lhs.toHsName $ @lhs.freshVar + 1
    loc.nu = Annotation_Var $ @lhs.toHsName $ @lhs.freshVar + 2
    loc.delta = Annotation_Var $ @lhs.toHsName $ @lhs.freshVar + 3
    loc.etaTy = EtaType_Eta @loc.tau @loc.nu
    lhs.freshVar = @lhs.freshVar + 4
    -- lhs.env = M.singleton @v $ RhoScheme_Rho (EtaScheme_Eta @loc.sigma @loc.nu) @loc.delta -- annOne
    lhs.env = M.singleton @v $ RhoScheme_Rho (EtaScheme_Eta @loc.sigma @loc.nu) annOne
    lhs.etaTy = @loc.etaTy
    lhs.constraints = singleGC $ Constraint_Inst @v @loc.sigma @loc.tau
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_VarLocal @v @extra
  | VarImport
    loc.tau = Type_Var $ @lhs.toHsName @lhs.freshVar
    loc.sigma = @lhs.importEnv M.! @v
    loc.etaTy = EtaType_Eta @loc.tau annTop
    lhs.freshVar = @lhs.freshVar + 1
    lhs.env = M.empty
    lhs.etaTy = @loc.etaTy
    lhs.constraints = singleGC $ Constraint_Inst @v @loc.sigma @loc.tau
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_VarImport @v @extra
  | Const
    loc.tau = @c.ty
    loc.nu = Annotation_Var $ @lhs.toHsName @lhs.freshVar
    loc.etaTy = EtaType_Eta @loc.tau @loc.nu
    lhs.freshVar = @lhs.freshVar + 1
    lhs.env = M.empty
    lhs.etaTy = @loc.etaTy
    lhs.constraints = mempty
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_Const @c.annCopy
  | Abs
    loc.env1 = M.delete @bind @body.env
    loc.(rho, fv) = envLookupFresh (@body.freshVar, @lhs.toHsName) @body.env @bind
    loc.sigma = getType @loc.rho
    loc.nu = getUsage @loc.rho
    loc.delta = getDemand @loc.rho
    loc.eta = @body.etaTy
    loc.c1 = @body.constraints 
    loc.nu2 = Annotation_Var $ @lhs.toHsName @loc.fv
    loc.tau = Type_Var $ @lhs.toHsName $ @loc.fv + 1
    loc.((env2, c2), fv2) = computeTimes (@loc.fv + 2, @lhs.toHsName) @loc.nu2 @loc.env1
    loc.etaTy = EtaType_Eta (Type_Func (RhoType_Rho (EtaType_Eta @loc.tau @loc.nu) @loc.delta) @loc.eta) @loc.nu2
    lhs.freshVar = @loc.fv2
    lhs.env = @loc.env2
    lhs.etaTy = @loc.etaTy
    lhs.constraints = @loc.c1 <> @loc.c2 <> genEq @loc.sigma (Scheme_Forall mempty mempty mempty @loc.tau)
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_Abs @bind @body.annCopy @extra
    +bindingEnv = M.insert @bind @loc.rho
  | AppLocal
    loc.env1 = @func.env
    loc.eta' = @func.etaTy
    loc.c1 = @func.constraints
    loc.delta2 = Annotation_Var $ @lhs.toHsName @func.freshVar
    loc.sigmax = Scheme_Var $ @lhs.toHsName $ @func.freshVar + 1
    loc.nux = Annotation_Var $ @lhs.toHsName $ @func.freshVar + 2
    loc.taux = Type_Var $ @lhs.toHsName $ @func.freshVar + 3
    loc.eta4 = EtaScheme_Eta @loc.sigmax @loc.nux
    loc.eta2' = EtaType_Eta @loc.taux @loc.nux
    loc.c2 = singleGC $ Constraint_Inst @arg @loc.sigmax @loc.taux
    loc.eta3 = EtaType_Eta (Type_Var $ @lhs.toHsName $ @func.freshVar + 4) $ Annotation_Var $ @lhs.toHsName $ @func.freshVar + 5
    loc.((eta2, c2'), fv) = sub (@func.freshVar + 6, @lhs.toHsName) @lhs.subeffecting @loc.eta2'
    loc.((etas', c1'), fv2) = sub (@loc.fv, @lhs.toHsName) genSub @loc.eta'
    loc.tau1 = getType @loc.etas'
    loc.nu1 = getUsage @loc.etas'
    loc.((env2, c3), fv3) = computePlus (@loc.fv2, @lhs.toHsName) @loc.env1 $ M.singleton @arg $ RhoScheme_Rho @loc.eta4 @loc.delta2
    loc.etaTy = @loc.eta3
    lhs.freshVar = @loc.fv3
    lhs.env = @loc.env2
    lhs.etaTy = @loc.etaTy
    lhs.constraints = mconcat [@loc.c1, @loc.c1', @loc.c2, @loc.c2', @loc.c3, 
                        genEq @loc.tau1 $ Type_Func (RhoType_Rho @loc.eta2 @loc.delta2) @loc.eta3, 
                        genEq @loc.nu1 annOne]
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_AppLocal @func.annCopy @arg @extra
  | AppImport
    loc.env = @func.env
    loc.eta' = @func.etaTy
    loc.c1 = @func.constraints
    loc.delta2 = Annotation_Var $ @lhs.toHsName @func.freshVar
    loc.sigmax = @lhs.importEnv M.! @arg
    loc.taux = Type_Var $ @lhs.toHsName $ @func.freshVar + 2
    loc.eta2' = EtaType_Eta @loc.taux annTop
    loc.c2 = singleGC $ Constraint_Inst @arg @loc.sigmax @loc.taux
    loc.eta3 = EtaType_Eta (Type_Var $ @lhs.toHsName $ @func.freshVar + 3) $ Annotation_Var $ @lhs.toHsName $ @func.freshVar + 4
    loc.((eta2, c2'), fv) = sub (@func.freshVar + 5, @lhs.toHsName) @lhs.subeffecting @loc.eta2'
    loc.((etas', c1'), fv2) = sub (@loc.fv, @lhs.toHsName) genSub @loc.eta'
    loc.tau1 = getType @loc.etas'
    loc.nu1 = getUsage @loc.etas'
    loc.etaTy = @loc.eta3
    lhs.freshVar = @loc.fv2
    lhs.env = @loc.env
    lhs.etaTy = @loc.etaTy
    lhs.constraints = mconcat [@loc.c1, @loc.c1', @loc.c2, @loc.c2', 
                        genEq @loc.tau1 $ Type_Func (RhoType_Rho @loc.eta2 @loc.delta2) @loc.eta3, 
                        genEq @loc.nu1 annOne]
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_AppImport @func.annCopy @arg @extra
  | AppConst
    loc.env = @func.env
    loc.eta' = @func.etaTy
    loc.c1 = @func.constraints
    loc.delta2 = Annotation_Var $ @lhs.toHsName @func.freshVar
    loc.eta2' = EtaType_Eta @arg.ty $ Annotation_Var $ @lhs.toHsName $ @func.freshVar + 1
    loc.eta3 = EtaType_Eta (Type_Var $ @lhs.toHsName $ @func.freshVar + 2) $ Annotation_Var $ @lhs.toHsName $ @func.freshVar + 3
    loc.((eta2, c2), fv) = sub (@func.freshVar + 4, @lhs.toHsName) @lhs.subeffecting @loc.eta2'
    loc.((etas', c1'), fv2) = sub (@loc.fv, @lhs.toHsName) genSub @loc.eta'
    loc.tau1 = getType @loc.etas'
    loc.nu1 = getUsage @loc.etas'
    loc.etaTy = @loc.eta3
    lhs.freshVar = @loc.fv2
    lhs.env = @loc.env
    lhs.etaTy = @loc.etaTy
    lhs.constraints = mconcat [@loc.c1, @loc.c1', @loc.c2, 
                        genEq @loc.tau1 $ Type_Func (RhoType_Rho @loc.eta2 @loc.delta2) @loc.eta3, 
                        genEq @loc.nu1 annOne]
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_AppConst @func.annCopy @arg.annCopy @extra
  | Let
    binds.allBindingNames = @binds.bindingNames
    loc.env0 = envDeleteList @e.env @binds.bindingNames
    loc.(rho0i, fvs) = envLookupFreshList (@e.freshVar, @lhs.toHsName) @e.env @binds.bindingNames
    loc.sigmai = map getType @loc.rho0i
    loc.nui = map (\(e, r, f) -> if e then Annotation_Var $ @lhs.toHsName f else getUsage r) $ zip3 @loc.boolExports @loc.rho0i [@loc.fvs + length @loc.rho0i ..]
    loc.boolExports = map (`S.member` @lhs.exports) @binds.bindingNames
    loc.delta0i = map (\(e, r, f) -> if e then Annotation_Var $ @lhs.toHsName f else getDemand r) $ zip3 @loc.boolExports @loc.rho0i [@loc.fvs ..]
    loc.fv = @loc.fvs + 2 * length @loc.rho0i
    loc.deltai = map (Annotation_Var . @lhs.toHsName) [@loc.fv .. @loc.fv + length @loc.delta0i - 1]
    loc.fv0 = @loc.fv + length @loc.delta0i
    loc.eta = @e.etaTy
    loc.c0 = @e.constraints
    loc.tauij = map (\x -> map (Type_Var . @lhs.toHsName) [@loc.fv0 + x * length @binds.bindingNames .. @loc.fv0 + (x + 1) * length @binds.bindingNames - 1]) [0 .. length @binds.bindingNames - 1]
    loc.fv1 = @loc.fv0 + length @binds.bindingNames * length @binds.bindingNames
    loc.sigmaij = map (map $ Scheme_Forall mempty mempty mempty) @loc.tauij
    loc.envi = @binds.envs
    loc.sigmaij' = map (map getType) @binds.rhoSchemes
    loc.nuij = map (map getUsage) @binds.rhoSchemes
    loc.deltaij = map (map getDemand) @binds.rhoSchemes
    loc.taui = map getType @binds.etaTypes
    loc.nuxi = map getUsage @binds.etaTypes
    loc.c0'= genEq @loc.nui @loc.nuxi
    loc.c1i = @binds.constraints
    loc.c1' = genEq @loc.sigmaij @loc.sigmaij'
    loc.c1 = @loc.c1' <> @loc.c1i
    
    loc.((envi', c2i), fv2) = computeCondList (@loc.fv1 + length @binds.bindingNames ^ 2, @lhs.toHsName) @loc.deltai @loc.envi
    loc.((env', c2), fv3) = bigPlus (@loc.fv2, @lhs.toHsName) @loc.envi'
    loc.((env, c2'), fv4) = computePlus (@loc.fv3, @lhs.toHsName) @loc.env0 @loc.env'
    
    loc.((deltaij', c3ij), fv5) = computeCondMatrix (@loc.fv4, @lhs.toHsName) @loc.deltai @loc.deltaij
    loc.((deltai', c3i), fv6) = bigPlusMatrix (@loc.fv5, @lhs.toHsName) @loc.deltaij'
    loc.((deltai'', c3i'), fv7) = computePlus (@loc.fv6, @lhs.toHsName) @loc.deltai @loc.deltai'
    loc.c3' = genEq @loc.deltai @loc.deltai''
    loc.c3 = @loc.c3' <> @loc.c3ij <> @loc.c3i <> @loc.c3i'
    
    loc.((nuij', c4ij), fv8) = computeCondMatrix (@loc.fv7, @lhs.toHsName) @loc.deltai @loc.nuij
    loc.((nui', c4i), fv9) = bigPlusMatrix (@loc.fv8, @lhs.toHsName) @loc.nuij'
    loc.((nu0i, c4i'), fv10) = computePlus (@loc.fv9, @lhs.toHsName) @loc.nui @loc.nui'
    loc.c4' = mempty
    -- loc.c4' = genEq @loc.nu0i @loc.nui
    loc.c4 = @loc.c4' <> @loc.c4ij <> @loc.c4i <> @loc.c4i'
    
    loc.((tauij', c5ij), fv11) = computeCondMatrix (@loc.fv10, @lhs.toHsName) @loc.deltai @loc.tauij
    loc.((taui', c5i), fv12) = bigPlusMatrix (@loc.fv11, @lhs.toHsName) @loc.tauij'
    loc.c5' = genEq @loc.taui' @loc.taui
    loc.c5 = @loc.c5' <> @loc.c5ij <> @loc.c5i
    
    loc.cGen = @loc.c1 <> @loc.c3 <> @loc.c4 <> @loc.c5
    loc.c6 = mconcat $ zipWith7 (\nm t n d n0 d0 s -> singleGC $ Constraint_Gen nm t n d n0 d0 @loc.fv12 @loc.env s) @binds.bindingNames @loc.taui @loc.nui @loc.deltai @loc.nu0i @loc.delta0i @loc.sigmai
    loc.c7i = zipWith3 (\x n d0 -> if x `S.member` @lhs.exports then genEq n annTop <> genEq d0 annTop else mempty) @binds.bindingNames @loc.nu0i @loc.deltai
    
    loc.etaTy = @loc.eta
    lhs.freshVar = @loc.fv12 + 1
    lhs.env = @loc.env
    lhs.etaTy = @loc.etaTy
    lhs.constraints = @loc.c6 <> @loc.c0 <> @loc.c0' <> @loc.c2 <> @loc.c2' <> @loc.c2i <> mconcat @loc.c7i
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_Let @binds.annCopy @e.annCopy @extra
    +bindingEnv = M.union (M.fromList $ zip @binds.bindingNames @loc.rho0i)
    +constraintsMap = M.insert @loc.fv12 $ toConstraints @loc.cGen
  | LetBang
    loc.env0 = M.delete @x @e2.env
    loc.(rho0, fv) = envLookupFresh (@e2.freshVar, @lhs.toHsName) @e2.env @x
    loc.sigma0 = getType @loc.rho0
    loc.nu = getUsage @loc.rho0
    loc.delta = getDemand @loc.rho0
    loc.eta = @e2.etaTy
    loc.c0 = @e2.constraints
    loc.env1 = M.delete @x @e1.env
    loc.(rho1, fv2) = envLookupFresh (@loc.fv, @lhs.toHsName) @e1.env @x
    loc.sigma' = getType @loc.rho1
    loc.nu1 = getUsage @loc.rho1
    loc.delta1 = getDemand @loc.rho1
    loc.tau = getType @e1.etaTy
    loc.nu2 = getUsage @e1.etaTy
    loc.c1 = @e1.constraints
    loc.c1' = genEq @loc.sigma' (Scheme_Forall mempty mempty mempty @loc.tau)-- <> genSub annZero @loc.nu2
    loc.((env, c2), fv3) = computePlus (@loc.fv2, @lhs.toHsName) @loc.env0 @loc.env1
    loc.((delta0, c3), fv4) = computePlus (@loc.fv3, @lhs.toHsName) annOne @loc.delta
    loc.((delta', c4), fv5) = computePlus (@loc.fv4, @lhs.toHsName) @loc.delta0 @loc.delta1
    -- loc.c4' = mempty 
    loc.c4' = genEq @loc.delta0 @loc.delta'
    -- loc.c4'' = mempty
    loc.c4'' = case @e1.maybeDemand of
                Nothing -> mempty
                Just d -> genEq d @loc.delta'
    loc.((nu', c5), fv6) = computePlus (@loc.fv5, @lhs.toHsName) @loc.nu @loc.nu1
    loc.c5' = mempty
    -- loc.c5' = genEq @loc.nu @loc.nu'
    loc.cGen = @loc.c1 <> @loc.c1' <> @loc.c3 <> @loc.c4 <> @loc.c4' <> @loc.c4'' <> @loc.c5 <> @loc.c5'
    loc.c6 = traceShow ("letBang:", @x, @loc.sigma0) $ singleGC $ Constraint_Gen @x @loc.tau @loc.nu @loc.delta0 @loc.nu' @loc.delta' @loc.fv6 @loc.env @loc.sigma0
    loc.etaTy = @loc.eta
    lhs.freshVar = @loc.fv6 + 1
    lhs.env = @loc.env
    lhs.etaTy = @loc.etaTy
    lhs.constraints = @loc.c6 <> @loc.c0 <> @loc.c2
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_LetBang @x @e1.annCopy @e2.annCopy @extra
    +bindingEnv = M.insert @x (RhoScheme_Rho (EtaScheme_Eta @loc.sigma0 @loc.nu') @loc.delta')
    +constraintsMap = M.insert @loc.fv6 $ toConstraints @loc.cGen
  | Con
    loc.env = @flds.env
    loc.rho' = @flds.rhoTypes
    loc.c1 = @flds.constraints
    loc.data = fromMaybe (error "con") $ @tyNm `dataGamLookup` @lhs.dataEnv
    loc.ul = annVars @loc.data
    loc.ak = tyVars @loc.data
    loc.exTy = exTyVars @loc.data
    loc.exTySol = M.fromList $ zip @loc.exTy $ map (Type_Var . @lhs.toHsName) [@flds.freshVar + length @loc.ul + length @loc.ak + 1  .. @flds.freshVar + length @loc.ul + length @loc.ak + length @loc.exTy]
    loc.rhoj = fromFields $ constrs @loc.data M.! @conNm
    loc.phil = map (Annotation_Var . @lhs.toHsName) [@flds.freshVar .. @flds.freshVar + length @loc.ul - 1]
    loc.tauk = map (Type_Var . @lhs.toHsName) [@flds.freshVar + length @loc.ul  .. @flds.freshVar + length @loc.ul + length @loc.ak - 1]
    loc.sol = Solution (M.fromList $ zip @loc.ul @loc.phil) (M.union (M.fromList $ zip @loc.ak @loc.tauk) @loc.exTySol) M.empty
    loc.rhoj' = S.substSolution @loc.rhoj @loc.sol
    loc.c2 = genEq @loc.rhoj' @loc.rho'
    loc.nu = Annotation_Var $ @lhs.toHsName $ @flds.freshVar + length @loc.ul + length @loc.ak
    loc.etaTy = EtaType_Eta (Type_Data @tyNm @loc.phil @loc.tauk) @loc.nu
    lhs.freshVar = @flds.freshVar + length @loc.ul + length @loc.ak + length @loc.exTy + 1
    lhs.env = @loc.env
    lhs.etaTy = @loc.etaTy
    lhs.constraints = @loc.c1 <> @loc.c2
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_Con @tyNm @conNm @flds.annCopy @extra
  | Tup
    -- copy rules
    loc.nu = Annotation_Var $ @lhs.toHsName @flds.freshVar
    loc.etaTy = EtaType_Eta (Type_Tup @flds.rhoTypes) @loc.nu
    lhs.freshVar = @flds.freshVar + 1
    lhs.etaTy = @loc.etaTy
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_Tup @flds.annCopy @extra
  | CaseCon
    loc.data = fromMaybe (error "CaseCon") $ @alts.tyNm `dataGamLookup` @lhs.dataEnv
    loc.ul = annVars @loc.data
    loc.ak = tyVars @loc.data
    loc.exTy = exTyVars @loc.data
    loc.exTySol = M.fromList $ zip @loc.exTy $ map (Type_Var . @lhs.toHsName) [@loc.fv  .. @loc.fv + length @loc.exTy - 1]
    loc.rhoijtau = map (fromFields . snd) $ M.toList $ constrs @loc.data
    loc.phil = map (Annotation_Var . @lhs.toHsName) [@alts.freshVar .. @alts.freshVar + length @loc.ul - 1]
    loc.tauk = map (Type_Var . @lhs.toHsName) [@alts.freshVar + length @loc.ul  .. @alts.freshVar + length @loc.ul + length @loc.ak - 1]
    loc.sol = Solution (M.fromList $ zip @loc.ul @loc.phil) (M.union (M.fromList $ zip @loc.ak @loc.tauk) @loc.exTySol) M.empty
    loc.rhoijtau' = S.substSolution @loc.rhoijtau @loc.sol
    loc.rhoijsigma = map (map $ fromGRho . fmap (Scheme_Forall mempty mempty mempty) . toGRho) @loc.rhoijtau'
    loc.env0 = @e.env
    loc.tau0 = getType @e.etaTy
    loc.nu0 = getUsage @e.etaTy
    loc.c1 = @e.constraints
    loc.c1' = genEq @loc.tau0 (Type_Data @alts.tyNm @loc.phil @loc.tauk) <> genSub annOne @loc.nu0
    loc.env' = @alts.env
    loc.rhoij' = M.elems @alts.rhoSchemes
    loc.eta1 = @alts.etaTy
    loc.c2 = @alts.constraints
    loc.c2' = genEq @loc.rhoijsigma @loc.rhoij'
    loc.((env, c3'), fv) = computePlus (@alts.freshVar + length @loc.ul + length @loc.ak, @lhs.toHsName) @loc.env0 @loc.env'
    loc.etaTy = @loc.eta1
    lhs.freshVar = @loc.fv + length @loc.exTy
    lhs.env = @loc.env
    lhs.etaTy = @loc.etaTy
    lhs.constraints = @loc.c1 <> @loc.c1' <> @loc.c2 <> @loc.c2' <> @loc.c3'
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_CaseCon @e.annCopy @alts.annCopy @extra
  | CaseTup
    loc.rhoitau = map (\n -> RhoType_Rho (EtaType_Eta (Type_Var $ @lhs.toHsName $ @e1.freshVar + 3 * n) $ Annotation_Var $ @lhs.toHsName $ @e1.freshVar + 1 + 3 * n) $ Annotation_Var $ @lhs.toHsName $ @e1.freshVar + 2 + 3 * n) [0 .. length @xs - 1]
    loc.rhoisigma = map (fromGRho . fmap (Scheme_Forall mempty mempty mempty) . toGRho) @loc.rhoitau
    loc.env0 = @e.env
    loc.tau0 = getType @e.etaTy
    loc.nu0 = getUsage @e.etaTy
    loc.c1 = @e.constraints
    loc.c1' = genEq @loc.tau0 (Type_Tup @loc.rhoitau) <> genSub annOne @loc.nu0
    loc.env1 = envDeleteList @e1.env @xs
    loc.(rhoi', fv) = envLookupFreshList (@e1.freshVar + 3 * length @xs, @lhs.toHsName) @e1.env @xs
    loc.eta = @e1.etaTy
    loc.c2 = @e1.constraints
    loc.c2' = genEq @loc.rhoisigma @loc.rhoi'
    loc.((env, c3), fv2) = computePlus (@loc.fv, @lhs.toHsName) @loc.env0 @loc.env1
    loc.etaTy = @loc.eta
    lhs.freshVar = @loc.fv2
    lhs.env = @loc.env
    lhs.etaTy = @loc.etaTy
    lhs.constraints = @loc.c1 <> @loc.c1' <> @loc.c2 <> @loc.c2' <> @loc.c3
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_CaseTup @e.annCopy @xs @e1.annCopy @extra
    +bindingEnv = M.union (M.fromList $ zip @xs @loc.rhoisigma)
  | CaseConst
    loc.tau = @alts.ty
    loc.env0 = @e.env
    loc.tau0 = getType @e.etaTy
    loc.nu0 = getUsage @e.etaTy
    loc.c1 = @e.constraints
    loc.c1' = genEq @loc.tau0 @loc.tau <> genSub annOne @loc.nu0
    loc.env' = @alts.env
    loc.eta1 = @alts.etaTy
    loc.c2 = @alts.constraints
    loc.((env, c3'), fv) = computePlus (@alts.freshVar, @lhs.toHsName) @loc.env0 @loc.env'
    loc.etaTy = @loc.eta1
    lhs.freshVar = @loc.fv
    lhs.env = @loc.env
    lhs.etaTy = @loc.etaTy
    lhs.constraints = @loc.c1 <> @loc.c1' <> @loc.c2 <> @loc.c3'
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_CaseConst @e.annCopy @alts.annCopy @extra
  | FFI
    loc.tau = Type_Var $ @lhs.toHsName @lhs.freshVar
    loc.sigma = annotate @lhs.dataEnv @ty
    loc.(_,_,ent) = @extra
    loc.etaTy = EtaType_Eta @loc.tau annTop
    lhs.freshVar = @lhs.freshVar + 1
    lhs.env = M.empty
    lhs.etaTy = @loc.etaTy
    lhs.constraints = singleGC $ Constraint_Inst (mkHNm $ "FFI: " ++ show @loc.ent) @loc.sigma @loc.tau
    loc.annCopy = Expr_Ann @loc.etaTy $ Expr_FFI @ty @extra
  | Error
    lhs.env = panic "Error expression" 
    lhs.constraints = panic "Error expression" 
    lhs.etaTy = panic "Error expression" 

SEM ConVars
  | Cons
    loc.((env, c'), fv) = if @tl.isNil then ((@hd.env, mempty), @tl.freshVar) else computePlus (@tl.freshVar, @lhs.toHsName) @hd.env @tl.env
    loc.c = @hd.constraints <> if @tl.isNil then mempty else @tl.constraints
    lhs.freshVar = @loc.fv
    lhs.env = @loc.env
    lhs.rhoTypes = @hd.rhoTy : if @tl.isNil then [] else @tl.rhoTypes
    lhs.constraints = @loc.c' <> @loc.c
  | Nil
    lhs.env = M.empty
    lhs.rhoTypes = []
    lhs.constraints = mempty
    
SEM ConVar
  | VarLocal
    loc.tau = Type_Var $ @lhs.toHsName @lhs.freshVar
    loc.sigma = Scheme_Var $ @lhs.toHsName $ @lhs.freshVar + 1
    loc.nu = Annotation_Var $ @lhs.toHsName $ @lhs.freshVar + 2
    loc.delta2 = Annotation_Var $ @lhs.toHsName $ @lhs.freshVar + 3
    lhs.freshVar = @lhs.freshVar + 4
    lhs.env = M.singleton @v $ RhoScheme_Rho (EtaScheme_Eta @loc.sigma @loc.nu) @loc.delta2 -- annOne
    lhs.rhoTy = RhoType_Rho (EtaType_Eta @loc.tau @loc.nu) @loc.delta2
    lhs.constraints = singleGC $ Constraint_Inst @v @loc.sigma @loc.tau
  | VarImport
    loc.tau = Type_Var $ @lhs.toHsName @lhs.freshVar
    loc.sigma = @lhs.importEnv M.! @v
    loc.delta2 = Annotation_Var $ @lhs.toHsName $ @lhs.freshVar + 1
    lhs.freshVar = @lhs.freshVar + 2
    lhs.env = M.empty
    lhs.rhoTy = RhoType_Rho (EtaType_Eta @loc.tau annTop) @loc.delta2
    lhs.constraints = singleGC $ Constraint_Inst @v @loc.sigma @loc.tau
  | Const
    loc.tau = @c.ty
    loc.nu = Annotation_Var $ @lhs.toHsName @lhs.freshVar
    loc.delta2 = Annotation_Var $ @lhs.toHsName $ @lhs.freshVar + 1
    lhs.freshVar = @lhs.freshVar + 2
    lhs.env = M.empty
    lhs.rhoTy = RhoType_Rho (EtaType_Eta @loc.tau @loc.nu) @loc.delta2
    lhs.constraints = mempty

SEM AltCons AltConsts
  | Cons
    loc.((env, c1), fv) = if @tl.isNil then ((@hd.env, mempty), @hd.freshVar) 
                            else computeUnion (@tl.freshVar, @lhs.toHsName) @hd.env @tl.env
    loc.c2 = if @tl.isNil then mempty else genEq @hd.etaTy @tl.etaTy
    lhs.freshVar = @loc.fv
    lhs.env = @loc.env
    lhs.etaTy = @hd.etaTy
    lhs.constraints = @loc.c1 <> @loc.c2 <> @hd.constraints <> (if @tl.isNil then mempty else @tl.constraints)
  | Nil
    lhs.env = panic "env"
    lhs.etaTy = panic "etaTy"
    lhs.constraints = panic "constraints"

SEM AltCon
  | Alt
    loc.env = envDeleteList @e.env @xs
    loc.(rhosigma, fv) = envLookupFreshList (@e.freshVar, @lhs.toHsName) @e.env @xs
    lhs.freshVar = @loc.fv
    lhs.env = @loc.env
    lhs.etaTy = @e.etaTy
    lhs.constraints = @e.constraints
    lhs.rhoSchemes = @loc.rhosigma
    lhs.conNm = @conNm
    +bindingEnv = M.union (M.fromList $ zip @xs @loc.rhosigma)
    
SEM AltConst
  -- copy rules

SEM AltCons AltConsts ConVars Bindings
  | Cons
    lhs.isNil = False
  | Nil
    lhs.isNil = True

SEM AltCons
  | Cons
    lhs.rhoSchemes = M.insert @hd.conNm @hd.rhoSchemes $ if @tl.isNil then M.empty else @tl.rhoSchemes
  | Nil
    lhs.rhoSchemes = panic "rhoSchemes"

SEM Const
  | String
    lhs.ty = Type_Data hsnPackedString [] []
    -- lhs.ty = Type_Data (mkHNm "UHC.Base1.[]") (map (Annotation_Var . @lhs.toHsName) [@lhs.freshVar .. @lhs.freshVar + 3]) [Type_Data (mkHNm "Char") [] []]
    lhs.freshVar = @lhs.freshVar + 4
  | Integer
    lhs.ty = Type_Data hsnInteger [] []


SEM AltConsts
  | Cons
    lhs.ty = @hd.ty
  | Nil
    lhs.ty = panic "ty"

SEM AltConst Const
  | Int
    lhs.ty = Type_Data (mkHNm "Int") [] []
  | Char
    lhs.ty = Type_Data (mkHNm "Char") [] []
  

SEM AltCons
  | Cons
    lhs.tyNm = @hd.tyNm
  | Nil
    lhs.tyNm = panic "tyNm"

SEM AltCon
  | Alt
    lhs.tyNm = @tyNm

SEM Bindings
  | Cons
    lhs.bindingNames = @hd.bindingName : (if @tl.isNil then [] else @tl.bindingNames) 
    lhs.envs = @hd.env : (if @tl.isNil then [] else @tl.envs) 
    lhs.etaTypes = @hd.etaTy : (if @tl.isNil then [] else @tl.etaTypes) 
    lhs.rhoSchemes = @hd.rhoSchemes : (if @tl.isNil then [] else @tl.rhoSchemes)
    lhs.constraints = @hd.constraints <> (if @tl.isNil then mempty else @tl.constraints)
  | Nil
    lhs.bindingNames = [] -- panic "bindingNames"
    lhs.constraints = panic "constraints"
    lhs.envs = panic "envs"
    lhs.etaTypes = panic "etaTypes"
    lhs.rhoSchemes = panic "rhoSchemes"

SEM Binding
  | Bind
    lhs.bindingName = @n
    loc.env = envDeleteList @e.env @lhs.allBindingNames
    loc.(rhosigma, fv) = envLookupFreshList (@e.freshVar, @lhs.toHsName) @e.env @lhs.allBindingNames
    lhs.freshVar = @loc.fv
    lhs.env = @loc.env
    lhs.etaTy = @e.etaTy
    lhs.rhoSchemes = @loc.rhosigma
    lhs.constraints = @e.constraints
  
%%]
