%%[0 lhs2tex
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% See CommonBindExtract
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}Core.BindExtract}
%%]

%%[(8 codegen) hs import({%{EH}Base.Common},{%{EH}Core},{%{EH}Ty})
%%]

%%[(8 codegen) hs import(Control.Monad.State)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Interface structures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(BoundSel(..),noBoundSel,emptyBoundSel)
-- | Selection predicates, an algebra for CBound fixed to yield Bool
data BoundSel
  = BoundSel
      { selBind         :: Bool
      , selMeta         :: ACoreBindAspectKeyS -> Bool
%%[[(8 codegenanalysis)
      , selRelevTy      :: ACoreBindAspectKeyS -> RelevTy -> Bool
%%]]
      , selVal          :: ACoreBindAspectKeyS -> MetaLev -> CLbl -> Bool
      , selTy           :: ACoreBindAspectKeyS -> Bool
%%[[90
      , selFFE          :: Bool
%%]]
      }


-- | Default selection
noBoundSel, emptyBoundSel :: BoundSel
noBoundSel
  = BoundSel
      { selBind			= False
      , selMeta			= const False
%%[[(8 codegenanalysis)
      , selRelevTy		= \_ _ -> False
%%]]
      , selVal			= \_ _ _ -> False
      , selTy			= const False
%%[[90
      , selFFE			= False
%%]]
      }

emptyBoundSel = noBoundSel
%%]

%%[(8 codegen) hs export(boundSelVal,boundSelExpr,boundSelMetaLev0,boundSelMetaLev01)
-- | Predefined selection: Val
boundSelVal :: BoundSel
boundSelVal
  = noBoundSel
      { selVal 			= \_ _ _ -> True
      }

-- | Predefined selection: Expr occurring in either Val or Bind or FFE
boundSelExpr :: BoundSel
boundSelExpr
  = boundSelMetaLev0
      { selBind			= True
      }

-- | Predefined selection: same MetaLev (i.e. 0)
boundSelMetaLev0 :: BoundSel
boundSelMetaLev0
  = noBoundSel
      { selBind			= True
      , selVal 			= \_ mlev _ -> mlev == 0
%%[[90
      , selFFE 			= True
%%]]
      }

-- | Predefined selection: same MetaLev (i.e. 0), + 1 higher (i.e. has signature)
boundSelMetaLev01 :: BoundSel
boundSelMetaLev01
  = boundSelMetaLev0
      { selVal 			= \_ mlev _ -> mlev <= 1
      , selTy			= const True
      }
%%]

%%[(8 codegen) hs export(SelVal)
type SelVal = CBound
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).WRAPPER ag import({Core/AbsSyn},{Core/CommonBindExtract})
WRAPPER CBind CBound
%%]

%%[(8 codegen) hs export(cbindExtractMk,cbindExtract,cboundExtract)
-- | Extract CBounds for a binding, partitioned according to selection, returning a reconstruction function taking mapped CBounds
cbindExtractMk :: BoundSel -> CBind -> ([SelVal],[SelVal],[SelVal] -> CBind)
cbindExtractMk sel b
  = ( selvalYesL_Syn_CBind t
    , selvalNoL_Syn_CBind t
    , \yessel -> b {bindAspects_CBind_Bind = selvalInsertYes_Syn_CBind t yessel}
    )
  where t = wrap_CBind (sem_CBind b)
              (Inh_CBind
                { boundsel_Inh_CBind = sel
                })

-- | Extract CBounds for a binding, partitioned according to selection
cbindExtract :: BoundSel -> CBind -> ([SelVal],[SelVal])
cbindExtract sel b
  = (yessel,nosel)
  where (yessel,nosel,_) = cbindExtractMk sel b

-- | Extract CBounds for a bound, partitioned according to selection
cboundExtract :: BoundSel -> CBound -> ([SelVal],[SelVal])
cboundExtract sel b
  = (selvalYesL_Syn_CBound t, selvalNoL_Syn_CBound t)
  where t = wrap_CBound (sem_CBound b)
              (Inh_CBound
                { boundsel_Inh_CBound = sel
                })
%%]

%%[(8 codegen) hs export(cbindExtractExprMk)
-- | Extract (first) bound CExpr and reconstruction
cbindExtractExprMk :: CBind -> (CExpr, CExpr -> CBind)
cbindExtractExprMk bi
  = case bo of
      CBound_Val  {expr_CBound_Val =e} -> (e, mkbi $ \e' -> bo {expr_CBound_Val =e'})
      CBound_Bind {expr_CBound_Bind=e} -> (e, mkbi $ \e' -> bo {expr_CBound_Bind=e'})
%%[[90
      CBound_FFE  {expr_CBound_FFE =e} -> (e, mkbi $ \e' -> bo {expr_CBound_FFE =e'})
%%]]
  where mkbi mke = \e' -> mks (mke e' : bos)
        (bo : bos, _, mks) = cbindExtractMk boundSelExpr bi
%%]

%%[(8 codegen) hs export(cbindExtractVal',cbindExtractVal,cboundExtractVal',cboundExtractVal)
extractVal' :: (BoundSel -> b -> ([SelVal],[SelVal])) -> b -> (ACoreBindAspectKeyS,MetaLev,CExpr)
extractVal' extr b
  = (a,ml,e)
  where (CBound_Val a ml _ e:_, _) = extr boundSelVal b

extractVal :: (BoundSel -> b -> ([SelVal],[SelVal])) -> b -> CExpr
extractVal extr b
  = e
  where (_,_,e) = extractVal' extr b

cbindExtractVal' :: CBind -> (ACoreBindAspectKeyS,MetaLev,CExpr)
cbindExtractVal' = extractVal' cbindExtract

cbindExtractVal :: CBind -> CExpr
cbindExtractVal = extractVal cbindExtract

cboundExtractVal' :: CBound -> (ACoreBindAspectKeyS,MetaLev,CExpr)
cboundExtractVal' = extractVal' cboundExtract

cboundExtractVal :: CBound -> CExpr
cboundExtractVal = extractVal cboundExtract
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% The returned value, just self
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllExpr [ | | boundval: SELF ]
%%]

