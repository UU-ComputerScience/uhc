%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Generation of EH AST
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1
ATTR AGItf [ | | eh: {EH.AGItf} ]

SEM AGItf
    | AGItf
        lhs         .   eh          =   EH.AGItf_AGItf @module.eh
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utils: factored out code         
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1 hs
ehSection :: AppLike eh bound
  => UID -> Range
  -> RngLiftArg (HsName -> eh)
  -> RngLiftArg (HsName -> ehp)
  -> RngLiftArg (ehp -> eh -> eh)
  -> Maybe eh -> eh -> Maybe eh
  -> eh
ehSection uniq range semvar sempatvar semlam left op right
  = case (left,right) of
      -- (Just l ,Just r ) -> appRngParApp range [op,l,r]
      (Nothing,Just r ) -> rngLift range semlam np (appRngParApp range [op,ne,r])
      (Just l ,Nothing) -> appRngParApp range [op,l]
      (Nothing,Nothing) -> op
  where n  = mkHNmHidden $ mkHNm ("x_" ++ show uniq)
        ne = rngLift range semvar n
        np = rngLift range sempatvar n
%%]

%%[1 hs
ehTupleConstructor
  :: AppLike eh bound
     => Range -> Int -> RngLiftArg (HsName -> eh) -> RngLiftArg (HsName -> ehp) -> RngLiftArg (ehp -> eh -> eh)
%%[[1
     -> RngLiftArg (HsName -> eh)
%%][7
     -> ([ehp] -> eh -> eh) -> RngLiftArg (r -> eh) -> RngLiftArg (r -> Maybe HsName -> eh -> r) -> RngLiftArg r
%%]]
     -> eh
ehTupleConstructor range arity semvar sempatvar semlam
%%[[1
        semcon
%%][7
        semtop semrecd semrecdext semrecdempty
%%]]
  = foldr (rngLift range semlam) recd ps
  where ns     = take arity hsnLclSupply
        ps     = map (rngLift range sempatvar) ns
        recd   = mkt (map (rngLift range semvar) ns)
%%[[1
        mkt ns = appRngParApp range (rngLift range semcon (hsnProd arity) : ns)
%%][7
        mkt ns = semtop ps
                 $ rngLift range semrecd
                 $ foldl (\r e -> rngLift range semrecdext r Nothing e)
                         (rngLift range semrecdempty)
                         ns
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Modules         
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1
ATTR Module [ | | eh: {EH.Expr} ]
%%]

%%[1
ATTR Body [ | | eh: {EH.Expr} ]
%%]

%%[1.Body.hsnMain
SEM Body
    | Body
        lhs         .   eh          =   @mkSccLet (rngLift @range EH.Expr_IConst 0)
%%]

%%[8.Body.hsnMain -1.Body.hsnMain
SEM Body
    | Body
        lhs         .   eh          =   @mkSccLet (if @mainValExists then rngLift @range EH.Expr_Var hsnMain
                                                                     else rngLift @range EH.Expr_IConst 0
                                                  )
%%]

%%[50 -8.Body.hsnMain
SEM Body
    | Body
        lhs         .   eh          =   @mkSccLet (if @lhs.isMainMod then rngLift @range EH.Expr_Var hsnMain
                                                                     else rngLift @range EH.Expr_IConst 0
                                                  )
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Top level main binding         
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8.Body.ehMainDecl
SEM Body
    | Body
        loc         .   ehMainDecl  =   rngLift @range EH.Decl_Val
                                            (rngLift @range EH.PatExpr_Var hsnMain)
                                            (rngLift @range EH.Expr_IConst 0)
%%]

%%[50 -8.Body.ehMainDecl
SEM Body
    | Body
        loc         .   ehMainDecl  =   rngLift @range EH.Decl_Val
                                            (rngLift @range EH.PatExpr_Var hsnMain)
%%[[50
                                            (rngLift @range EH.Expr_Var @mainrefname)
%%][99
                                            (appRngParApp @range [rngLift @range EH.Expr_Var (@mainrefnames !! 2),rngLift @range EH.Expr_Var @mainrefname])
%%]]
%%[[98
                    .   ehMainSig   =   rngLift @range EH.Decl_TySig
                                            hsnMain
                                            (appRngParApp @range [rngLift @range EH.TyExpr_Con (@mainrefnames !! 1),rngLift @range EH.TyExpr_Wild])
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Declarations    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1
ATTR MaybeDeclarations [ | | eh USE {`const`} {Nothing}: {Maybe [EH.Decl]} ]

ATTR Declarations [ | | eh USE {++} {[]}: {[EH.Decl]} ]

ATTR Declaration [ | | eh: {[EH.Decl]} ]

SEM MaybeDeclarations
    | Just
        lhs         .   eh          =   Just @just.eh

SEM Declaration
    | FunctionBindings
        lhs         .   eh          =   @bindings.eh
    | PatternBinding
        loc         .   eh          =   rngLift @range EH.Decl_Val @pattern.eh @righthandside.eh
        lhs         .   eh          =   [@eh]
    | TypeSignature
        loc         .   mkEHSig     =   \n -> rngLift @range EH.Decl_TySig n @type.eh
        lhs         .   eh          =   map @mkEHSig @refnames
    | Fixity
        lhs         .   eh          =   []
    | Empty
        lhs         .   eh          =   []
%%]
%%[5
    | Data
%%[[31
      GADT
%%]]
        loc         .   eh          =   rngLift @range EH.Decl_Data False @typerefname (map (rngLift @range EH.TyVar_Var) @typelefthandside.typevariables) @constructors.eh
%%[[92
                                                (if ehcOptGenGenerics @lhs.opts then Just @generMaxRemArity else Nothing)
%%]]
        lhs         .   eh          =   [@eh]
    | Newtype
        loc         .   eh          =   rngLift @range EH.Decl_Data True @typerefname (map (rngLift @range EH.TyVar_Var) @typelefthandside.typevariables) [@constructors.eh]
%%[[92
                                                (if ehcOptGenGenerics @lhs.opts then Just @generMaxRemArity else Nothing)
%%]]
        lhs         .   eh          =   [@eh]
%%[[92
    | Data Newtype GADT
        loc         .   ehGener     =   rngLift @range EH.Decl_GenerRep @generMaxRemArity @typerefname @constructors.conrefnames @constructors.conAndFldrefnames
%%]]
%%[[93
    | FusionDeclaration
        loc         .   eh          =   rngLift @range EH.Decl_FusionDecl @reffusename
    | FusionConversion
        loc         .   eh          =   rngLift @range EH.Decl_FusionConv (@refnames !! 0) (@refnames !! 1)
    | FusionDeclaration FusionConversion
        lhs         .   eh          =   [@eh]
%%]]
%%]
%%[6
    | KindSignature
        loc         .   mkEHSig     =   \n -> rngLift @range EH.Decl_KiSig n @kind.eh
        lhs         .   eh          =   map @mkEHSig @refnames
%%]
%%[(8 codegen)
    | ForeignImport
        loc         .   eh          =   rngLift @range EH.Decl_FFI @callconvention (maybe "safe" id @safety) @ent @refname @type.eh
        lhs         .   eh          =   [@eh]
%%]
%%[9
    | Class
        loc         .   (eh,ehInst) =   let h = rngLift @range EH.TyExpr_Pred
                                                $ rngLift @range EH.PrExpr_Class @classrefname (map (rngLift @range EH.TyExpr_Var) @typelefthandside.typevariables)
                                            c = map (rngLift @range EH.TyExpr_Pred) @context.eh
                                            a = appArr c h
                                            (vals,sigs) = partition EH.ehIsDeclVal $ concat @ehReorderedDecls
                                        in  ( rngLift @range EH.Decl_Class a
%%[[15
                                                      @dependencies.eh
%%]]
                                                      (Just @instancerefname) sigs
%%[[92
                                                      []
%%][99
                                                      @generDerivInfoL
%%]]
                                            , rngLift @range EH.Decl_Instance (Just (@instancerefname,False)) InstDefault a vals
                                            )
        lhs         .   eh          =   [@eh,@ehInst]
    | Instance
        loc         .   eh          =   let -- h = rngLift @range EH.TyExpr_Pred $ rngLift @range EH.PrExpr_Class @classrefname @types.eh
                                            h = rngLift @range EH.TyExpr_Pred $ panicJust "HS.ToEH.Instance.eh.type.ehMbAsPr" @type.ehMbAsPr
                                            c = map (rngLift @range EH.TyExpr_Pred) @context.eh
                                        in  rngLift @range EH.Decl_Instance (Just (@instancerefname,@useimplicitly)) @instVariant (appArr c h) (concat @ehReorderedDecls)
        lhs         .   eh          =   [@eh]
    | InstanceUseImplicitly
        loc         .   eh          =   let h = rngLift @range EH.PrExpr_Class @classrefname @types.eh
                                        in  rngLift @range EH.Decl_InstanceIntro (Just @instancerefname) @expression.eh h
        lhs         .   eh          =   [@eh]
    | Default
        loc         .	ignoredecl	=	null @classrefnames
                    .   eh          =   rngLift @range EH.Decl_Default @classrefname @types.eh
        lhs         .   eh          =   [@eh]
%%]
%%[11
    | Type
        loc         .   eh          =   rngLift @range EH.Decl_Type @typerefname (foldr (rngLift @range EH.TyExpr_Lam) @type.eh @typelefthandside.typevariables)
        lhs         .   eh          =   [@eh]
%%]
%%[(90 codegen)
    | ForeignExport
        loc         .   nmForParse 	=	maybe "" id @exportname
                    .   (ent,entErrs)
                                    =   parseForeignEnt ForeignDirection_Export @callconvention (Just $ show @name) @nmForParse
                    .   eh          =   rngLift @range EH.Decl_FFE @exportrefname @callconvention @ent (rngLift @range EH.Expr_Var @refname) @type.eh
        lhs         .   eh          =   [@eh]
%%]
%%[99
    | Pragma Module
        loc         .   eh          =   undefined
        lhs         .   eh          =   []
%%]

%%[15
ATTR FunctionalDependencies [ | | eh USE {:} {[]}: {[EH.FuncDep]} ]

ATTR FunctionalDependency [ | | eh: {EH.FuncDep} ]

SEM FunctionalDependency
    | Dependency
        lhs         .   eh          =   rngLift @range EH.FuncDep_Dep
                                          (map (rngLift @range EH.TyVar_Var) @fromtypevariables)
                                          (map (rngLift @range EH.TyVar_Var) @totypevariables)
%%]

%%[91
ATTR AllDeriving [ ehDataTyExpr: {EH.TyExpr} | | ]

SEM Declaration
    | Data Newtype GADT
        derivings   .   ehDataTyExpr=   appTopApp (rngLift @range EH.TyExpr_Con @typerefname : map (rngLift @range EH.TyExpr_Var) @typelefthandside.typevariables)

SEM Deriving
    | Deriving
        loc         .   eh          =   let h = rngLift @range EH.TyExpr_Pred
                                                $ rngLift @range EH.PrExpr_Class @refname [rngLift @range EH.TyExpr_Parens @lhs.ehDataTyExpr]
                                        in  rngLift @range EH.Decl_Instance (Just (@instancerefname,@useimplicitly)) (InstDeriving InstDerivingFrom_Datatype) h []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Kinds           
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[6
ATTR Kinds [ | | eh USE {:} {[]}: {[EH.KiExpr]} ]

ATTR Kind [ | | eh: {EH.KiExpr} ]

SEM Kind
    | NormalApplication
        lhs         .   eh          =   appTopApp (@function.eh : @arguments.eh)
    | InfixApplication
        loc         .   eh          =   appRngParApp @range [@operator.eh,@leftKind.eh,@rightKind.eh]
    | Constructor
        lhs         .   eh          =   rngLift @range EH.KiExpr_Con @refname
    | Parenthesized
        lhs         .   eh          =   rngLift @range EH.KiExpr_Parens @kind.eh
    | Variable
        lhs         .   eh          =   rngLift @range EH.KiExpr_Var @name
    | Forall
        lhs         .   eh          =   {- foldr (rngLift @range EH.KiExpr_Quant tyQu_Forall) -} @kind.eh {- @kindvariables -}
	| Annotate
		loc			.	eh			=	rngLift @range EH.KiExpr_Ann @annotation.eh @kind.eh
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Types           
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[7.ehTyExprArg hs
ehTyExprArg :: EH.TyExpr -> EH.TyExpr
ehTyExprArg = snd . panicJust "HS.ToEH.ehTyExprArg" . appMbApp1 . fst . appUnTop
%%]

%%[1
ATTR Types [ | | eh USE {:} {[]}: {[EH.TyExpr]} ]

ATTR Type [ | | eh: {EH.TyExpr} ]

ATTR MaybeType [ | | eh USE {`const`} {Nothing}: {Maybe EH.TyExpr} ]

SEM MaybeType
    | Just
        lhs         .   eh          =   Just @just.eh
%%]

%%[1
SEM Type
    | NormalApplication
        loc         .   eh          =   appTopApp (@function.eh : @arguments.eh)
%%[[1
    | InfixApplication
        loc         .   eh          =   appRngParApp @range [@operator.eh,@leftType.eh,@rightType.eh]
%%][9
    | InfixApplication
        loc         .   (eh,ctxtFormErrs,isPredOp)
                                    =   if not @lhs.isAsPred && @operator.tyConIs == TyConIsPrArrow
                                        then let t = foldr app1Arr @rightType.eh [ pr | (Just pr) <- @leftType.ehMbAsTyPrL ]
                                             in  if all isJust @leftType.ehMbAsTyPrL
                                                 then (t, []                                                  , True )
                                                 else (t, [rngLift @range Err_MalformedPred @leftType.pp]     , False)
                                        else (appRngParApp @range [@operator.eh,@leftType.eh,@rightType.eh], [], False)
%%]]
%%[[5
    | InfixApplicationChainTop
        loc         .   eh          =   @ehFromOpChain
%%]]
    | SectionApplication
        loc         .   eh          =   ehSection
                                            @lUniq_1_nm @range
%%[[1
                                            (panic "HS.ToEH.Type.SectionApplication.TyExpr_Var")		-- guaranteed by parsing not to happend
%%][3
                                            EH.TyExpr_Var
%%]]
                                            (rngAntilift id)
%%[[1
                                            (panic "HS.ToEH.Type.SectionApplication.TyExpr_Lam")		-- guaranteed by parsing not to happend
%%][11
                                            EH.TyExpr_Lam
%%]]
                                            @leftType.eh @operator.eh @rightType.eh
        loc         .   lUniq_1_nm  :   UNIQUEREF gUniq
    | Constructor
        loc         .   eh          =   rngLift @range EH.TyExpr_Con @refname
    | Parenthesized
        loc         .   eh          =   rngLift @range EH.TyExpr_Parens @type.eh
	| Annotate
		loc			.	eh			=	rngLift @range EH.TyExpr_Ann @annotation.eh @type.eh
%%]
%%[2
    | Wildcard
        loc         .   eh          =   rngLift @range EH.TyExpr_Wild
    | MonoWildcard
        loc         .   eh          =   rngLift @range EH.TyExpr_Mono
%%]
%%[3
    | Variable
%%[[1
        loc         .   eh          =   rngLift @range EH.TyExpr_Var @name
%%][4
        loc         .   eh          =   rngLift @range (if @lhs.doGenVarWild then EH.TyExpr_VarWild else EH.TyExpr_Var) @name
%%]]
    | NamedWildcard
        loc         .   eh          =   rngLift @range EH.TyExpr_VarWild @name
%%]
%%[4
    | Forall
        loc         .   eh          =   foldr (rngLift @range EH.TyExpr_Quant tyQu_Forall) @type.eh @typevariables
    | Exists
        loc         .   eh          =   foldr (rngLift @range EH.TyExpr_Quant tyQu_Exists) @type.eh @typevariables
%%]
%%[7
    | RowUpdate
        loc         .   eh          =   foldl (flip ($)) @type.eh @rowTypeUpdates.eh
    | RowEmpty
        loc         .   eh          =   rngLift @range EH.TyExpr_Row (rngLift @range EH.RowTyExpr_Empty)
    | RowRecUpdate
        loc         .   eh          =   foldl (\e u -> appCon1App hsnRec $ u $ ehTyExprArg $ e) @type.eh @rowTypeUpdates.eh
    | RowRecEmpty
        loc         .   eh          =   appCon1App hsnRec $ rngLift @range EH.TyExpr_Row (rngLift @range EH.RowTyExpr_Empty)
    | RowSumUpdate
        loc         .   eh          =   foldl (\e u -> appCon1App hsnSum $ u $ ehTyExprArg $ e) @type.eh @rowTypeUpdates.eh
    | RowSumEmpty
        loc         .   eh          =   appCon1App hsnSum $ rngLift @range EH.TyExpr_Row (rngLift @range EH.RowTyExpr_Empty)
%%]
%%[9
    | Qualified
        loc         .   eh          =   foldr app1Arr @type.eh @context.ehTy
%%]
%%[11
    | TupleConstructor
        loc         .   eh          =   ehTupleConstructor @range @arity EH.TyExpr_Var (rngAntilift id)
                                            EH.TyExpr_Lam
                                            (\ps r -> {- appArr (map (rngLift @range EH.TyExpr_Var) ps) -} r)
                                            (rngAntilift $ \row -> appCon1App hsnRec (rngLift @range EH.TyExpr_Row row))
                                            EH.RowTyExpr_Ext EH.RowTyExpr_Empty
%%]
    | Implicits
        loc         .   eh          =   rngLift @range EH.TyExpr_Impls
    | NoImplicits
        loc         .   eh          =   rngLift @range EH.TyExpr_NoImpls

%%[9 hs
%%]
ehExpUnTop :: EH.Expr -> EH.Expr
ehExpUnTop (EH.Expr_AppTop e) = e
ehExpUnTop e                  = e

%%[9
ATTR ContextItems [ | | eh USE {:} {[]}: {[EH.PrExpr]}  ehTy USE {:} {[]}: {[EH.TyExpr]} ]

ATTR ContextItem [ | | eh: {EH.PrExpr}  ehTy: {EH.TyExpr} ]

SEM ContextItem
    | Class
        loc         .   eh          =   rngLift @range EH.PrExpr_Class @refname @types.eh
    | Implicits NoImplicits
        loc         .   eh          =   undefined -- may not occur nested
%%[[10
    | RowLacksLabel
        loc         .   eh          =   rngLift @range EH.PrExpr_Lacks (rngLift @range EH.RowTyExpr_Var @rowvariable) @name
%%]]
%%[[13
    | Arrow
        loc         .   eh          =   rngLift @range EH.PrExpr_Arrow @argument.eh @result.eh
    | Forall
        loc         .   eh          =   foldr (rngLift @range EH.PrExpr_Forall) @context.eh @typevariables
%%]]
%%[[31
    | Equal
        loc         .   eh          =   rngLift @range EH.PrExpr_Eq @type1.eh @type2.eh
%%]]

SEM ContextItem
    | * - Implicits NoImplicits
        loc         .   ehTy        =   rngLift @range EH.TyExpr_Pred @eh
    | Implicits
        loc         .   ehTy        =   rngLift @range EH.TyExpr_Impls
    | NoImplicits
        loc         .   ehTy        =   rngLift @range EH.TyExpr_NoImpls
%%]

%%[5
ATTR Constructors [ | | eh USE {:} {[]}: {[EH.DataConstr]} ]

ATTR Constructor [ | | eh: {EH.DataConstr} ]
%%]

%%[7 hs
ehPlainDataField :: Range -> EH.TyExpr -> EH.DataField
ehPlainDataField r
  = rngLift r EH.DataField_Field Nothing
%%]

%%[5.Constructor
SEM Constructor
    | Constructor 
        lhs         .   eh          =   rngLift @range EH.DataConstr_Constr @conrefname
                                                @types.eh
%%[[31
                                                Nothing
%%]]
%%[[41
                                                []
%%]]
    | Infix
        lhs         .   eh          =   rngLift @range EH.DataConstr_Constr @conrefname
                                                [@leftType.eh,@rightType.eh]
%%[[31
                                                Nothing
%%]]
%%[[41
                                                []
%%]]
%%]

%%[7.Constructor -5.Constructor
SEM Constructor
    | Constructor 
        lhs         .   eh          =   rngLift @range EH.DataConstr_Constr @conrefname
%%[[91
                                                Nothing
%%]]
                                                (map (ehPlainDataField emptyRange) @types.eh)
%%[[31
                                                Nothing
%%]]
%%[[41
                                                []
%%]]
%%[[31
    | GADTFunction 
        loc			.	(ehArgs,ehRes)
        							=	appUnArr @type.eh
        lhs         .   eh          =   rngLift @range EH.DataConstr_Constr @conrefname
%%[[91
                                                Nothing
%%]]
                                                (map (ehPlainDataField emptyRange) @ehArgs)
                                                (Just @ehRes)
%%[[41
                                                []
%%]]
%%]]
    | Infix
        lhs         .   eh          =   rngLift @range EH.DataConstr_Constr @conrefname
%%[[91
                                                -- (Just $ fgiPrio $ fixityGamLookup @conrefname @lhs.fixityGam)
                                                (let fgi = fixityGamLookup @conrefname @lhs.fixityGam
                                                  in Just (fgiPrio fgi, fgiFixity fgi)
                                                )
%%]]
                                                (map (ehPlainDataField emptyRange) [@leftType.eh,@rightType.eh])
%%[[31
                                                Nothing
%%]]
%%[[41
                                                []
%%]]
    | Record
        lhs         .   eh          =   rngLift @range EH.DataConstr_Constr @conrefname
%%[[91
                                                Nothing
%%]]
                                                @fieldDeclarations.eh
%%[[31
                                                Nothing
%%]]
%%[[41
                                                []
%%]]
%%[[9
	| Contexted
		lhs			.	eh			=	@constructor.eh			-- for now: ignore
%%]]
%%]

%%[7
ATTR FieldDeclarations [ | | eh USE {:} {[]}: {[EH.DataField]} ]

ATTR FieldDeclaration [ | | eh: {EH.DataField} ]

SEM FieldDeclaration
    | FieldDeclaration
        lhs         .   eh          =   rngLift @range EH.DataField_Field (Just @fldrefnames) @type.eh
%%]

%%[9
ATTR Type [ | | ehMbAsPr: {Maybe EH.PrExpr} ]

SEM Type
    | NormalApplication
        loc         .   ehMbAsPr    =   case @function.mbRefConNm of
                                          Just conNm | @lhs.isAsPred
                                            -> Just $ rngLift @range EH.PrExpr_Class conNm @arguments.eh
                                          _ -> Nothing
    | Forall
        loc         .   ehMbAsPr    =   foldr (\tv pr -> fmap (rngLift @range EH.PrExpr_Forall tv) pr) @type.ehMbAsPr @typevariables
    | InfixApplication
        loc         .   ehMbAsPr    =   case (@leftType.ehMbAsPr,@rightType.ehMbAsPr) of
                                          (Just l,Just r) | @operator.tyConIs == TyConIsPrArrow && @lhs.isAsPred
                                            -> Just $ rngLift @range EH.PrExpr_Arrow l r
                                          (Nothing,Nothing) | @lhs.isAsPred
                                            -> case @operator.tyConIs of
                                                 TyConIsPrArrow -> Just $ rngLift @range EH.PrExpr_Class (fromJust @operator.mbRefConNm) [@leftType.eh,@rightType.eh]
%%[[31
                                                 TyConIsEqTilde -> Just $ rngLift @range EH.PrExpr_Eq @leftType.eh @rightType.eh
%%]]
                                                 TyConIsOther   -> Just $ rngLift @range EH.PrExpr_Class (fromJust @operator.mbRefConNm) [@leftType.eh,@rightType.eh]
                                          _ -> Nothing
    | InfixApplicationChainTop Parenthesized Annotate
        loc         .   ehMbAsPr    =   @type.ehMbAsPr
    | * - NormalApplication Forall InfixApplication InfixApplicationChainTop Parenthesized Annotate
        loc         .   ehMbAsPr    =   Nothing

ATTR Type AllRowTypeUpdate [ | | ehMbAsPrL USE {++} {[]}: {[Maybe EH.PrExpr]} ]

SEM Type
    | RowRecUpdate
        loc         .   ehMbAsPrL   =   @rowTypeUpdates.ehMbAsPrL
    | Parenthesized Annotate
        loc         .   ehMbAsPrL   =   @type.ehMbAsPrL
    | * - RowRecUpdate Parenthesized Annotate
        loc         .   ehMbAsPrL   =   [@ehMbAsPr]

SEM RowTypeUpdate
    | Extends
        loc         .   ehMbAsPrL   =   [@type.ehMbAsPr]
%%]

%%[9
ATTR Type [ | | ehMbAsTyPr: {Maybe EH.TyExpr} ]

SEM Type
	| Wildcard MonoWildcard
		loc			.	ehMbAsTyPr	=	Just $ rngLift @range EH.TyExpr_Impls
	| * - Wildcard MonoWildcard
		loc			.	ehMbAsTyPr	=	fmap (rngLift @range EH.TyExpr_Pred) @ehMbAsPr

ATTR Type AllRowTypeUpdate [ | | ehMbAsTyPrL USE {++} {[]}: {[Maybe EH.TyExpr]} ]

SEM Type
    | RowRecUpdate
        loc         .   ehMbAsTyPrL =   @rowTypeUpdates.ehMbAsTyPrL
	| Wildcard MonoWildcard
		loc			.	ehMbAsTyPrL	=	[@ehMbAsTyPr]
	| * - Wildcard MonoWildcard Parenthesized RowRecUpdate
		loc			.	ehMbAsTyPrL	=	map (fmap (rngLift @range EH.TyExpr_Pred)) @ehMbAsPrL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Expressions     
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[97 hs
ehExpLitInt :: Range -> Int -> String -> Int -> [HsName] -> (EH.Expr,Maybe SrcConst)
ehExpLitInt r b s sign litrefnames
  | sign < 0  = mk (\e -> ehExpVarApp r (litrefnames !! 1) [e], negate)
  | otherwise = mk (id                                        , id    )
  where i = intDenot2Integer b s
        mk (neg,negconst)
          = (neg $ ehExpVarApp r (litrefnames !! 0) [rngLift r EH.Expr_IIConst i], Just $ SrcConst_Int $ negconst i)

ehExpLitFloat :: Range -> String -> Int -> [HsName] -> (EH.Expr,Maybe SrcConst)
ehExpLitFloat r s sign litrefnames
  | sign < 0  = mk (\e -> ehExpVarApp r (litrefnames !! 2) [e], \(n,d) -> (negate n, d))
  | otherwise = mk (id                                        , id                     )
  where nd@(n,d) = floatDenot2NomDenom s
        mk (neg,negconst)
          = ( neg $ ehExpVarApp r (litrefnames !! 1)
                  $ [rngLift r EH.Expr_Parens $ ehExpVarApp r (litrefnames !! 0) [rngLift r EH.Expr_IIConst n,rngLift r EH.Expr_IIConst d]]
            , Just $ uncurry SrcConst_Ratio $ negconst nd
            )
%%]

%%[1 hs
ehExpApp' :: (EH.Expr -> a -> EH.Expr) -> Range -> EH.Expr -> [a] -> EH.Expr
ehExpApp' app r f as
  = rngLift r EH.Expr_AppTop
    $ foldl app (ehExpUnTop f) as

ehExpConApp :: Range -> HsName -> [EH.Expr] -> EH.Expr
ehExpConApp r n as
  = appRngParApp r (rngLift r EH.Expr_Con n : as)

ehExpVarApp :: Range -> HsName -> [EH.Expr] -> EH.Expr
ehExpVarApp r n as
  = appRngParApp r (rngLift r EH.Expr_Var n : as)

ehExpUnTop :: EH.Expr -> EH.Expr
%%[[1
ehExpUnTop (EH.Expr_AppTop   e) = e
%%][99
ehExpUnTop (EH.Expr_AppTop _ e) = e
%%]]
ehExpUnTop e                    = e
%%]

%%[1.ehExpProd hs
ehExpProd :: Range -> [EH.Expr] -> EH.Expr
ehExpProd r as
  = ehExpConApp r (hsnProd a) as
  where a = length as
%%]

%%[1
ATTR Expressions [ | | eh USE {:} {[]}: {[EH.Expr]} ]

ATTR MaybeExpression [ | | eh USE {`const`} {Nothing}: {Maybe EH.Expr} ]

ATTR Expression [ | | eh: {EH.Expr} ]

SEM MaybeExpression
    | Just
        lhs         .   eh          =   Just @just.eh
%%]

%%[1
SEM Expression
    | Literal
        loc         .   eh          =   case @literal.eh of
%%[[1
                                          Literal_Int    r   s -> rngLift r EH.Expr_IConst (read s)
%%][97
                                          Literal_Int    r b s -> fst $ ehExpLitInt r b s 1 @litrefnames
%%]]
                                          Literal_Char   r s -> rngLift r EH.Expr_CConst (head s)
%%[[5
                                          Literal_String r s -> rngLift r EH.Expr_SConst s
%%]]
%%[[97
                                          Literal_Float  r s -> fst $ ehExpLitFloat r s 1 @litrefnames
%%]]
    | Variable
        loc         .   eh          =   rngLift @range EH.Expr_Var @refname
    | Constructor
        loc         .   eh          =   rngLift @range EH.Expr_Con @refname
    | TupleConstructor
        loc         .   eh          =   ehTupleConstructor @range @arity EH.Expr_Var EH.PatExpr_Var EH.Expr_Lam
%%[[1
                                            EH.Expr_Con
%%][7
                                            (\_ x -> x) EH.Expr_Rec EH.RecExpr_Ext EH.RecExpr_Empty
%%]]
    | Parenthesized
        loc         .   eh          =   rngLift @range EH.Expr_Parens @expression.eh
    | NormalApplication
        loc         .   eh          =   appRngTopApp @range (@function.eh : @arguments.eh)
    | InfixApplication
        loc         .   eh          =   appRngParApp @range [@operator.eh,@leftExpression.eh,@rightExpression.eh]
    | InfixApplicationChainTop
        loc         .   eh          =   @ehFromOpChain
    | SectionApplication
        loc         .   eh          =   ehSection
                                            @lUniq_1_nm @range
                                            EH.Expr_Var EH.PatExpr_Var EH.Expr_Lam
                                            @leftExpression.eh @operator.eh @rightExpression.eh
        loc         .   lUniq_1_nm  :   UNIQUEREF gUniq
    | Lambda
        loc         .   eh          =   foldr (rngLift @range EH.Expr_Lam) @expression.eh @patterns.eh
    | Let
        loc         .   eh          =   @mkSccLet @expression.eh
    | Tuple
        loc         .   eh          =   ehExpConApp @range (hsnProd (length @expressions.eh)) @expressions.eh
    | Typed
        loc         .   eh          =   rngLift @range EH.Expr_TypeAs False @type.eh @expression.eh
    | Negate
        loc         .   eh          =   ehExpVarApp @range @refname [@expression.eh]
	| Annotate
		loc			.	eh			=	rngLift @range EH.Expr_Ann @annotation.eh @expression.eh
%%]
%%[4
    | ImpredicativeApplication
        loc         .   eh          =   ehExpApp' (rngLift @range EH.Expr_AppImpred) @range @function.eh @arguments.eh
%%]
%%[5
    | If
        loc         .   eh          =   EH.mkIf' (@typerefname : @valrefnames) @range @guardExpression.eh @thenExpression.eh @elseExpression.eh
%%[[5
    | Case
        loc         .   eh          =   EH.mkCase' @range @expression.eh @alternatives.eh
%%][8
    | Case
        loc         .   eh          =   EH.mkCase' @range @expression.eh (Just $ Set.singleton @caseId) Set.empty False @alternatives.eh
%%]]
    | List
        loc         .   eh          =   foldr (\l r -> ehExpConApp @range (@refnames !! 0) [l,r]) (rngLift @range EH.Expr_Con (@refnames !! 1)) @expressions.eh
    | Enum
        loc         .   enumNm      =   case (@from.eh,@then.eh,@to.eh) of
                                          (fr,Just th,Just to) -> hsnEnumFromThenTo
                                          (fr,Just th,Nothing) -> hsnEnumFromThen  
                                          (fr,Nothing,Just to) -> hsnEnumFromTo    
                                          (fr,Nothing,Nothing) -> hsnEnumFrom      
                    .   eh          =   case (@from.eh,@then.eh,@to.eh) of
                                          (fr,Just th,Just to) -> ehExpVarApp @range @refname [fr,th,to]
                                          (fr,Just th,Nothing) -> ehExpVarApp @range @refname [fr,th   ]
                                          (fr,Nothing,Just to) -> ehExpVarApp @range @refname [fr   ,to]
                                          (fr,Nothing,Nothing) -> ehExpVarApp @range @refname [fr      ]
    | Comprehension
        loc         .   eh          =   foldr ($) @expression.eh @qualifiers.eh
%%]
%%[7
    | RecordConstruction
        loc         .   eh          =   rngLift @range EH.Expr_DataFields $ foldl (flip ($)) (rngLift @range EH.DataFieldExpr_Con @refname) @recordExpressionBindings.eh
    | RecordUpdate
        loc         .   eh          =   case @recordExpressionBindings.eh of
                                          b@(_:_) -> rngLift @range EH.Expr_DataFields $ foldl (flip ($)) (rngLift @range EH.DataFieldExpr_Expr @expression.eh) b
                                          _       -> @expression.eh
    | RowRecordUpdate
        loc         .   eh          =   foldl (flip ($)) @expression.eh @rowRecordExpressionUpdates.eh
    | RowRecordEmpty
        loc         .   eh          =   rngLift @range EH.Expr_Rec (rngLift @range EH.RecExpr_Empty)
    | RowRecordSelect
        loc         .   eh          =   rngLift @range EH.Expr_Sel @expression.eh @name
%%]
%%[9
    | Do
        loc         .   (eh,_)      =   foldr1 (\(_,s) (e,_) -> (s e,undefined)) @statements.eh
%%]
%%[12
    | ImplicitApplication
        loc         .   eh          =   ehExpApp' (\f (e,p) -> rngLift @range EH.Expr_AppImpl f p e) @range @function.eh @arguments.eh
    | ImplicitLambda
        loc         .   eh          =   foldr (\(p,c) e -> rngLift @range EH.Expr_LamImpl c p e) @expression.eh @patterns.eh
%%]
-- Helium
%%[55
    | NegateFloat
        loc         .   eh          =   rngLift @range XX
        expression               : Expression
%%]

%%[12
ATTR ContextedExpressions [ | | eh USE {:} {[]}: {[(EH.Expr,EH.PrExpr)]} ]

ATTR ContextedExpression [ | | eh: {(EH.Expr,EH.PrExpr)} ]

SEM ContextedExpression
    | Contexted
        lhs         .   eh          =   (@expression.eh,@context.eh)
%%]

%%[5 hs
-- original with mono restriction
ehGenerator :: Range -> EH.PatExpr -> (EH.Expr -> EH.Expr) -> EH.Expr -> EH.Expr -> EH.Expr
ehGenerator r p mkRes fail e
  = EH.mkLet r
      (Just
         [ {- -} rngLift r EH.Decl_TySig ok ([mono] `appArr` appTopApp1 mono mono)
         , 
           rngLift r EH.Decl_Val
             (rngLift r EH.PatExpr_Var ok)
             (rngLift r EH.Expr_Lam
               (rngLift r EH.PatExpr_Var x)
               (EH.mkCase r
                 (rngLift r EH.Expr_Var x)
                 [(p,e),(rngLift r EH.PatExpr_Var hsnWild,fail)]
             ) )
{-
         , rngLift r EH.Decl_TySig res mono
         , rngLift r EH.Decl_Val
             (rngLift r EH.PatExpr_Var res)
             (mkRes (rngLift r EH.Expr_Var ok))
-}
         ])
      (mkRes (rngLift r EH.Expr_Var ok))
      -- (rngLift r EH.Expr_Var res)
  where ok   = mkHNmHidden "ok"
        res  = mkHNmHidden "ok_app"
        x    = mkHNmHidden "x"
        mono = rngLift r EH.TyExpr_Mono
%%]
-- directly inlining
ehGenerator :: Range -> EH.PatExpr -> (EH.Expr -> EH.Expr) -> EH.Expr -> EH.Expr -> EH.Expr
ehGenerator r p mkRes fail e
{-
  = EH.mkLet r
      (Just
         [ rngLift r EH.Decl_Val (rngLift r EH.PatExpr_Var ok) okLam
         ])
      (mkRes (rngLift r EH.Expr_Var ok))
-}
  = mkRes okLam
  where ok = mkHNmHidden "ok"
        x  = mkHNmHidden "x"
        okLam =
             (rngLift r EH.Expr_Lam
               (rngLift r EH.PatExpr_Var x)
               (EH.mkCase r
                 (rngLift r EH.Expr_Var x)
                 [(p,e),(rngLift r EH.PatExpr_Var hsnWild,fail)]
             ) )

-- original
ehGenerator :: Range -> EH.PatExpr -> (EH.Expr -> EH.Expr) -> EH.Expr -> EH.Expr -> EH.Expr
ehGenerator r p mkRes fail e
  = EH.mkLet r
      (Just
         [ rngLift r EH.Decl_Val
             (rngLift r EH.PatExpr_Var ok)
             (rngLift r EH.Expr_Lam
               (rngLift r EH.PatExpr_Var x)
               (EH.mkCase r
                 (rngLift r EH.Expr_Var x)
                 [(p,e),(rngLift r EH.PatExpr_Var hsnWild,fail)]
             ) )
         ])
      (mkRes (rngLift r EH.Expr_Var ok))
  where ok = mkHNmHidden "ok"
        x  = mkHNmHidden "x"

-- original with mono restriction
ehGenerator :: Range -> EH.PatExpr -> (EH.Expr -> EH.Expr) -> EH.Expr -> EH.Expr -> EH.Expr
ehGenerator r p mkRes fail e
  = EH.mkLet r
      (Just
         [ {- -} rngLift r EH.Decl_TySig ok ([mono] `appArr` appTopApp1 mono mono)
         , 
           rngLift r EH.Decl_Val
             (rngLift r EH.PatExpr_Var ok)
             (rngLift r EH.Expr_Lam
               (rngLift r EH.PatExpr_Var x)
               (EH.mkCase r
                 (rngLift r EH.Expr_Var x)
                 [(p,e),(rngLift r EH.PatExpr_Var hsnWild,fail)]
             ) )
{-
         , rngLift r EH.Decl_TySig res mono
         , rngLift r EH.Decl_Val
             (rngLift r EH.PatExpr_Var res)
             (mkRes (rngLift r EH.Expr_Var ok))
-}
         ])
      (mkRes (rngLift r EH.Expr_Var ok))
      -- (rngLift r EH.Expr_Var res)
  where ok   = mkHNmHidden "ok"
        res  = mkHNmHidden "ok_app"
        x    = mkHNmHidden "x"
        mono = rngLift r EH.TyExpr_Mono

%%[9
ATTR Statements [ | | eh USE {:} {[]}: {[(EH.Expr,EH.Expr -> EH.Expr)]} ]

ATTR Statement [ | | eh: {(EH.Expr,EH.Expr -> EH.Expr)} ]

SEM Statement
    | Expression
        lhs         .   eh          =   (@expression.eh,\e -> ehExpVarApp @range @refname [@expression.eh,e])
    | Let
        lhs         .   eh          =   (EH.mkUnit @range,@mkSccLet)
    | Generator
        lhs         .   eh          =   (@expression.eh
                                        ,ehGenerator
                                           @range @pattern.eh
                                           (\e -> ehExpVarApp @range (@refnames !! 0) [@expression.eh,e])
                                           (EH.mkError' (@refnames !! 1) @range "monadic bind")
                                        )
    | Empty
        lhs         .   eh          =   (undefined,id)
%%]

%%[5
ATTR Qualifiers [ | | eh USE {:} {[]}: {[EH.Expr -> EH.Expr]} ]

ATTR Qualifier [ | | eh: {EH.Expr -> EH.Expr} ]

SEM Qualifier
    | Guard
        lhs         .   eh          =   \e -> EH.mkIf' (@typerefname : @valrefnames) @range @guard.eh e (appCon (@valrefnames !! 2))
    | Let
        lhs         .   eh          =   @mkSccLet
    | Generator
        lhs         .   eh          =   ehGenerator
                                           @range @pattern.eh
                                           (\e -> ehExpVarApp @range (@refnames !! 0) [e,@expression.eh])
                                           (appCon (@refnames !! 1))
    | Empty
        lhs         .   eh          =   \e -> ehExpConApp @range (@refnames !! 0) [e,appCon (@refnames !! 1)]
%%]

%%[5
ATTR Alternatives [ | | eh USE {++} {[]}: {[EH.CaseAlt]} ]

ATTR Alternative [ | | eh: {[EH.CaseAlt]} ]

SEM Alternative
    | Alternative
        lhs         .   eh          =   [EH.mkAlt @range @pattern.eh @righthandside.eh]
    | Empty
        lhs         .   eh          =   []
%%]

%%[5
%%[[5
ATTR GuardedExpressions [ | | eh USE {:} {[]}: {[EH.Expr -> EH.Expr]} ]
ATTR GuardedExpression [ | | eh: {EH.Expr -> EH.Expr} ]
%%][8
ATTR GuardedExpressions [ | | eh USE {:} {[]}: {[UIDS -> EH.Expr -> EH.Expr]} ]
ATTR GuardedExpression [ | | eh: {UIDS -> EH.Expr -> EH.Expr} ]
%%]]
%%]

%%[5
SEM GuardedExpression -- ToDo: or _Guard?
%%[[5
    | GuardedExpression
        lhs         .   eh          =   EH.mkIf' (@typerefname : @valrefnames) @range @guard.eh $ ehMkEnforceMono @range @lhs.mustBeMono @expression.eh
%%][8
    | GuardedExpression
        lhs         .   eh          =   \failS e -> EH.mkIf'' (@typerefname : @valrefnames) @range @guard.eh (ehMkEnforceMono @range @lhs.mustBeMono @expression.eh) e Nothing failS -- (Just @lhs.caseId)
%%]]
%%]

%%[7
ATTR RecordExpressionBindings [ | | eh USE {:} {[]}: {[EH.DataFieldExpr -> EH.DataFieldExpr]} ]

ATTR RecordExpressionBinding [ | | eh: {EH.DataFieldExpr -> EH.DataFieldExpr} ]

SEM RecordExpressionBinding
    | Binding
        lhs         .   eh          =   \df -> rngLift @range EH.DataFieldExpr_Upd df @refname @expression.eh
%%]

%%[7 hs
ehRowRecExprUpd :: Range -> nm -> (EH.RecExpr -> nm -> EH.Expr -> EH.RecExpr) -> EH.Expr -> EH.Expr -> EH.Expr
ehRowRecExprUpd rng nm mk updE recE
  = case recE of
%%[[7
      EH.Expr_Rec r
%%][99
      EH.Expr_Rec _ r
%%]]
        -> mkUpd  r
      _ -> mkUpd (r2e recE)
  where r2e     = rngLift rng EH.RecExpr_Expr
        mkUpd r = rngLift rng EH.Expr_Rec (mk r nm updE)

ehRowRecPatExprUpd :: Range -> nm -> (EH.RecPatExpr -> nm -> EH.PatExpr -> EH.RecPatExpr) -> EH.PatExpr -> EH.PatExpr -> EH.PatExpr
ehRowRecPatExprUpd rng nm mk updE recE
  = case recE of
%%[[7
      EH.PatExpr_Rec r
%%][99
      EH.PatExpr_Rec _ r
%%]]
        -> mkUpd  r
      _ -> mkUpd (r2e recE)
  where r2e     = rngLift rng EH.RecPatExpr_Expr
        mkUpd r = rngLift rng EH.PatExpr_Rec (mk r nm updE)
%%]

%%[7.ehRowRowTyExprUpd hs
ehRowRowTyExprUpd :: Range -> nm -> (EH.RowTyExpr -> nm -> EH.TyExpr -> EH.RowTyExpr) -> EH.TyExpr -> EH.TyExpr -> EH.TyExpr
ehRowRowTyExprUpd rng nm mk updE recE
  = case recE of
%%[[7
      EH.TyExpr_Row r
%%][99
      EH.TyExpr_Row _ r
%%]]
        -> mkUpd  r
      _ -> mkUpd (rngLift rng EH.RowTyExpr_Empty)
  where mkUpd r = rngLift rng EH.TyExpr_Row (mk r nm updE)
%%]

%%[9.ehRowRowTyExprUpd -7.ehRowRowTyExprUpd hs
ehRowRowTyExprUpd :: Range -> nm -> (EH.RowTyExpr -> nm -> EH.TyExpr -> EH.RowTyExpr) -> EH.TyExpr -> EH.TyExpr -> EH.TyExpr
ehRowRowTyExprUpd rng nm mk updE recE
  = case recE of
%%[[9
      EH.TyExpr_Row r
%%][99
      EH.TyExpr_Row _ r
%%]]
        -> mkUpd  r
%%[[9
      EH.TyExpr_Var v
%%][99
      EH.TyExpr_Var _ v
%%]]
        -> mkUpd (rngLift rng EH.RowTyExpr_Var v)
      _ -> mkUpd (rngLift rng EH.RowTyExpr_Empty)
  where mkUpd r = rngLift rng EH.TyExpr_Row (mk r nm updE)
%%]

%%[7
ATTR RowRecordExpressionUpdates [ | | eh USE {:} {[]}: {[EH.Expr -> EH.Expr]} ]

ATTR RowRecordExpressionUpdate [ | | eh: {EH.Expr -> EH.Expr} ]

SEM RowRecordExpressionUpdate
    | Extends
        lhs         .   eh          =   ehRowRecExprUpd @range @name (rngLift @range EH.RecExpr_Ext) @expression.eh
    | Update
        lhs         .   eh          =   ehRowRecExprUpd @range @name (rngLift @range EH.RecExpr_Upd) @expression.eh

ATTR RowRecordPatternBindings [ | | eh USE {:} {[]}: {[EH.PatExpr -> EH.PatExpr]} ]

ATTR RowRecordPatternBinding [ | | eh: {EH.PatExpr -> EH.PatExpr} ]

SEM RowRecordPatternBinding
    | Binding
        lhs         .   eh          =   ehRowRecPatExprUpd @range @name (rngLift @range EH.RecPatExpr_Ext) @pattern.eh

ATTR RowTypeUpdates [ | | eh USE {:} {[]}: {[EH.TyExpr -> EH.TyExpr]} ]

ATTR RowTypeUpdate [ | | eh: {EH.TyExpr -> EH.TyExpr} ]

SEM RowTypeUpdate
    | Extends
        lhs         .   eh          =   ehRowRowTyExprUpd @range @name (rngLift @range EH.RowTyExpr_Ext) @type.eh
%%]

%%[7
ATTR RecordPatternBindings [ | | eh USE {:} {[]}: {[EH.DataFieldPatExpr -> EH.DataFieldPatExpr]} ]

ATTR RecordPatternBinding [ | | eh: {EH.DataFieldPatExpr -> EH.DataFieldPatExpr} ]

SEM RecordPatternBinding
    | Binding
        lhs         .   eh          =   \df -> rngLift @range EH.DataFieldPatExpr_Ext df @fldrefname @pattern.eh
    | Pun
        lhs         .   eh          =   \df -> rngLift @range EH.DataFieldPatExpr_Ext df @fldrefname (rngLift @range EH.PatExpr_Var @refname)
%%]

%%[1
ATTR FunctionBindings [ | | eh USE {:} {[]}: {[EH.Decl]} ]

ATTR FunctionBinding [ | | eh: {EH.Decl} ]

SEM FunctionBinding
    | FunctionBinding
        lhs         .   eh          =   let (h,t) = hdAndTl @lefthandside.eh
                                        in  rngLift @range EH.Decl_Val h						-- this def is not used, instead it is constructed via IdAsp_Val_Fun
                                              (foldr (rngLift @range EH.Expr_Lam)
%%[[1
                                                     @righthandside.eh
%%][4
                                                     (@lefthandside.ehTyMk @righthandside.eh)
%%]]
                                                     t)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% LHS, RHS for value bindings     
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[2 hs
-- | enforce monomorphism
ehMkEnforceMono :: Range -> Bool -> EH.Expr -> EH.Expr
ehMkEnforceMono r True e = rngLift r EH.Expr_TypeAs False (rngLift r EH.TyExpr_Mono) e
ehMkEnforceMono _ _    e =                                                     e
%%]

%%[1
ATTR LeftHandSide [ | | eh: {[EH.PatExpr]} ]

SEM LeftHandSide
    | Function
        lhs         .   eh          =   rngLift @range EH.PatExpr_Var
%%[[1
                                                @refname
%%][50
                                                (@lhs.patchEhNmInInstance @refname)
%%]]
                                          : @patterns.eh
    | Infix
        lhs         .   eh          =   [ rngLift @range EH.PatExpr_Var
%%[[1
                                                  @refname
%%][50
                                                  (@lhs.patchEhNmInInstance @refname)
%%]]
                                        , @leftPattern.eh
                                        , @rightPattern.eh
                                        ]
    | Parenthesized
        lhs         .   eh          =   @lefthandside.eh ++ @patterns.eh
%%]
%%[4
    | Typed
        lhs         .   eh          =   @lefthandside.eh
%%]

%%[4
ATTR LeftHandSide [ | | ehTyMk: {EH.Expr -> EH.Expr} ]

SEM LeftHandSide
    | Typed
        lhs         .   ehTyMk      =   rngLift @range EH.Expr_TypeAs True @type.eh
    | * - Typed
        lhs         .   ehTyMk      =   id
%%]

%%[1
ATTR RightHandSide [ | | eh: {EH.Expr} ]

SEM RightHandSide
    | Expression
        lhs         .   eh          =   @mkSccLet
%%[[2
                                        $ ehMkEnforceMono @range @lhs.mustBeMono
%%]]
                                          @expression.eh
%%[[5
    | Guarded
        lhs         .   eh          =   @mkSccLet (foldr ($) (EH.mkError @range "guarded expr") @guardedexpressions.eh)
%%][8
    | Guarded
        lhs         .   eh          =   @mkSccLet (foldr (\(mk,failS) e -> mk failS e)
                                                         (rngLift @range EH.Expr_CaseAltFail @lhs.caseId)
                                                         (zip @guardedexpressions.eh (Set.singleton @lhs.caseId : repeat Set.empty)))
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% LHS, RHS for type bindings     
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[5
ATTR TypeLeftHandSide [ | | eh: {[EH.TyVar]} ]

SEM TypeLeftHandSide
    | Function
        lhs         .   eh          =   rngLift @range EH.TyVar_Var @name : @patterns.eh
    | Infix
        lhs         .   eh          =   [ rngLift @range EH.TyVar_Var @operator
                                        , @leftPattern.eh
                                        , @rightPattern.eh
                                        ]
    | Parenthesized
        lhs         .   eh          =   @lefthandside.eh ++ @patterns.eh
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Patterns for values
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1 hs
ehPatConApp r n as
  = rngLift r EH.PatExpr_AppTop
    $ foldl (rngLift r EH.PatExpr_App) (rngLift r EH.PatExpr_Con n) as
%%]

%%[1.ehPatProd hs
ehPatProd :: Range -> [EH.PatExpr] -> EH.PatExpr
ehPatProd r as
  = ehPatConApp r (hsnProd a) as
  where a = length as
%%]

%%[1
ATTR Patterns [ | | eh USE {:} {[]}: {[EH.PatExpr]} ]

ATTR Pattern [ | | eh: {EH.PatExpr} ]
%%]

%%[1
SEM Pattern
    | Literal
        lhs         .   eh          =   let 
%%[[1
                                            mkc r = rngLift r EH.PatExpr_CConst
%%][97
                                            mkc r = \c -> mke r (rngLift r EH.Expr_CConst c, Just $ SrcConst_Char c)
                                            mke r = uncurry (rngLift r EH.PatExpr_Expr)
%%]]
                                        in  case @literal.eh of
                                              Literal_Char   r   s -> mkc r $ head s
%%[[1
                                              Literal_Int    r   s -> rngLift r EH.PatExpr_IConst (@sign * read s)
%%][97
                                              Literal_Int    r b s -> mke r (ehExpLitInt r b s @sign @litrefnames)
%%]]
%%[[5
                                              Literal_String r   s -> foldr (\c p -> ehPatConApp r (@litrefnames !! 0) [mkc r c,p]) (ehPatConApp r (@litrefnames !! 1) []) s
%%]]
%%[[97
                                              Literal_Float  r   s -> mke r (ehExpLitFloat r s @sign @litrefnames)
%%]]
    | Variable
        lhs         .   eh          =   rngLift @range EH.PatExpr_Var
%%[[1
                                                @refname
%%][50
                                                (@lhs.patchEhNmInInstance @refname)
%%]]
    | Constructor
        lhs         .   eh          =   ehPatConApp @range @refname @patterns.eh
    | Parenthesized
        lhs         .   eh          =   rngLift @range EH.PatExpr_Parens @pattern.eh
    | Tuple
%%[[1
        lhs         .   eh          =   ehPatConApp @range (hsnProd (length @patterns.eh)) @patterns.eh
%%][7
        lhs         .   eh          =   foldl (\eh (n,p) -> ehRowRecPatExprUpd @range (Just n) (rngLift @range EH.RecPatExpr_Ext) p eh)
                                              (rngLift @range EH.PatExpr_Rec $ rngLift @range EH.RecPatExpr_Empty)
                                        $ zip positionalFldNames @patterns.eh
%%]]
    | As
        lhs         .   eh          =   rngLift @range EH.PatExpr_VarAs
%%[[1
                                                @refname
%%][50
                                                (@lhs.patchEhNmInInstance @refname)
%%]]
                                                @pattern.eh
    | Wildcard
        lhs         .   eh          =   rngLift @range EH.PatExpr_Var hsnWild
	| Annotate
		loc			.	eh			=	rngLift @range EH.PatExpr_Ann @annotation.eh @pattern.eh
%%]
%%[4
    | Typed
        lhs         .   eh          =   rngLift @range EH.PatExpr_TypeAs @type.eh @pattern.eh
%%]
%%[5
    | InfixConstructor
        lhs         .   eh          =   ehPatConApp @range @refname [@leftPattern.eh,@rightPattern.eh]
    | List
        lhs         .   eh          =   foldr (\l r -> ehPatConApp @range (@refnames !! 0) [l,r]) (appCon (@refnames !! 1)) @patterns.eh
%%]
%%[7
    | Record
        lhs         .   eh          =   rngLift @range EH.PatExpr_DataFields $ foldl (flip ($)) (rngLift @range EH.DataFieldPatExpr_Con @refname) @recordPatternBindings.eh
    | RowRecordBinding
        lhs         .   eh          =   foldl (flip ($)) @pattern.eh @rowRecordPattternBindings.eh
    | RowRecordEmpty
        lhs         .   eh          =   rngLift @range EH.PatExpr_Rec (rngLift @range EH.RecPatExpr_Empty)
%%]
%%[8
    | Irrefutable
        lhs         .   eh          =   rngLift @range EH.PatExpr_Irrefutable @pattern.eh
    | Bang
        lhs         .   eh          =   rngLift @range EH.PatExpr_Bang        @pattern.eh
%%]
%%[55
    | Successor                    -- n+k patterns        
        lhs         .   eh          =   rngLift @range XX
        name                     : Name
        literal                  : Literal -- only integers allowed here
-- Helium
    | NegateFloat
        lhs         .   eh          =   rngLift @range XX
        literal                  : Literal -- only numbers allowed here
%%]
                                              Literal_String r   s -> mke r $ rngLift r EH.Expr_SConst s

%%[12
ATTR ContextedPatterns [ | | eh USE {:} {[]}: {[(EH.PatExpr,EH.PrExpr)]} ]

ATTR ContextedPattern [ | | eh: {(EH.PatExpr,EH.PrExpr)} ]

SEM ContextedPattern
    | Contexted
        lhs         .   eh          =   (@pattern.eh,@context.eh)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Patterns for types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[5
ATTR TypePatterns [ | | eh USE {:} {[]}: {[EH.TyVar]} ]

ATTR TypePattern [ | | eh: {EH.TyVar} ]
%%]

%%[5
SEM TypePattern
    | Variable
        lhs         .   eh          =   rngLift @range EH.TyVar_Var @refname
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Case ID, required for CaseAltFail to know for which case it fails
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[8
ATTR
  AllExpression AllAlternative AllGuardedExpression AllFunctionBinding AllDeclarationPlain
    [ caseId: UID | | ]

SEM Expression
    | Case
        loc         .   caseId      =   @lUniq
		loc			.	lUniq		:	UNIQUEREF gUniq

SEM FunctionBinding
    | FunctionBinding
        loc         .   caseId      =   @lUniq

SEM Declaration
    | PatternBinding
        loc         .   caseId      =   @lUniq

SEM Body
    | Body
        loc         .   caseId      =   uidStart
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Annotations          
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1
ATTR TypeAnnotation [ | | eh: {EH.TyExprAnn} ]

SEM TypeAnnotation
%%[[1
    | Empty
		loc			.	eh			=	EH.TyExprAnn_Empty
%%][5
    | Strict
		loc			.	eh			=	EH.TyExprAnn_Empty
%%][(8 codegen)
    | Strict
        loc         .   eh          =   EH.TyExprAnn_Strictness (Strictness_Strict)
    | AnnotationName
        loc         .   eh          =   case show @name of
                                          "strict"    ->  EH.TyExprAnn_Strictness (Strictness_Strict)
                                          "nonStrict" ->  EH.TyExprAnn_Strictness (Strictness_NonStrict)
                                          _           -> EH.TyExprAnn_Empty
    | AnnotationVar
        loc         .   eh          =   case show @name of
                                          "strictness" -> EH.TyExprAnn_Strictness (Strictness_Var @var)
                                          _            -> EH.TyExprAnn_Empty
%%]]
%%]

%%[1
ATTR PatternAnnotation [ | | eh: {EH.PatExprAnn} ]

SEM PatternAnnotation
	| Empty
		loc			.	eh			=	EH.PatExprAnn_Empty
%%]

%%[1
ATTR ExpressionAnnotation [ | | eh: {EH.ExprAnn} ]

SEM ExpressionAnnotation
	| Empty
		loc			.	eh			=	EH.ExprAnn_Empty
%%]

%%[6
ATTR KindAnnotation [ | | eh: {EH.KiExprAnn} ]

SEM KindAnnotation
	| Empty
		loc			.	eh			=	EH.KiExprAnn_Empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Basics          
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1
ATTR Literal [ | | eh: SELF ]
%%]

%%[1
ATTR Strings [ | | eh USE {:} {[]}: {[String]} ]
%%]
ATTR MaybeInt [ | | eh USE {`const`} {Nothing}: {Maybe Int} ]
ATTR MaybeString [ | | eh USE {`const`} {Nothing}: {Maybe String} ]

