%%[(8 counting) hs module {%{EH}CountingAnalysis}
%%]

%%[(8 counting) hs import(Data.Set (Set),qualified Data.Set as S,Data.Map (Map),qualified Data.Map as M)
%%]

%%[(8 counting) hs import({%{EH}Base.HsName (HsName, hsnIsNr)}, {%{EH}Core}, {%{EH}CodeGen.Tag (CTag)})
%%]

%%[(8 counting) hs import(UHC.Util.Binary, UHC.Util.Serialize)
%%]

%%[(8 counting) hs import(Control.Monad)
%%]

%%[(8 counting) hs import(qualified Data.Sequence as Seq, qualified Data.Foldable as Fold)
%%]

%%[(8 counting) hs import({%{EH}Base.Target (FFIWay)}, {%{EH}Foreign (ForeignEnt)}, {%{EH}Ty (Ty)})
%%]

%%[(8 counting) ag import({CountingAnalysis/AbsSyn})
-- optpragmas
-- {
-- {-# LANGUAGE TypeFamilies #-}
-- {-# LANGUAGE RankNTypes #-}
-- {-# LANGUAGE MultiParamTypeClasses #-}
-- {-# LANGUAGE FunctionalDependencies #-}
-- {-# LANGUAGE DeriveFunctor #-}
-- {-# LANGUAGE TemplateHaskell #-}
-- }
%%]

%%[(8 counting) hs

singleC :: Constraint -> Constraints
singleC x =[x]

%%]

%%[(8 counting) hs
type AnnSol = Map HsName Annotation
type TySol = Map HsName Type
type SchemeSol = Map HsName Scheme
type PartSolution = Map HsName (Set AnnVal)
data Solution = Solution 
  { _annSol :: AnnSol
  , _tySol :: TySol
  , _schemeSol :: SchemeSol
  }
  deriving (Eq, Show)
  
emptySolution = Solution
  { _annSol = M.empty
  , _tySol = M.empty
  , _schemeSol = M.empty
  }

type Imports = Map HsName Scheme
type Exports = Set HsName
type BindingEnv = Env
%%]

%%[(8 counting) ag
DERIVING *
  : Typeable, Show, Generic

DERIVING Annotation Type AnnPrim Scheme RhoType EtaType RhoScheme 
  EtaScheme Constraint ConstraintAnn ConstraintEq Field
  : Eq, Ord, Data

%%]

%%[(8 counting) hs
type Var = Int
type HsNames = [HsName]
type AnnVal = Set AnnPrim
type AnnotationValue = AnnVal

annBot' = S.empty
annBot = Annotation_Val annBot'

annZero' = S.singleton AnnPrim_Zero
annZero = Annotation_Val annZero'

annOne' = S.singleton AnnPrim_One
annOne = Annotation_Val annOne'

annW' = S.singleton AnnPrim_Infinity
annW = Annotation_Val annW'

annTop' = S.fromList [AnnPrim_Zero, AnnPrim_One, AnnPrim_Infinity]
annTop = Annotation_Val annTop'

annPow :: AnnVal -> Set AnnVal
annPow = S.fromList . map (S.fromList) . annPow' . S.toList
  where annPow' [] = [[]]
        annPow' (x:xs) = p ++ map (x:) p
          where p = annPow' xs

annPowWithoutEmpty :: AnnVal -> Set AnnVal
annPowWithoutEmpty = S.delete (S.empty) . annPow

type UsageAnnotation = Annotation
type DemandAnnotation = Annotation

type family UType a
type instance UType EtaType = Type
type instance UType EtaScheme = Scheme
type instance UType RhoType = Type
type instance UType RhoScheme = Scheme
type instance UType (GEta a) = a
type instance UType (GRho a) = a

data GEta a = GEta a Annotation
  deriving (Show, Ord, Eq, Functor)
data GRho a  = GRho (GEta a) Annotation
  deriving (Show, Ord, Eq, Functor)

class Eta a where
  getType :: a -> UType a
  getUsage :: a -> Annotation
  toGEta :: a -> GEta (UType a)
  toGEta a = GEta (getType a) (getUsage a)
  fromGEta :: GEta (UType a) -> a

class Eta a => Rho a where
  getDemand :: a -> DemandAnnotation
  toGRho :: a -> GRho (UType a)
  toGRho a = GRho (toGEta a) (getDemand a)
  fromGRho :: GRho (UType a) -> a

instance Eta (GEta a) where
  getType (GEta a _) = a
  getUsage (GEta _ u) = u
  fromGEta = id

instance Eta (GRho a) where
  getType (GRho e _) = getType e
  getUsage (GRho _ u) = u
  fromGEta = undefined

instance Rho (GRho a) where
  getDemand (GRho _ d) = d
  fromGRho = id

instance Eta EtaType where
  getType (EtaType_Eta t _) = t
  getUsage (EtaType_Eta _ u) = u
  fromGEta (GEta t u) = EtaType_Eta t u

instance Eta EtaScheme where
  getType (EtaScheme_Eta t _) = t
  getUsage (EtaScheme_Eta _ u) = u
  fromGEta (GEta s u) = EtaScheme_Eta s u

instance Eta RhoType where
  getType (RhoType_Rho e _) = getType e
  getUsage (RhoType_Rho e _) = getUsage e
  fromGEta = undefined

instance Eta RhoScheme where
  getType (RhoScheme_Rho e _) = getType e
  getUsage (RhoScheme_Rho e _) = getUsage e
  fromGEta = undefined

instance Rho RhoType where
  getDemand (RhoType_Rho _ d) = d
  fromGRho (GRho e d) = RhoType_Rho (fromGEta e) d

instance Rho RhoScheme where
  getDemand (RhoScheme_Rho _ d) = d
  fromGRho (GRho e d) = RhoScheme_Rho (fromGEta e) d
  
%%]

Serialize
%%[(8 counting) hs
instance Serialize AnnPrim where
instance Serialize Annotation where
instance Serialize Type where
instance Serialize EtaType where
instance Serialize RhoType where
instance Serialize EtaScheme where
instance Serialize RhoScheme where
instance Serialize Field where
instance Serialize Scheme where
instance Serialize Constraint where
instance Serialize ConstraintAnn where
instance Serialize ConstraintEq where  
%%]