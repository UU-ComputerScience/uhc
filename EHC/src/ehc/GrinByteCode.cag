%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Grin ByteCode
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs module {%{EH}GrinByteCode} import({%{EH}Base.Common},{%{EH}GrinCode},qualified {%{EH}Config} as Cfg,{%{EH}GrinCode.Pretty})
%%]

%%[(8 codegen grin) hs import({%{EH}CodeGen.BasicAnnot}) export(module {%{EH}CodeGen.BasicAnnot})
%%]

%%[(8 codegen grin) hs import(UHC.Util.Utils,UHC.Util.Pretty as Pretty,Data.Bits,Data.Maybe,qualified UHC.Util.FastSeq as Seq,qualified Data.Map as Map)
%%]

%%[(8 codegen grin) hs import({%{EH}Base.HsName.Builtin},{%{EH}CodeGen.BuiltinSizeInfo},{%{EH}Opts})
%%]

%%[(8 codegen grin) hs import({%{EH}CodeGen.Bits} as Binary)
%%]

%%[(8 codegen grin) hs import({%{EH}CodeGen.ValAccess} as VA) export(module VA)
%%]
%%[(8 codegen grin) hs import({%{EH}CodeGen.Const} as Const)
%%]

%%[(8 codegen grin) hs export(AGItf(..),Module(..),Instr(..), Instrs, Meta(..))
%%]

%%[(8 codegen grin) hs export(InsOp_LocE(..), InsOp_LocB(..), InsOp_LocODst(..), InsOp_LocOSrc(..), InsOp_TyOp(..), InsOp_DataOp(..), InsOp_ImmSz(..), InsOp_Deref(..), InsOp_DerefB(..), Imm(..))
%%]

%%[(8 codegen grin) ag import({GrinByteCode/AbsSyn})
%%]

%%[(50 codegen grin) hs import({%{EH}LamInfo})
%%]

%%[(50 codegen grin) hs import(Control.Monad)
%%]
%%[(50 codegen grin) hs import(UHC.Util.Serialize)
%%]

%%[(9999 codegen grin) hs import({%{EH}Base.ForceEval})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Configuration like constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Nr of words of basic values, both boxed and unboxed
20070904: Not yet used consistently, will it change anyway?

%%[(8 codegen grin) hs export(nrValWords)
nrValWords :: Int
nrValWords = 1
%%]

Nr of words occupied by header in node

%%[(8 codegen grin) hs export(nrNodeHdrWords)
nrNodeHdrWords :: Int
nrNodeHdrWords = 1
%%]

Nr of words required for call return info:
return address + saved bp

%%[(8 codegen grin) hs export(nrCallRetWords)
nrCallRetWords :: Int
nrCallRetWords = 2
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% GrValIntro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(GrValIntro)
-- | Specific instantiation for bytecode
type GrValIntro = GrValIntro' () () () () () -- tag ty varref datafldref tupfldref
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code location
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(CodeAbsLoc,CodeRelOff)
type CodeAbsLoc = Int		-- absolute location
type CodeRelOff = Int		-- relative location
%%]
codeLocNil :: CodeAbsLoc
codeLocNil = -1

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Labels
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(LabelId,newLabelId)
type LabelId = Int

newLabelId :: GBState -> (GBState,LabelId)
newLabelId st = (st {gbstLbl = l+1},l)
  where l = gbstLbl st
%%]

%%[(8 codegen grin) hs export(LabelLocMp,labelLocAdd,labelLocNew)
type LabelLocMp = Map.Map LabelId CodeAbsLoc

labelLocAdd :: LabelId -> CodeAbsLoc -> LabelLocMp -> LabelLocMp
labelLocAdd lbl loc m = Map.insert lbl loc m

labelLocNew :: GBState -> CodeAbsLoc -> LabelLocMp -> (GBState,LabelId,LabelLocMp)
labelLocNew lbl loc m
  = (next,lbl',Map.insert lbl' loc m)
  where (next,lbl') = newLabelId lbl
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional datastructures, not incorporated as AST
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Instruction sequence
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(InsSeq)
type InsSeq = Seq.FastSeq Instr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% String constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(StringConst'(..),StringConst)
data StringConst' a
  = StringConst a
  deriving(Eq,Ord, Show)

type StringConst = StringConst' String
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Reference to defining location in code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(LocRef(..),lrefIsLabel)
lrefIsLabel :: LocRef -> Bool
lrefIsLabel (LocRef_CodeEntry     _) = False
lrefIsLabel _                        = True

data LocRef
  = LocRef_CodeEntry    { lrefId :: !Int     }       -- resolved at initialization runtime, translates to
  | LocRef_Label        { lrefId :: !LabelId }       -- resolved before runtime, translates to offsets
  | LocRef_EndSwitch    { lrefId :: !LabelId }       -- as label, but we know it is the end of a switch
  | LocRef_CaseArm      							 -- as label, but with tag of case arm included, for optional use further down the pipeline
                        { lrefId  :: !LabelId
                        , lrefTag :: !Int
                        }       
  deriving (Eq,Ord,Show)
%%]

%%[(8 codegen grin) hs
instance PP LocRef where
  pp (LocRef_CodeEntry c) = "_FunLbl_"                     >|< c
  pp (LocRef_Label     l) = "_Lbl_"                        >|< l
  pp (LocRef_EndSwitch l) = "_EndSwitchLbl_"               >|< l
  pp (LocRef_CaseArm l c) = "_CaseLbl_" >|< l
%%]

%%[(8 codegen grin) hs export(StackDepth)
type StackDepth = Int
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% GC permission: encoding, utilities
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
-- 1 bit No(0)/Yes(1) permit GC tracing, see also ststGCEncoding
gcpermitEncoding :: GCPermit -> Int
gcpermitEncoding GCPermit_Not = 0
gcpermitEncoding _            = 1
%%]

The BP relative stack locations about which GC permission is known

%%[(8 codegen grin) hs export(GCPermitMp)
type GCPermitMp = Map.Map StackDepth GCPermit
%%]

%%[(8 codegen grin) hs export(gcpermitMpRestrict)
-- restrict to offset
gcpermitMpRestrict :: StackDepth -> GCPermitMp -> GCPermitMp
gcpermitMpRestrict maxOffset = Map.filterWithKey (\o _ -> o <= maxOffset)
%%]

%%[(8 codegen grin) hs
-- distinguish only between GCPermit_Not and the rest
gcpermitMpCanonicalize :: GCPermitMp -> GCPermitMp
gcpermitMpCanonicalize
  = Map.map m
  where m x@GCPermit_Not = x
        m _              = GCPermit_Must
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Stack state
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

StackState describes how the stack for a single function body:
- the depth of the stack, i.e. that which is in use
- the GC permission for each word on the stack

StackState grows and shrinks with the stack,
in contrast to GBState which simulates execution/codegen and is threaded

%%[(8 codegen grin) hs export(StackState(..),emptyStackState)
data StackState
  = StackState
      { ststDepth		:: !StackDepth
      , ststGCPermitMp	:: !GCPermitMp
      }
  deriving Show

instance PP StackState where
  pp  = pp . show

emptyStackState :: StackState
emptyStackState = StackState 0 Map.empty
%%]

%%[(8 codegen grin) hs export(ststFromDep,ststFromPerm,ststFromDepPerm)
ststFromDep :: StackDepth -> StackState
ststFromDep d = emptyStackState { ststDepth = d }

ststFromPerm :: [StackDepth] -> GCPermit -> StackState
ststFromPerm offs perm = emptyStackState { ststGCPermitMp = Map.fromList [ (o,perm) | o<-offs ] }

ststFromDepPerm :: StackDepth -> GCPermit -> StackState
ststFromDepPerm d perm = ststFromPerm [0..d-1] perm `ststInc` ststFromDep d
%%]

%%[(8 codegen grin) hs export(ststPatchDepPerm,ststPatchTOSGCNot)
-- patch top elements
ststPatchDepPerm :: StackDepth -> GCPermit -> StackState
ststPatchDepPerm d perm = ststFromPerm [-d .. -1] perm

ststPatchTOSGCNot :: StackState
ststPatchTOSGCNot = ststPatchDepPerm 1 GCPermit_Not 
%%]

%%[(8 codegen grin) hs export(ststInc,ststIncDep,ststIncPerm)
infixl 3 `ststInc`, `ststIncDep`

-- right operand increments left
ststInc :: StackState -> StackState -> StackState
ststInc st stBy
  = st { ststDepth      = dep + ststDepth stBy
       , ststGCPermitMp = Map.mapKeys (+dep) (ststGCPermitMp stBy) `Map.union` gmp
       }
  where dep = ststDepth      st
        gmp = ststGCPermitMp st

ststIncDep :: StackState -> StackDepth -> StackState
ststIncDep st d = st `ststInc` ststFromDep d

ststIncPerm :: StackState -> ([StackDepth],GCPermit) -> StackState
ststIncPerm st (o,p) = st `ststInc` ststFromPerm o p
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% GC info encoding for StackState
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

GCStackInfo describes what can & cannot be GC'ed.
It consists of an array of descriptors each describing a range of the stack.
All descriptors together describe consecutive ranges, so a descriptor ends where the next begins.
Each range has the same GC behavior.

%%[(8 codegen grin) hs export(GCStackInfo'(..),GCStackInfo)
data GCStackInfo' x
  = GCStackInfo
      { gcstinfoSz		:: !Int			-- the size of the stack covered
      , gcstinfoPerms	:: !x			-- descriptors for GC permission, encoded as 7 bits size, 1 bit No(0)/Yes(1) permit GC tracing
      }
  | GCStackInfo_None
  deriving (Eq,Ord,Show)

type GCStackInfo = GCStackInfo' [Int]
%%]

%%[(8 codegen grin) hs
ststGCEncoding :: StackState -> GCStackInfo
ststGCEncoding stState
  = GCStackInfo sz encs
  where sz = ststDepth stState
        fillGaps off sz []
             | sz > 0      = [(off,sz,GCPermit_Must)]
             | otherwise   = []
        fillGaps off sz (p@(poff,psz,_):ps)
             | poff >  off = [(off,poff-off,GCPermit_Must)] ++ [p] ++ ps'
             | poff == off = [p] ++ ps'
             | otherwise   = panic $ "GrinByteCode.ststGCEncoding: sz/poff/off " ++ show sz ++ "/" ++ show poff ++ "/" ++ show off
             where off' = poff + psz
                   ps' = fillGaps off' (sz - off') ps
        encs
           = concatMap
               (\(_,psz,perm)
                  -> let n = entierUpShrBy max psz
                         enc  = gcpermitEncoding perm
                         mk x = x `shiftL` 1 .|. enc
                     in  replicate (n-1) (mk max) ++ [mk (psz - (n-1) * max)]
               )
           $ map (\l@((o,_,p) : _) -> (o,sum $ map (\(_,len,_) -> len) l,p))
           $ groupOn (\(_,_,p) -> p)
           $ fillGaps 0 sz
           $ map (\l@((o,p) : _) -> (o,length l,p))
           $ consecutiveBy (\(o1,p1) (o2,p2) -> o1 == o2-1 && p1 == p2)
           $ sortOnLazy fst
           $ Map.toList
           $ gcpermitMpCanonicalize
           $ ststGCPermitMp stState
        logmax = 7
        max = pow2 logmax - 1
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% C Call encoding info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(CCallEncInfo'(..),CCallEncInfo)
data CCallEncInfo' x
  = CCallEncInfo
      { ccencinfoSizes	:: !x			-- wrapping/encoding of C call, between BC & C stacks
      }
  deriving (Eq,Ord,Show)

type CCallEncInfo = CCallEncInfo' [BasicSize]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Function Info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(FunctionInfoFlag(..),FunctionInfo'(..),FunctionInfo)
data FunctionInfoFlag
  = FunctionInfoFlag_None
  | FunctionInfoFlag_1stArgIsStackTrace					-- 1st arg is explicit stacktrace
  deriving Show

instance PP FunctionInfoFlag where
  pp = pp . show

data FunctionInfo' x
  = FunctionInfo
      { funinfoKey				:: !x					-- name of function, later the index
      , funinfoNm				:: !HsName				-- name of function, used to build exported/propagated mapping to above index
      , funinfoMaxStackSz		:: !StackDepth			-- max stack size used by function, in words (in final bytecode in bytes)
      , funinfoFlags			:: [FunctionInfoFlag]	-- optional info, config, etc
      }

instance Eq (FunctionInfo' x) where
  i1 == i2 = funinfoNm i1 == funinfoNm i2

instance Ord (FunctionInfo' x) where
  i1 `compare` i2 = funinfoNm i1 `compare` funinfoNm i2

type FunctionInfo = FunctionInfo' String

emptyFunctionInfo :: FunctionInfo
emptyFunctionInfo = FunctionInfo "" hsnUnknown 1 []
%%]

%%[(50 codegen grin) hs export(FunctionInfoExportMp)
type FunctionInfoExportMp = Map.Map HsName GrinByteCodeLamInfo			-- to index into table of FunctionInfos, to be included in HIInfo
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Call Info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(CallInfoKind(..))
-- the order must correspond to the first defines of CallInfo_Kind_XXX in rts/base/types.h
data CallInfoKind
  = CallInfoKind_Call             -- normal call
  | CallInfoKind_Tail             -- tail call
  | CallInfoKind_Eval             -- eval call
  | CallInfoKind_EvalWrap         -- eval call internal wrapper
  | CallInfoKind_TailEv           -- tail eval call
  | CallInfoKind_Apply            -- apply call
  | CallInfoKind_CCall            -- C call
  | CallInfoKind_EvCont           -- eval update continuation
  | CallInfoKind_ApCont           -- apply continuation
  | CallInfoKind_PApCont          -- partial apply continuation
  | CallInfoKind_Hdlr             -- exception handler installment
  | CallInfoKind_TailEval         -- tail eval call
  deriving (Enum,Eq,Ord,Show)
%%]

%%[(8 codegen grin) hs
data CallInfoExtra
  = CallInfoExtra_CCall [BasicSize]		-- type: (res : args)
  | CallInfoExtra_None
  deriving (Eq,Ord,Show)
%%]

%%[(8 codegen grin) hs
instance PP CallInfoExtra where
  pp (CallInfoExtra_CCall t) = pp $ show $ concatMap basicGrinSizeCharEncoding t
  pp CallInfoExtra_None      = pp "NULL"
%%]

%%[(8 codegen grin) hs export(CallInfo'(..),CallInfo,CallInfoCall)
type MbStrInx  = Maybe Int
type MbCIStr   = Maybe String
type MbCIStrNm = Maybe (Maybe String,HsName)

data CallInfo' info str
  = CallInfo
      { ciKind			:: !CallInfoKind
      , ciMbKey	        :: !(Maybe str)					-- string (or index), if any
      , ciGCStackInfo 	:: !info
      , ciExtra			:: !CallInfoExtra
      }
  deriving (Eq,Ord,Show)

type CallInfo     = CallInfo' GCStackInfo StringConst
type CallInfoCall = CallInfo' GCStackInfo (Maybe StringConst,HsName)

%%]

%%[(8 codegen grin) hs export(mkCICall)
mkCIExtra :: CallInfoExtra -> CallInfoKind -> MbCIStr -> GCStackInfo -> CallInfo
mkCIExtra e k i gc = CallInfo k (fmap StringConst i) gc e

mkCI :: CallInfoKind -> MbCIStr -> CallInfo
mkCI k i = mkCIExtra CallInfoExtra_None k i GCStackInfo_None

mkCIEval, mkCITailEval, mkCIApply :: MbCIStr -> CallInfo
mkCIEval       = mkCI                              CallInfoKind_Eval  
mkCITailEval   = mkCI                              CallInfoKind_TailEval  
mkCIApply      = mkCI                              CallInfoKind_Apply 

mkCICall :: MbCIStrNm -> CallInfoCall
mkCICall i = CallInfo CallInfoKind_Call (fmap (\(i,n) -> (fmap StringConst i,n)) i) GCStackInfo_None CallInfoExtra_None

mkCICCall :: [BasicSize] -> MbCIStr -> GCStackInfo -> CallInfo
mkCICCall e    = mkCIExtra (CallInfoExtra_CCall e) CallInfoKind_CCall
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Entry point info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(EntryInfo)
type EntryInfo = EntryInfo' StringConst
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Link Chain
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

20090923. New representation of linking info. Instead of separate tables
pointing to locations in the code, this variant uses a linked list of
entries inside the code. This is much more C code space efficient,
because no separate tables are required and the list can be overwritten
with the actual entries.

Each entry in the code consists of one word only, which both encodes the
next entry and the payload. If this does not fit, an entry in an
indirection table is used.

Each entry is keyed by a kind and location (label), later to be translated
to a separate list for each kind, each ordered by code location of the labels,
where the next entry is encoded by an offset relative to the current.

The definition of LinkChainKind must corespond with the defines
GB_LinkChainKind_XXX in src/rts/base/types.

%%[(8 codegen grin) hs export(LinkChainKind(..),LinkChainKey(..),LinkChainId(..),linkChainId,LinkChainKeyInfo,lckeyMbLbl,lckeyMbLoc)
data LinkChainEncoding
  = LinkChainEncoding_Ind			-- to a separate table, the payload now is the index into that table
  | LinkChainEncoding_16_10			-- inline, 16(32) bits for inx, 10(26) for offset
  deriving (Enum)

data LinkChainKind
  = LinkChainKind_None
  | LinkChainKind_GCInfo			-- ref to GC Info
  | LinkChainKind_Const				-- ref to constant
  | LinkChainKind_Code				-- ref to global code entrypoint
  | LinkChainKind_Offset			-- ref to label
  | LinkChainKind_Offsets			-- ref to labels
  | LinkChainKind_CallInfo			-- ref to callinfo
  | LinkChainKind_StringConst		-- ref to C string start address
  | LinkChainKind_FunctionInfo		-- ref to function info
%%[[50
  | LinkChainKind_ImpEntry			-- ref to imported code entrypoint
%%]]
  deriving (Eq,Ord,Enum,Show)

data LinkChainId
  = LinkChainId_Lbl !LabelId
  | LinkChainId_Loc !CodeAbsLoc
  deriving (Eq,Ord,Show)

linkChainId :: (LabelId -> x) -> (CodeAbsLoc -> x) -> LinkChainId -> x
linkChainId lbl _   (LinkChainId_Lbl l) = lbl l
linkChainId _   loc (LinkChainId_Loc l) = loc l

data LinkChainKey
  = LinkChainKey
      { lckeyKind		:: !LinkChainKind
      , lckeyId			:: !LinkChainId
      }
  deriving (Eq,Ord,Show)

lckeyMbLbl :: LinkChainKey -> Maybe LabelId
lckeyMbLbl k = case lckeyId k of {LinkChainId_Lbl l -> Just l ; _ -> Nothing}

lckeyMbLoc :: LinkChainKey -> Maybe LabelId
lckeyMbLoc k = case lckeyId k of {LinkChainId_Loc l -> Just l ; _ -> Nothing}

type LinkChainKeyInfo = Int													-- info must be representable by Int
%%]

%%[(8 codegen grin) hs export(LinkChainKeyMp)
type LinkChainKeyMp      = Map.Map LinkChainKey LinkChainKeyInfo
%%]

%%[(8 codegen grin) hs
%%]
-- the 'escape' entry when it does not fit in a word
data LinkChainIndirectionEntry
  = LinkChainIndirectionEntry
      { lcind
      }

%%[(8 codegen grin) hs export(LinkChainResolvedInfo(..),LinkChainResolvedIndInfoSet,emptyLinkChainResolvedIndInfoSet)
-- when resolved we have the original info & relative offset to next entry
data LinkChainResolvedInfo = LinkChainResolvedInfo LinkChainKind LinkChainKeyInfo CodeRelOff

-- the 'escape' entries when it does not fit in a word, as reversed list + its (cached) size
type LinkChainResolvedIndInfoSet = (Int,[LinkChainResolvedInfo])

emptyLinkChainResolvedIndInfoSet :: LinkChainResolvedIndInfoSet
emptyLinkChainResolvedIndInfoSet = (0,[])
%%]

%%[(8 codegen grin) hs export(linkChainResolvedInfoEncoding)
linkChainResolvedInfoEncoding :: LinkChainResolvedIndInfoSet -> LinkChainResolvedInfo -> (Integer,LinkChainResolvedIndInfoSet)
linkChainResolvedInfoEncoding 
  = \indset i
       -> case i of
            LinkChainResolvedInfo kind info off
              | info' >= 0 && info' < p1 && off' < p2
                          -> (info' `shiftL` b1 .|. off' `shiftL` b2 .|. k kind `shiftL` b3 .|. e16_10, indset)
              | otherwise -> let (sz,inds) = indset
                             in  (toInteger sz `shiftL` b3 .|. eInd, (sz+1, i : inds))
              where info' = toInteger info
                    off'  = toInteger off
  where k :: Enum a => a -> Integer
  	k e  = toInteger $ fromEnum e
        b1 = Cfg.sizeofWordInBits `div` 2
        b3 = 2
        b2 = b3 + 4
        p1 = pow2 (Cfg.sizeofWordInBits - b1)
        p2 = pow2 (b1 - b2)
        e16_10 = k LinkChainEncoding_16_10
        eInd   = k LinkChainEncoding_Ind
%%]

%%[(8 codegen grin) hs export(LinkChainResolvedMp)
type LinkChainResolvedMp = Map.Map LinkChainKey LinkChainResolvedInfo
%%]

%%[(8 codegen grin) hs export(LinkChainEntry(..))
-- as it appears in GB code
data LinkChainEntry
  = LinkChainEntry
       { lcentryKey		:: !LinkChainKey
       , lcentryInfo	:: !LinkChainKeyInfo
       -- , lcentryInfo2	:: !LinkChainKeyInfo	-- extra info only for certain LinkChainKinds
       }
  deriving Show
%%]

%%[(8 codegen grin) hs export(linkChainConst,linkChainCode,linkChainOffset,linkChainOffsets)
linkChainEntry' :: LinkChainKind -> LabelId -> Int -> Int -> LinkChainEntry
linkChainEntry' kind lbl inx inx2 = LinkChainEntry (LinkChainKey kind (LinkChainId_Lbl lbl)) inx -- inx2

linkChainEntry :: LinkChainKind -> LabelId -> Int -> LinkChainEntry
linkChainEntry kind lbl inx = linkChainEntry' kind lbl inx 0

linkChainConst :: LabelId -> Int -> LinkChainEntry
linkChainConst = linkChainEntry LinkChainKind_Const

linkChainCode :: LabelId -> Int -> LinkChainEntry
linkChainCode = linkChainEntry LinkChainKind_Code

linkChainOffset :: LabelId -> Int -> LinkChainEntry
linkChainOffset = linkChainEntry LinkChainKind_Offset

linkChainOffsets :: LabelId -> Int -> LinkChainEntry
linkChainOffsets = linkChainEntry LinkChainKind_Offsets
%%]
linkChainGCInfo :: LabelId -> Int -> LinkChainEntry
linkChainGCInfo = linkChainEntry LinkChainKind_GCInfo

%%[(50 codegen grin) hs export(linkChainImpEntry)
linkChainImpEntry :: LabelId -> Int -> LinkChainEntry
linkChainImpEntry = linkChainEntry LinkChainKind_ImpEntry
%%]

%%[(8 codegen grin) hs export(linkChainResolvedLookup)
linkChainResolvedLookup :: LinkChainKey -> LinkChainResolvedMp -> Maybe LinkChainResolvedInfo
linkChainResolvedLookup = Map.lookup
%%]

%%[(8 codegen grin) hs export(linkChainMpResolve)
linkChainMpResolve :: LabelLocMp -> LinkChainKeyMp -> (LinkChainResolvedMp,Maybe CodeRelOff)
linkChainMpResolve labelLocMp keyMp
  = foldr (\(k,(info,mbabsloc)) (m,mbnextabsloc) ->
              let diff  = case (mbnextabsloc,mbabsloc) of
                            (Just n, Just l) -> n - l
                            _                -> 0
                  info' = case (lckeyKind k,mbabsloc) of
                            (LinkChainKind_Offset, Just l) | isJust mblblloc
                               -> fromJust mblblloc - (l + Cfg.gbLabelOffsetSize)
                               where mblblloc = Map.lookup info labelLocMp
                            _  -> info
              in  (Map.insert k (LinkChainResolvedInfo (lckeyKind k) info' diff) m, mbabsloc)
          )
          (Map.empty,Nothing)
  $ sortOnLazy (snd.snd)
  $ [ (k, (i, linkChainId (\l -> Map.lookup l labelLocMp) Just (lckeyId k)))
    | (k,i) <- Map.toList keyMp
    ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Optimisation info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(LoadCtxt(..),defaultLoadCtxt)
data LoadCtxt
  = LoadCtxt
      { lcxDoLdTOS    	:: !Bool			-- for 0 offset sp relative emit relative load (when True) or delay by emitting LoadSrc_TOS
      , lcxOmitTOSLd	:: !Bool			-- if LoadSrc_TOS is emitted allow its corresponding optimization by not loading a ref to TOS on TOS
      }

defaultLoadCtxt :: LoadCtxt
defaultLoadCtxt = LoadCtxt False False
%%]

%%[(8 codegen grin) hs export(OptimEffect(..),defaultOptimEffect)
data OptimEffect
  = OptimEffect
{- -- moved to separate transformation to eliminate redundant eval's
      { oefIsEvaluated         :: Bool
      }
-}

defaultOptimEffect :: OptimEffect
defaultOptimEffect = OptimEffect {- False -}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Environmental info for name resolution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(ValAccessG, ValAccessGamG, vaEntryInx)
type ValAccessG 	= ValAccess 	StackDepth Fld Int Int
type ValAccessGamG 	= ValAccessGam 	StackDepth Fld Int Int

vaEntryInx :: ValAccessG -> Int
vaEntryInx = fldInt . vaGlobRef
%%]

%%[(8 codegen grin).NmEnvGB hs export(NmEnvGB)
type NmEnvGB = NmEnv StackDepth Fld Int Int ()
%%]

%%[(50 codegen grin).NmEnvGB -8.NmEnvGB hs export(NmEnvGB, neLamMp, neLamMpUpd)
type NmEnvGB = NmEnv StackDepth Fld Int Int LamMp

neLamMp :: NmEnvGB -> LamMp
neLamMp = neExtra

neLamMpUpd :: LamMp -> NmEnvGB -> NmEnvGB
neLamMpUpd m e = e {neExtra = m}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Load info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(LoadSrc(..))
data LoadSrc
  = LoadSrc_TOS         
  | LoadSrc_Imm
      { ldsrcImm      	:: !Integer
      }
  | LoadSrc_Imm_Int
      { ldsrcImm      	:: !Integer
      }
  | LoadSrc_TOS_Rel
      { ldsrcOff      	:: !StackDepth
      , ldsrcNrWords 	:: Int
      }
  | LoadSrc_Reg_Rel
      { ldsrcOff      	:: !StackDepth
      , ldsrcNrWords 	:: Int
      }

instance Show LoadSrc where
  show LoadSrc_TOS = "sp[0]"
  show (LoadSrc_Imm x) = "#" ++ show x
  show (LoadSrc_Imm_Int x) = "#" ++ show x
  show (LoadSrc_TOS_Rel o s) = "sp[" ++ show o ++ ".." ++ show (o+s-1) ++ "]"
  show (LoadSrc_Reg_Rel o s) = "rr[" ++ show o ++ ".." ++ show (o+s-1) ++ "]"
%%]

%%[(8 codegen grin) hs
ldsrc2ins :: Bool -> (Instr -> Instr) -> GCPermit -> LoadSrc -> (InsSeq,StackState)
ldsrc2ins doLdTOS instrann gcPermit s
  = case s of
      {-
      LoadSrc_TOS | doLdTOS   -> ( Seq.fromList  $ ann      $ ldlm nrValWords 0, nrwd )
                  | otherwise -> ( Seq.empty                          , zero )
      -}
      LoadSrc_TOS             -> ( Seq.empty                          , zero )
      LoadSrc_TOS_Rel  o n    -> ( Seq.fromList  $ ann      $ ldlm n o, d n  )
      LoadSrc_Reg_Rel  o n    -> ( Seq.fromList  $ ann      [ l1tr (o+o') | o' <- reverse rng ]
                                 , d n
                                 )
                              where rng = [0 .. n-1]
      LoadSrc_Imm      c      -> ( Seq.singleton $ instrann $ ldc  c  , nrwd )
      LoadSrc_Imm_Int  c      -> ( Seq.singleton $ instrann $ ldi  c  , nrwd )
  where ldlm n o = replicate n (ldl o)
        -- ldrm n o = [ l1tr o' | o' <- reverse [o..o+n-1] ]	-- hardcoded 'stack grows down' assumption
        ann (h:t) = instrann h : t
        d i  = ststFromDepPerm i gcPermit
        zero = d 0
        nrwd = d nrValWords
%%]

%%[(8 codegen grin) hs
instance PP LoadSrc where
  pp = pp . show
%%]

%%[(8 codegen grin) hs export(Load(..))
data Load
  = Load
      { ldPreIns        :: !InsSeq
      , ldPreStackInc   :: !StackDepth
      , ldPreLoc        :: !LoadSrc
      , ldPostIns       :: !InsSeq
      }

loadWithPrePostFrom :: [Instr] -> StackDepth -> LoadSrc -> [Instr] -> Load
loadWithPrePostFrom pre presz s post = Load (Seq.fromList pre) presz s (Seq.fromList post)

loadWithPreFrom :: [Instr] -> StackDepth -> LoadSrc -> Load
loadWithPreFrom pre presz s = loadWithPrePostFrom pre presz s []

loadWithPre0From :: [Instr] -> LoadSrc -> Load
loadWithPre0From pre s = loadWithPreFrom pre 0 s

loadWithPost0From :: LoadSrc -> [Instr] -> Load
loadWithPost0From s post = loadWithPrePostFrom [] 0 s post

loadFrom :: LoadSrc -> Load
loadFrom s = loadWithPreFrom [] 0 s
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Named value access
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
type NmLdInfo = (Maybe ValAccessG, Load, BasicSize, GCPermit)
%%]

%%[(8 codegen grin) hs
nmLd' :: LoadCtxt -> NmEnvGB -> StackState -> GBState -> HsName -> (NmLdInfo,GBState)
nmLd' ldcxt env stState gbState nm
  = case nmEnvLookup nm env of
      mva@(Just va)
        -> case va of
             Val_Local o annot
               -> ( ( mva
                    , loadWithPrePostFrom [meta' AnnIdUse (nm >#< valAccessAnnot pp (>#<) annot >#< src)]
                                          0 src post
                    , vaAnnotBasicSize annot, vaAnnotGCPermit annot
                    )
                  , gbState
                  )
               where (src,post)
                         = case annot of
                             ValAccessAnnot_Annot (BasicAnnot_Size bsz _    BasicAnnotTagging_FromPtr   sgn)
                                                                                   -> (srcDflt Cfg.sizeofGrWord ,[untag2 sgn {-(basicSizeIsSigned bsz)-}])
                             ValAccessAnnot_Annot (BasicAnnot_Size bsz _    BasicAnnotTagging_ToPtr     _)
                                                                                   -> (srcDflt Cfg.sizeofGrWord ,[])
                             ValAccessAnnot_Annot (BasicAnnot_Size bsz _    _   _) -> (srcDflt (basicSizeInBytes bsz),[])
                             ValAccessAnnot_Annot (BasicAnnot_Dflt               ) -> (srcDflt Cfg.sizeofGrWord ,[])
                             ValAccessAnnot_Basic _ _                              -> (srcDflt Cfg.sizeofGrWord ,[])
                         where srcDflt n = offSrc (stkDepth - o) (nrByte2Word n)
             {-
             Val_NodeTagLocal o
               -> (mva,loadFrom (offSrc (stkDepth - o) nrValWords),dfltBasicSize,gbState)
             -}
             Val_NodeFldLocal o annot
               -> ( (mva,l,vaAnnotBasicSize annot,vaAnnotGCPermit annot)
                  , gbState
                  )
               where a = meta' AnnIdUse (nm >#< valAccessAnnot pp (>#<) annot >#< vaAnnotGCPermit annot)
                     l = case annot of
                           ValAccessAnnot_Annot (BasicAnnot_Size bsz _    BasicAnnotTagging_FromPtr   sgn)
                                                                                 -> loadWithPost0From (offSrc (stkDepth - o) nrValWords) [a, untag2 sgn {-(basicSizeIsSigned bsz)-}]
                           ValAccessAnnot_Annot (BasicAnnot_Size bsz _    BasicAnnotTagging_ToPtr     sgn)
                                                                                 -> loadWithPost0From (offSrc (stkDepth - o) nrValWords) [a, tag2   sgn {-(basicSizeIsSigned bsz)-}]
                           ValAccessAnnot_Annot (BasicAnnot_Size bsz _    _   _) -> loadWithPre0From [a, ldlr (stkDepth - o)] (LoadSrc_Reg_Rel nrNodeHdrWords (nrByte2Word $ basicSizeInBytes bsz))
                           _                                                     -> panic "GrinByteCode.nmLd'.Val_NodeFldLocal"
             Val_Int i
               -> ( (mva,loadFrom (LoadSrc_Imm_Int i),dfltBasicSize,GCPermit_May)
                  , gbState
                  )
             Val_GlobEntry o
               -> ( ( mva
                    , loadWithPreFrom [instrann' AnnIdUse nm $ ldg InsOp_LocB_TOS (linkChainCode codeLbl $ fldInt o)]
                                      nrValWords LoadSrc_TOS -- (offSrc 0 nrValWords)
                    , dfltBasicSize, GCPermit_Must
                    )
                  , gbState2
                  )
               where (gbState2,codeLbl) = newLabelId gbState
%%[[50
             Val_ImpEntry mo eo
               -> ( ( mva
                    , loadWithPre0From [instrann' AnnIdUse nm $ ldg InsOp_LocB_Reg (linkChainImpEntry codeLbl mo)]
                                       (LoadSrc_Reg_Rel (eo + nrNodeHdrWords) nrValWords)
                    , dfltBasicSize
                    , GCPermit_Must
                    )
                  , gbState2
                  )
               where (gbState2,codeLbl) = newLabelId gbState
%%]]
      _ -> ( (Nothing,loadWithPreFrom [instrann' AnnIdUse ("dummy ld for" >#< nm) $ ldl stkDepth] nrValWords LoadSrc_TOS {-(offSrc 0 nrValWords)-},dfltBasicSize,GCPermit_Not)
           , gbState
           )
  where offSrc off sz | off == 0 && not (lcxDoLdTOS ldcxt) = LoadSrc_TOS
                      | otherwise                          = LoadSrc_TOS_Rel off sz
        dfltBasicSize = grinBasicAnnotSize BasicAnnot_Dflt
        stkDepth = ststDepth stState
%%]

%%[(8 codegen grin) hs
vaAndLd2Ins :: LoadCtxt -> HsName -> (NmLdInfo,GBState) -> (InsSeq,StackState,GBState)
vaAndLd2Ins ldcxt nm vald
  = case vald of
      ((Just (Val_Local _ (ValAccessAnnot_Annot annot)),Load pins pdep LoadSrc_TOS postins,_,gcPermit),gbState)
        | not (lcxOmitTOSLd ldcxt)
          -> (pins Seq.:++: ins Seq.:++: postins, ststFromDep pdep `ststInc` incld, gbState)
          where (ins,incld) = ldsrc2ins False (instrann' AnnIdUse (nm >#< annot)) gcPermit (LoadSrc_TOS_Rel 0 nrValWords)
      ((_,Load pins pdep ls postins,_,gcPermit),gbState)
          -> (pins Seq.:++: ins Seq.:++: postins, ststFromDep pdep `ststInc` incld, gbState)
          where (ins,incld) = ldsrc2ins (lcxDoLdTOS ldcxt) (instrann $ show ls) gcPermit ls
%%]

%%[(8 codegen grin) hs export(nmLd)
nmLd :: LoadCtxt -> NmEnvGB -> StackState -> GBState -> HsName -> (InsSeq,StackState,GBState)
nmLd ldcxt env stState gbState nm
  = vaAndLd2Ins ldcxt nm $ nmLd' ldcxt env stState gbState nm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% GB codegen state
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Threaded, gathering state, accumulating info throughout the execution of bytecodes.
This is in contrast to StackState, which models the state of the stack, including its growth and shrink.

%%[(8 codegen grin) hs export(GBState(..),emptyGBState)
data GBState
  = GBState
      { gbstLbl			:: !LabelId
      , gbstMaxStkDepth	:: !StackDepth
      }

emptyGBState :: GBState
emptyGBState = GBState 0 0
%%]

%%[(8 codegen grin) hs export(gbstIncByStackState)
-- Increment gbstate by info from stackstate.
-- The function may be called redundantly, i.e. its implementation must be idempotent
gbstIncByStackState :: GBState -> StackState -> GBState
gbstIncByStackState g s
  = g { gbstMaxStkDepth = gbstMaxStkDepth g `max` ststDepth s
      }
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% GrVal Value introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(GrValIntroAlt(..))
data GrValIntroAlt
  = GrValIntroAlt_OnTOS     InsSeq StackState OptimEffect [BasicSize]
  | GrValIntroAlt_Delay     InsSeq StackState OptimEffect NmLdInfo
%%]

%%[(8 codegen grin) hs export(gviLd,gviLd',gviLdFold)
gviLdFold' :: EHCOpts -> GrValIntroAlt -> LoadCtxt -> NmEnvGB -> StackState -> GBState -> [GrValIntro] -> (GrValIntroAlt,GBState)
gviLdFold' opts dflt ldcxt env stState gbState introL
  = foldl ld (dflt, gbState) $ reverse $ introL
  where ld (GrValIntroAlt_OnTOS ins inc _ basicsz, gbState) intro
          = (GrValIntroAlt_OnTOS (ins Seq.:++: ins') (inc `ststInc` inc') defaultOptimEffect (basicsz' ++ basicsz), gbState2)
          where (GrValIntroAlt_OnTOS ins' inc' _ basicsz', gbState2) = gviLd opts ldcxt env (stState `ststInc` inc) gbState intro

gviLdFold :: EHCOpts -> LoadCtxt -> NmEnvGB -> StackState -> GBState -> [GrValIntro] -> (GrValIntroAlt,GBState)
gviLdFold opts = gviLdFold' opts (GrValIntroAlt_OnTOS Seq.empty emptyStackState defaultOptimEffect [])

gviLd' :: EHCOpts -> LoadCtxt -> NmEnvGB -> StackState -> GBState -> GrValIntro -> (GrValIntroAlt,GBState)
gviLd' opts ldcxt env stState gbState intro
  = ld ldcxt (GrValIntroAlt_OnTOS Seq.empty emptyStackState defaultOptimEffect []) intro
  where ld ldcxt dflt@(GrValIntroAlt_OnTOS ins dfltInc _ _) intro
          = case intro of
              GrValIntro_Nm nm
                -> (GrValIntroAlt_Delay ins dfltInc defaultOptimEffect nmLdInfo, gbState3)
                where (nmLdInfo,gbState3) = nmLd' ldcxt env stState gbState2 nm
              GrValIntro_Str s _ -- constInx
                -> (GrValIntroAlt_OnTOS (ins Seq.::+: str) (dfltInc `ststIncDep` nrValWords) defaultOptimEffect [dfltBasicSize], gbState3)
                where (gbState3,constLbl) = newLabelId gbState2
                      -- lce = linkChainConst constLbl constInx
                      -- str = ldg InsOp_LocB_TOS lce
                      str = ldstr InsOp_LocB_TOS (StringConst s)
              GrValIntro_Int i
                -> (GrValIntroAlt_Delay ins dfltInc defaultOptimEffect (Nothing,loadFrom $ LoadSrc_Imm_Int i,dfltBasicSize,GCPermit_Not), gbState)
              GrValIntro_Enum nm
                -> case mbva of
                     Just va | vaHasAnnot va
                       -> case vaAnnot va of
                            ValAccessAnnot_Annot BasicAnnot_Dflt                -> basicAnnotDflt ml
                            ValAccessAnnot_Annot (BasicAnnot_Size bsz _ BasicAnnotTagging_ToPtr sgn)
                                                                                -> basicAnnotTaggedPtr sgn {-(basicSizeIsSigned bsz)-} nm ml dfltBasicSize
                            _                                   -> panic "GrinByteCode.gviLd'.GrValIntro_Enum.Just"
                     _ -> panic "GrinByteCode.gviLd'.GrValIntro_Enum.Nothing"
                where ml@((mbva,_,_,_),_) = nmLd' ldcxt env stState gbState nm
              GrValIntro_Basic gtag nm
                -> case mbva of
                     Just va | vaHasAnnot va
                       -> case vaAnnot va of
                            ValAccessAnnot_Annot BasicAnnot_Dflt                    -> basicAnnotDflt ml
                            ValAccessAnnot_Annot (a@(BasicAnnot_Size bsz _ BasicAnnotTagging_ToPtr sgn))
                                                                                    -> basicAnnotTaggedPtr sgn {-(basicSizeIsSigned bsz)-} nm ml (grinBasicAnnotSize a)
                            ValAccessAnnot_Annot (BasicAnnot_Size bsz _ _ _)
                              -> ( GrValIntroAlt_OnTOS (ins Seq.:++: Seq.fromList [meta' AnnTag (ppGrTag gtag)] Seq.:++: tins Seq.:++: sins)
                                                       sinc defaultOptimEffect [basicsz]
                                 , gbState6 `gbstIncByStackState` stState4
                                 )
                              where (ins,inc,gbState4) = vaAndLd2Ins ldcxt nm ml
                                    stState3 = stState2 `ststInc` inc
                                    (tins,tinc,isEvaluated,gbState5) = tag env stState3 gtag (Just bsz) wsz gbState4
                                    (gbState6,allocLbl) = newLabelId gbState5
                                    stState4 = stState3 `ststInc` tinc
                                    (sins,sinc) = ndStore stState4 (wsz + ststDepth tinc) allocLbl
                                    wsz  = nrByte2Word $ basicSizeInBytes bsz
                            ValAccessAnnot_Basic bSz _ -> basicSize nm ml bSz
                            _ -> panic "GrinByteCode.gviLd'.GrValIntro_Basic.Just"
                     _ -> panic "GrinByteCode.gviLd'.GrValIntro_Basic.Nothing"
                where ml@((mbva,_,basicsz,_),gbState3) = nmLd' ldcxt env stState gbState2 nm
              GrValIntro_Grp gtag is
                -> ( GrValIntroAlt_OnTOS (prepins Seq.:++: ins Seq.:++: Seq.fromList [meta' AnnTag (ppGrTag gtag)] Seq.:++: tins Seq.:++: sins)
                                         sinc defaultOptimEffect [dfltBasicSize]
                   , gbState5 `gbstIncByStackState` stState5
                   )
                where (prepins,prepinc) = case (is, tag env stState2 gtag Nothing 0 gbState2) of
                                            ([],(_,st,_,_)) | Cfg.nodeNeedsForwarding opts && ststDepth st == 1
                                              -> (Seq.fromList [ldc 0],ststFromDepPerm 1 GCPermit_Not)
                                            _ -> (Seq.empty           ,ststFromDep 0)
                      stState3 = stState2 `ststInc` prepinc
                      i@(GrValIntroAlt_OnTOS ins inc _ _, gbState3) = gviLdFold' opts dflt (ldcxt {lcxOmitTOSLd = False}) env stState3 gbState2 is
                      inc2 = prepinc `ststInc` inc
                      stState4 = stState3 `ststInc` inc
                      (tins,tinc,isEvaluated,gbState4) = tag env stState4 gtag Nothing (ststDepth inc2) gbState3
                      stState5 = stState4 `ststInc` tinc
                      inc3 = inc2 `ststInc` tinc
                      (gbState5,allocLbl) = newLabelId gbState4
                      (sins,sinc) = ndStore stState5 (ststDepth inc3) allocLbl
              _ -> (dflt, gbState2)
          where stState2 = stState `ststInc` dfltInc
                gbState2 = gbState `gbstIncByStackState` stState2
                basicAnnotDflt (nmLdInfo,gbState)
                  = (GrValIntroAlt_Delay ins dfltInc defaultOptimEffect nmLdInfo, gbState)
                basicAnnotTaggedPtr sgn nm ml bSz
                  = (GrValIntroAlt_OnTOS (ins Seq.::+: tag2 sgn) inc defaultOptimEffect [bSz], gbState)
                  where (ins,inc,gbState) = vaAndLd2Ins ldcxt nm ml
                basicSize nm ml bSz
                  = (GrValIntroAlt_OnTOS (ins) inc defaultOptimEffect [bSz], gbState)
                  where (ins,inc,gbState) = vaAndLd2Ins ldcxt nm ml
                dfltBasicSize = grinBasicAnnotSize BasicAnnot_Dflt

gviLd :: EHCOpts -> LoadCtxt -> NmEnvGB -> StackState -> GBState -> GrValIntro -> (GrValIntroAlt,GBState)
gviLd opts ldcxt env stState gbState intro
  = case gviLd' opts ldcxt env stState gbState intro of
      (GrValIntroAlt_Delay ins inc optimEffect nmLdInfo@(mbva,l,basicsz,gcPermit), gbState2)
        -> (GrValIntroAlt_OnTOS (ins Seq.:++: sins) (inc `ststInc` sinc) optimEffect [basicsz], gbState3)
        where (sins,sinc,gbState3) = vaAndLd2Ins ldcxt hsnUnknown (nmLdInfo,gbState2)
      a -> a
%%]

%%[(8 codegen grin) hs export(gvCall)
gvCall :: MbCIStrNm -> NmEnvGB -> InsSeq -> StackState -> StackState -> GBState -> HsName -> (InsSeq,StackState,GBState)
gvCall i nmEnv ins inc stState gbState nm
  = (ins Seq.:++: fins Seq.:++: Seq.fromList [call i InsOp_LocB_TOS], ststFromDep nrValWords, gbState2)
  where (fins,_,gbState2) = nmLd defaultLoadCtxt nmEnv (stState `ststInc` inc) gbState nm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(nrWord2Byte)
nrWord2Byte :: Integral c => c -> c
nrWord2Byte sz
  = sz * wSz
  where wSz = fromInteger Cfg.sizeofGrWordAsInteger
%%]

%%[(8 codegen grin) hs export(nrByte2Word)
nrByte2Word :: Integral c => c -> c
nrByte2Word sz
  = (sz-1) `div` wSz + 1
  where wSz = fromInteger Cfg.sizeofGrWordAsInteger
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unboxed values
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(tagIsUnboxed)
tagIsUnboxed :: EHCOpts -> GrTag -> Bool
tagIsUnboxed opts
  = \gt -> case gt of
              GrTag_Con _ _ _ | check $ tagDataTypeNm gt
                -> True
              GrTag_Unboxed
                -> True
              _ -> False
  where check = maybe False biGbcMayLiveUnboxed . builtinGrinMayLiveUnboxed opts
%%]

%%[(8 codegen grin) hs export(tagAllowsUnboxedLife)
tagAllowsUnboxedLife :: EHCOpts -> GrTag -> Unbox
tagAllowsUnboxedLife opts gt
  = if tagIsUnboxed opts gt
    then Unbox_FirstField
    else case gt of
           GrTag_Con ann t _ | gtannMaxArity ann == 0
             -> Unbox_Tag t
           _ -> Unbox_None
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: immediate operands
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
imm :: Integral c => c -> (InsOp_ImmSz,Imm)
imm c
  = (s,Imm_Int i)
  where (s,i)
          = case toInteger c of
              i | i <  0 -> (s, i .&. m)
                         where (s,m) = case i of
                                         i | i >= pow2_7neg  -> (InsOp_ImmSz_Bits08,mask2_8 )
                                           | i >= pow2_15neg -> (InsOp_ImmSz_Bits16,mask2_16)
                                           | i >= pow2_31neg -> (InsOp_ImmSz_Bits32,mask2_32)
                                           | otherwise       -> (InsOp_ImmSz_Bits64,mask2_64)
              i | i >= 0 -> (s, i .&. mask2_64)
                         where s = case i of
                                     i | i < pow2_7sub1  -> InsOp_ImmSz_Bits08
                                       | i < pow2_15sub1 -> InsOp_ImmSz_Bits16
                                       | i < pow2_31sub1 -> InsOp_ImmSz_Bits32
                                       | otherwise       -> InsOp_ImmSz_Bits64
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: loading
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(ldc,ldl,ldg,ldi,l1tr,l2ts,ldnt)
ld :: Integral c => InsOp_Deref -> InsOp_LocB -> InsOp_LocE -> c -> Instr
ld ind locB locE c
  = Instr_Ld ind locB locE s i
  where (s,i) = imm c

-- load constant on TOS
ldc :: Integral c => c -> Instr
ldc = ld InsOp_Deref_Zero InsOp_LocB_TOS InsOp_LocE_Imm

-- load integer constant on TOS
ldi :: Integral c => c -> Instr
ldi = ld InsOp_Deref_Int InsOp_LocB_TOS InsOp_LocE_Imm

-- load local relative to SP on TOS
ldl :: Integral c => c -> Instr
ldl c = ld InsOp_Deref_One InsOp_LocB_TOS InsOp_LocE_SP (nrWord2Byte c)

-- load local relative to SP in reg
ldlr :: Integral c => c -> Instr
ldlr c = ld InsOp_Deref_One InsOp_LocB_Reg InsOp_LocE_SP (nrWord2Byte c)

-- load relative to reg on TOS
l1tr :: Integral c => c -> Instr
l1tr c = ld InsOp_Deref_One InsOp_LocB_TOS InsOp_LocE_Reg (nrWord2Byte c)

l2ts :: Integral c => c -> Instr
l2ts c = ld InsOp_Deref_Two InsOp_LocB_TOS InsOp_LocE_SP (nrWord2Byte c)

ldg :: InsOp_LocB -> LinkChainEntry -> Instr
ldg locB l = Instr_LdGlobal locB l

ldstr :: InsOp_LocB -> StringConst -> Instr
ldstr locB s = Instr_LdString locB s

ldnt :: Instr
ldnt = Instr_LdNodeTag
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: link
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
%%]
link :: Link -> Instr
link = Instr_Link

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: storing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-- not implemented yet

%%[(8 codegen grin) hs export()
st :: Integral c => InsOp_DerefB -> InsOp_LocE -> InsOp_LocB -> c -> Instr
st ind locE locB c
  = Instr_St ind locE locB s i
  where (s,i) = imm c
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: label
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(labelref,label,labelref2)
labelref :: LocRef -> Instr
labelref l = Instr_LabelRef l

labelref2 :: [LabelId] -> GBState -> ([Instr],GBState)
labelref2 lbls st
  = foldr (\l (is,st) -> let (st',llbl) = newLabelId st
                         in  (Instr_LinkChain (linkChainOffset llbl l) : is, st')
          )
          ([],st) lbls

label :: LocRef -> Instr
label l = Instr_Label l
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: fetching contents of a node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(fetch,fetchupdate)
fetch :: InsOp_LocB -> Instr
fetch locB = Instr_Fetch locB

fetchupdate :: Instr
fetchupdate = Instr_FetchUpdate
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: allocation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
allocstore :: InsOp_LocB -> LabelId -> GCStackInfo -> Instr
allocstore locB lbl gcStackInfo = Instr_AllocStore locB gcStackInfo

-- prepare node allocation by providing padding upto minimum size
{-
ndStorePrep :: EHCOpts -> Int -> (InsSeq,StackDepth)
ndStorePrep opts sz
  = (Seq.fromList $ replicate szExtra $ ldc 0, szExtra)
  where szPadded = Cfg.minwordsofNode opts `max` sz
        szExtra  = szPadded - sz
-}

ndStore :: StackState -> Int -> LabelId -> (InsSeq,StackState)
ndStore stState sz lbl
  = ( Seq.fromList [ ldc (nrWord2Byte sz)
                   , meta' AnnAllocStore sz, meta' AnnStackDepth stState2
                   , allocstore InsOp_LocB_TOS lbl (ststGCEncoding stState2)
                   ]
    , ststFromDep nrValWords
    )
  where stState2 = stState `ststInc` ststFromDepPerm 1 GCPermit_Not
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: eval
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(eval,apply)
eval :: MbCIStr -> InsOp_LocB -> Instr
eval i locB = Instr_Eval locB (mkCIEval i)

apply :: MbCIStr -> InsOp_LocB -> Instr
apply i locB = Instr_Apply locB (mkCIApply i)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: control, call, etc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(funstart,call,retcall,casecall,retcase,callc)
funstart :: FunctionInfo -> Instr
funstart i = Instr_FunStart i

call :: MbCIStrNm -> InsOp_LocB -> Instr
call i locB = Instr_Call locB (mkCICall i)

rettailcall :: Integral c => (InsOp_ImmSz -> InsOp_ImmSz -> Imm -> Imm -> Instr) -> c -> c -> Instr
rettailcall mk nArgMine nArgSurr -- retOffSurr
  = mk s1 s2 i1 i2
  where (s1,i1) = imm $ nrWord2Byte nArgMine
        (s2,i2) = imm $ nrWord2Byte nArgSurr
        -- (s3,i3) = imm $ nrWord2Byte retOffSurr

retcall :: Integral c => c -> c -> Instr
retcall = rettailcall Instr_RetCall

casecall :: LinkChainEntry -> Instr
casecall l
  = Instr_CaseCall l

callc :: Integral c => MbCIStr -> (LabelId,Int,[BasicSize]) -> StackState -> c -> Instr
callc i (lbl,inx,ty) stState nArg
  = Instr_CallC s1 i1 {- ce -} l (mkCICCall ty i (ststGCEncoding stState))
  where (s1,i1) = imm nArg
        -- (_ ,ce) = imm $ basicGrinSizeLEncoding ty
        l       = linkChainConst lbl inx

retcase :: Integral c => c -> c -> LinkChainEntry -> Instr
retcase nRes retOffSurr l
  = Instr_RetCase s1 s2 i1 i2 l
  where (s1,i1) = imm $ nrWord2Byte nRes
        (s2,i2) = imm $ nrWord2Byte retOffSurr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: tail variants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(taileval,tailcall,tailapply)
taileval :: Integral c => MbCIStr -> InsOp_LocB -> c -> Instr
taileval i locB nArgSurr
  = Instr_TailEval locB s1 i1 (mkCITailEval i)
  where (s1,i1) = imm $ nrWord2Byte nArgSurr
        -- (s2,i2) = imm $ nrWord2Byte retOffSurr

tailcall :: Integral c => InsOp_LocB -> c -> c -> Instr
tailcall locB = rettailcall (Instr_TailCall locB)

tailapply :: Integral c => InsOp_LocB -> c -> c -> Instr
tailapply locB = rettailcall (Instr_TailApply locB)

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: operators
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(op)
op :: Integral c => InsOp_TyOp -> InsOp_DataOp -> InsOp_LocODst -> InsOp_Deref -> InsOp_LocOSrc -> c -> Instr
op opTy opndTy locDst ind locSrc c
  = Instr_Op opTy opndTy locDst ind locSrc s1 i1
  where (s1,i1) = imm c
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: conversion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
tagi2w :: Instr
tagi2w = Instr_TagInt2Word

untagw2i :: Instr
untagw2i = Instr_UntagWord2Int

tagw2w :: Instr
tagw2w = Instr_TagWord2Word

untagw2w :: Instr
untagw2w = Instr_UntagWord2Word
%%]

%%[(8 codegen grin) hs export(untag2)
tag2 :: Bool -> Instr
tag2 sgn = if sgn then tagi2w else tagw2w

untag2 :: Bool -> Instr
untag2 sgn = if sgn then untagw2i else untagw2w
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: comment
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(AnnKind(..))
data AnnKind
  = AnnComment
  | AnnFunStart
  | AnnStackDepth
  | AnnIdUse
  | AnnTag
  | AnnAllocStore
  | AnnLabel
  | AnnLabelRef
  deriving (Eq,Show)

instance PP AnnKind where
  pp AnnComment      = Pretty.empty
  pp AnnFunStart     = pp "funstart"
  pp AnnStackDepth   = pp "stackoff"
  pp AnnIdUse        = pp "iduse"
  pp AnnTag          = pp "tag"
  pp AnnAllocStore   = pp "allocstore"
  pp AnnLabel        = pp "lbldef"
  pp AnnLabelRef     = pp "lblref"
%%]

%%[(8 codegen grin) hs export(meta',meta)
meta' :: PP a => AnnKind -> a -> Instr
meta' k a = Instr_Meta $ Meta_CmtHeader k $ pp a

meta :: PP a => a -> Instr
meta = meta' AnnComment
%%]

%%[(8 codegen grin) hs
instrann' :: PP a => AnnKind -> a -> Instr -> Instr
instrann' k a = Instr_Ann k $ showPP a

instrann :: PP a => a -> Instr -> Instr
instrann = instrann' AnnComment
%%]

%%[(8 codegen grin) hs
%%]
metaprop' :: PP a => AnnKind -> String -> a -> Instr
metaprop' k prop a = meta' k (prop >|< "=" >|< a)

metaprop :: PP a => String -> a -> Instr
metaprop = metaprop' AnnComment

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: tag
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Offsets should coincide with def of GB_NodeHeader, src/rts/base/types

%%[(8 codegen grin) hs
[tgShSize,tgShCateg,tagShGC,tagShTag,tgShNdEv]
  = if Cfg.use32Bits then [16,14,12,2,0::Int] else [32,30,28,2,0]

tgNeedEval_No, tgNeedEval_Yes, tgNeedEval_BlH :: Integer
tgNeedEval_No  = 0
tgNeedEval_Yes = 1
tgNeedEval_BlH = 2

tgCat_GB_NodeTagCat_Con
  , tgCat_GB_NodeTagCat_PAp
  , tgCat_GB_NodeTagCat_Fun
  , tgCat_GB_NodeTagCat_App
%%[[97
  , tgCat_GB_NodeTagCat_Intl
%%]]
      :: Integer

-- not requiring evaluation
tgCat_GB_NodeTagCat_Con  = 0
tgCat_GB_NodeTagCat_PAp  = 1
%%[[97
tgCat_GB_NodeTagCat_Intl = 3
%%]]
-- requiring evaluation
tgCat_GB_NodeTagCat_Fun  = 0
tgCat_GB_NodeTagCat_App  = 1

%%[[97
tgIntl_GB_NodeTag_Intl_Float
  , tgIntl_GB_NodeTag_Intl_Double
      :: Int
tgIntl_GB_NodeTag_Intl_Float  = 2
tgIntl_GB_NodeTag_Intl_Double = 3
%%]]
%%]

load tag, yield stack increment and additional size to alloc

%%[(8 codegen grin) hs export(tag)
tag :: NmEnvGB -> StackState -> GrTag -> Maybe BasicSize -> StackDepth -> GBState -> (InsSeq,StackState,Bool,GBState)
tag env stState gt bsz sz gbState
  = case gt of
      GrTag_Unboxed
        -> (Seq.empty,zero,False,gbState)
      _ -> (tins Seq.:++: Seq.fromList [ldc tword],tinc `ststInc` one,isEvaluated,gbState2)
        where (needEval,categ',tg',tins,tinc,gbState2)
                = case bsz of
%%[[97
                    Just BasicSize_Double       -> (tgNeedEval_No ,tgCat_GB_NodeTagCat_Intl,tgIntl_GB_NodeTag_Intl_Double,Seq.empty           ,zero ,gbState )
                    Just BasicSize_Float        -> (tgNeedEval_No ,tgCat_GB_NodeTagCat_Intl,tgIntl_GB_NodeTag_Intl_Float ,Seq.empty           ,zero ,gbState )
%%]]
                    _ -> case gt of
                           GrTag_Con _ tg _     -> (tgNeedEval_No ,tgCat_GB_NodeTagCat_Con ,tg                           ,Seq.empty           ,zero ,gbState )
                           GrTag_Hole           -> (tgNeedEval_BlH,0                       ,0                            ,Seq.fromList [ldc 0],one  ,gbState )
                           GrTag_Rec            -> (tgNeedEval_No ,tgCat_GB_NodeTagCat_Con ,0                            ,Seq.empty           ,zero ,gbState )
                           GrTag_App      nm    -> (tgNeedEval_Yes,tgCat_GB_NodeTagCat_App ,0                            ,Seq.empty           ,zero ,gbState )
                           GrTag_Fun      nm    -> (tgNeedEval_Yes,tgCat_GB_NodeTagCat_Fun ,0                            ,ins                 ,inc  ,gbState2)
                                                where (ins,inc,gbState2) = nmLd defaultLoadCtxt env stState gbState nm
                           GrTag_PApp m   nm    -> (tgNeedEval_No ,tgCat_GB_NodeTagCat_PAp ,m                            ,ins                 ,inc  ,gbState2)
                                                where (ins,inc,gbState2) = nmLd defaultLoadCtxt env stState gbState nm
              tword = (toInteger (sz + ststDepth tinc + 1) `shiftL` tgShSize) .|. needEval `shiftL` tgShNdEv .|. categ' `shiftL` tgShCateg .|. toInteger tg' `shiftL` tagShTag
              isEvaluated = needEval == tgNeedEval_No
  where zero     = ststFromDep 0
        one      = ststFromDepPerm 1 GCPermit_Not
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constructing: misc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs export(halt)
halt :: Instr
halt = Instr_Halt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Instances: ForceEval, Serializable
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9999 codegen grin) hs
instance ForceEval Const
instance ForceEval LinkChainEntry
instance ForceEval LocRef
instance ForceEval CallInfo
instance ForceEval CallInfoCall
instance ForceEval EntryInfo
%%]

