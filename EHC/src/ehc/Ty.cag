%%[0 hs
-- 20141217 AD: fix shuffle to propagate this for .cag files as well...
{-# LANGUAGE CPP #-}
%%]

%%[0 lhs2tex
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[1 haddock
The module %%@{%{EH}%%}Ty
contains the Haskell interface to the internal representation of types
used by EHC. The AST is described in Ty/AbsSyn.
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Ty
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[1 hs module {%{EH}Ty} import(UHC.Util.Utils,{%{EH}Base.Common}, {%{EH}Base.TermLike}, {%{EH}Base.HsName.Builtin}, {%{EH}Opts.Base})
%%]

%%[(1 hmtyinfer || hmtyast) hs export(TyAGItf(..), Ty(..), TyAnn(..), TyL, tyInt, tyChar)
%%]

%%[(1 hmtyinfer || hmtyast) hs export(tyLHdAndTl, tyProdArgs) 
%%]

%%[1 hs import(Data.Maybe, qualified Data.Set as Set, qualified Data.Map as Map) 
%%]

%%[(2 hmtyinfer || hmtyast) hs export(TyVarId, mkTyVar, mkNewTyVar, mkNewUIDTyVarL, mkNewTyVarL, mkTyFreshProd, mkTyFreshProdFrom, tyEnsureNonAny) 
%%]

%%[(3 hmtyinfer || hmtyast) hs export(mkTyQu, TyVarCateg(..))
%%]

%%[4 hs export(TyQu(..)) 
%%]

%%[(6 hmtyinfer || hmtyast) hs export(kiStar) 
%%]

%%[(6_4 hmtyinfer || hmtyast) hs export(tvIsEx) 
%%]

%%[(7 hmtyinfer || hmtyast) hs import(Data.List) export(kiRow) 
%%]

%%[(8 hmtyinfer || hmtyast) hs export(tyRecOffset) 
%%]

%%[(9 hmtyinfer || hmtyast) hs export(Pred(..))
%%]

%%[(9 hmtyinfer || hmtyast) hs export(Impls(..),ImplsVarId)
%%]

%%[(9 hmtyinfer || hmtyast) hs export(TyCtxt(..))
%%]

%%[(9 hmtyinfer || hmtyast) hs export(tyEnsureNonAnyImpl)
%%]

%%[(9 hmtyinfer || hmtyast) hs import(qualified UHC.Util.RLList.LexScope as LexScope)
%%]

%%[(9_1 hmtyinfer || hmtyast) hs export(TyPlusId)
%%]

%%[(10 hmtyinfer || hmtyast) hs export(Label(..),LabelAGItf(..))
%%]

%%[(11 hmtyinfer || hmtyast) hs export(tyLamArgsRes)
%%]

%%[(13 hmtyinfer || hmtyast) hs export(PredSeq(..))
%%]

%%[50 hs import(Control.Monad, UHC.Util.Binary, UHC.Util.Serialize)
%%]

%%[(1 hmtyinfer || hmtyast).TyAST ag import({Ty/AbsSyn})
%%]

%%[4 -1.TyAST ag import({Ty/AbsSyn})
%%]

%%[1 ag
DERIVING *
  : Show, Eq, Ord
%%[[50
  , Typeable, Data, Generic
%%]]

DERIVING TyVarCateg
  : Enum
%%]

Debug:

%%[(9 hmtyinfer || hmtyast) hs import(UHC.Util.Pretty,UHC.Util.Utils)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Misc types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(1 hmtyinfer || hmtyast).TyL hs
type TyL        = [Ty]
%%]

%%[(2 hmtyinfer || hmtyast).TyVarId.Base hs
type TyVarId    = VarId
%%]

%%[(2 hmtyinfer || hmtyast).TyVarId.Rest hs export(TyVarIdL,TyVarIdS)
type TyVarIdL   = [TyVarId]
type TyVarIdS   = VarIdS
%%]

%%[(7 hmtyinfer || hmtyast) hs export(FldTyL)
type FldTyL = AssocL (Maybe HsName) Ty
%%]

%%[(9 hmtyinfer || hmtyast) hs
type ImplsVarId    = VarId
%%]

%%[(9_1 hmtyinfer || hmtyast) hs
type TyPlusId      = VarId
%%]

%%[(10 hmtyinfer || hmtyast) hs export(LabelVarId)
type LabelVarId      = VarId
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Lookup types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(2 hmtyinfer || hmtyast) hs export(LookupTy)
type LookupTy = TyVarId -> Maybe Ty
%%]

%%[(9 hmtyinfer || hmtyast) hs export(LookupImpls)
type LookupImpls = ImplsVarId -> Maybe Impls
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Misc types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(2 hmtyinfer) hs export(TyVarWild(..),TyVarWildMp)
-- | tyvars may act as wildcard, that is, they act as placeholders inside partial type signatures, providing
--   some structure. Such wildcards come in flavors:
data TyVarWild
  = TyVarWild_NoQuantTyExpr_YesQuantLetBinding		-- quantify: not in TyExpr, yes in let binding
  | TyVarWild_NoQuantTyExpr_NoQuantLetBinding		-- quantify: not in TyExpr, not in let binding (enforce monomorphism)
  deriving Eq

type TyVarWildMp = Map.Map TyVarId TyVarWild
%%]

%%[(2 hmtyinfer) hs export(tvwmpNoQuantS)
tvwmpNoQuantS :: TyVarWildMp -> UIDS
tvwmpNoQuantS = Map.keysSet . Map.filter (== TyVarWild_NoQuantTyExpr_NoQuantLetBinding)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Tyvar category
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(4 hmtyinfer || hmtyast) hs export(tvCatIsPlain,tvCatIsFixed)
tvCatIsPlain :: TyVarCateg -> Bool
tvCatIsPlain TyVarCateg_Plain  = True
tvCatIsPlain _                 = False

tvCatIsFixed :: TyVarCateg -> Bool
tvCatIsFixed TyVarCateg_Fixed  = True
tvCatIsFixed _                 = False
%%]

%%[(9 hmtyinfer || hmtyast) hs export(tvCatIsMeta)
tvCatIsMeta :: TyVarCateg -> Bool
tvCatIsMeta TyVarCateg_Meta   = True
tvCatIsMeta _                 = False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Tyvar purpose
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Variables in types are used for different purposes
20080610, AD, todo: use this in VarMpInfo

%%[(9 hmtyinfer || hmtyast) hs export(TvPurpose(..))
data TvPurpose
  = TvPurpose_Ty TyVarCateg     -- stands for unknown type, the known humble type variable
  | TvPurpose_Impls             -- possibly empty sequence of implicit parameters
  | TvPurpose_Scope             -- predicate scope
  | TvPurpose_Pred              -- predicate
  | TvPurpose_AssNm             -- assumed name, in CHR
%%[[10
  | TvPurpose_Label             -- label, in CHR, for ext records
  | TvPurpose_Offset            -- offset, in CHR, for ext records
%%]]
%%[[13
  | TvPurpose_PredSeq           -- experimental still
%%]]
  deriving (Eq,Ord)
%%]

%%[(9 hmtyinfer || hmtyast) hs
instance Show TvPurpose where
  show (TvPurpose_Ty TyVarCateg_Fixed)  = "c"
  show (TvPurpose_Ty TyVarCateg_Meta )  = "m"
  show (TvPurpose_Ty _               )  = "v"
  show TvPurpose_Impls                  = "i"
  show TvPurpose_Scope                  = "s"
  show TvPurpose_Pred                   = "p"
  show TvPurpose_AssNm                  = "a"
%%[[10
  show TvPurpose_Label                  = "l"
  show TvPurpose_Offset                 = "o"
%%]]
%%[[13
  show TvPurpose_PredSeq                = "s"
%%]]
%%]

%%[(9 hmtyinfer || hmtyast) hs export(tvpurposeIsTy)
tvpurposeIsTy (TvPurpose_Ty _) = True
tvpurposeIsTy _                = False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Tyvar info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(4 hmtyinfer || hmtyast) hs export(TvInfo(..)) 
data TvInfo
  = TvInfo
      { tvinfoCateg     :: !TyVarCateg
%%[[9
      , tvinfoPurpose   :: !TvPurpose
%%]]
      }
%%]

%%[(4 hmtyinfer || hmtyast) hs export(emptyTvInfo) 
emptyTvInfo
  = TvInfo TyVarCateg_Plain
%%[[9
           (TvPurpose_Ty TyVarCateg_Plain)
%%]]
%%]

%%[(4 hmtyinfer || hmtyast) hs export(mkTvInfo,mkTvInfoTy) 
mkTvInfo = TvInfo

mkTvInfoTy :: TyVarCateg -> TvInfo
%%[[4
mkTvInfoTy c = mkTvInfo c
%%][9
mkTvInfoTy c = mkTvInfo c (TvPurpose_Ty c)
%%]]
%%]

%%[(4 hmtyinfer || hmtyast) hs
instance Show TvInfo where
%%[[4
  show i | cat == TyVarCateg_Fixed = "c"
         | otherwise               = "v"
    where cat = tvinfoCateg i
%%][9
  show i | pur == TvPurpose_Ty TyVarCateg_Fixed && cat == TyVarCateg_Fixed = "c"
         | otherwise                                                       = show pur
    where cat = tvinfoCateg i
          pur = tvinfoPurpose i
%%]]
%%]

%%[(9 hmtyinfer || hmtyast) hs export(mkTvInfoPlain)
mkTvInfoPlain :: TvPurpose -> TvInfo
mkTvInfoPlain p = mkTvInfo TyVarCateg_Plain p
%%]

%%[(4 hmtyinfer || hmtyast) hs export(TvCatMp,emptyTvCatMp) 
type TvCatMp = Map.Map TyVarId TvInfo
emptyTvCatMp = Map.empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Label offset
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(10 hmtyinfer || hmtyast) hs export(LabelOffset(..))
data LabelOffset
  = LabelOffset_Off !Int
  | LabelOffset_Var !UID
  deriving
    ( Eq, Ord
%%[[50
    , Typeable
%%]]
    )
%%]

%%[(10 hmtyinfer || hmtyast) hs
instance Show LabelOffset where
  show (LabelOffset_Off o) = show o
  show (LabelOffset_Var v) = "off_" ++ show v
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pred scope
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 hmtyinfer || hmtyast) hs export(PredScope(..),initPredScope)
data PredScope
  = PredScope_Lev !LexScope.LexScope
  | PredScope_Var !TyVarId
  deriving (Eq,Ord)

initPredScope :: PredScope
initPredScope = PredScope_Lev LexScope.empty
%%]

%%[(50 hmtyinfer || hmtyast) hs
deriving instance Typeable PredScope
deriving instance Data PredScope
%%]

%%[(9 hmtyinfer || hmtyast) hs export(pscpMbVar)
pscpMbVar :: PredScope -> Maybe TyVarId
pscpMbVar (PredScope_Var v) = Just v
pscpMbVar _                 = Nothing
%%]

%%[(9 hmtyinfer || hmtyast) hs
instance Show PredScope where
  show (PredScope_Lev l) = show l
  show (PredScope_Var v) = "[sc_" ++ show v ++ "]"
%%]

%%[(9 hmtyinfer || hmtyast) hs export(pscpEnter,pscpLeave)
pscpEnter :: Int -> PredScope -> (Int,PredScope)
pscpEnter x (PredScope_Lev s) = (x+1,PredScope_Lev (x `LexScope.enter` s))

pscpLeave :: PredScope -> PredScope
pscpLeave (PredScope_Lev s) = PredScope_Lev $ fromJust $ LexScope.leave s
%%]

%%[(9 hmtyinfer || hmtyast) hs export(pscpEnter',pscpLeave',pscpMk')
-- enter yes/no scope, give back the threaded counter to outside the new scope and inside
-- use in conjunction with pscpLeave'
pscpEnter' :: Bool -> Int -> (Int,Int)
pscpEnter' yesEnter x
  = if yesEnter
    then (fst $ pscpEnter x initPredScope,0)
    else (x,x)

-- leave scope, on previous entering yes/no scope, give back the threaded counter to outside the new scope and inside
-- use in conjunction with pscpEnter'
pscpLeave' :: Bool -> Int -> Int -> Int
pscpLeave' yesEnter newScopeCounter innerScopeCounter
  = if yesEnter
    then newScopeCounter
    else innerScopeCounter

-- make scope, depending on yes/no entering
-- use in conjunction with pscpEnter'
pscpMk' :: Bool -> Int -> PredScope -> PredScope
pscpMk' yesEnter x s
  = if yesEnter
    then snd $ pscpEnter x s
    else s
%%]

%%[(9 hmtyinfer || hmtyast) hs export(pscpIsVisibleIn,pscpCommon)
pscpIsVisibleIn :: PredScope -> PredScope -> Bool
pscpIsVisibleIn (PredScope_Lev sOuter) (PredScope_Lev sInner) = sOuter `LexScope.isVisibleIn` sInner
pscpIsVisibleIn _                      _                      = False

pscpCommon :: PredScope -> PredScope -> Maybe PredScope
pscpCommon (PredScope_Lev s1) (PredScope_Lev s2) = Just $ PredScope_Lev $ LexScope.common s1 s2
pscpCommon _                  _                  = Nothing        
%%]

%%[(9 hmtyinfer || hmtyast) hs export(pscpParents)
pscpParents :: PredScope -> [PredScope]
pscpParents (PredScope_Lev s) = map PredScope_Lev $ LexScope.parents s
pscpParents _                 = []
%%]

%%[(9 hmtyinfer || hmtyast) hs export(pscpCmp,pscpCmpByLen)
pscpCmp :: PredScope -> PredScope -> Maybe Ordering                  
pscpCmp (PredScope_Lev s) (PredScope_Lev t) = Just $ s `compare` t                   
pscpCmp _                 _                 = Nothing                 

pscpCmpByLen :: PredScope -> PredScope -> Ordering                  
pscpCmpByLen (PredScope_Lev s) (PredScope_Lev t) = s `LexScope.compareByLength` t                 
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Possible prove occurrence of predicate, but not yet known which
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Of Impls it is yet unknown to which pred it will bind.
Nevertheless, it can occur at locations which normally would give rise to prove obligations.
Hence we need to remember all required info except the yet unknown predicate.

%%[(9 hmtyinfer || hmtyast) hs export(ImplsProveOcc(..),mkImplsProveOcc)
data ImplsProveOcc
  = ImplsProveOcc
      { ipoId       :: !UID
      , ipoScope    :: !PredScope
      }
  deriving (Eq,Show,Ord,Data)

mkImplsProveOcc :: UID -> PredScope -> ImplsProveOcc
mkImplsProveOcc = ImplsProveOcc
%%]

%%[(50 hmtyinfer || hmtyast) hs
deriving instance Typeable ImplsProveOcc
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pred occurrence, to be obsolete when fully moved to CHR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 hmtyinfer || hmtyast) hs export(PredOcc(..),poId,mkPredOcc)
data PredOcc
  =  PredOcc
       { poPr               :: !Pred
       , poPoi              :: !PredOccId
       , poScope            :: !PredScope
%%[[99
       , poRange            :: !Range
%%]]
       }
  deriving (Show,Eq,Ord)

poId :: PredOcc -> UID
poId = poiId . poPoi

mkPredOcc :: Pred -> PredOccId -> PredScope -> PredOcc
mkPredOcc p i sc = rngLift emptyRange mkPredOccRng p i sc
%%]

%%[(9 hmtyinfer || hmtyast).poRange hs export(poRange)
poRange :: PredOcc -> Range
poRange = const emptyRange
%%]

%%[(9 hmtyinfer || hmtyast).mkPredOccRng hs export(mkPredOccRng)
mkPredOccRng :: Pred -> PredOccId -> PredScope -> PredOcc
mkPredOccRng p i sc = PredOcc p i sc
%%]

%%[(99 hmtyinfer || hmtyast) -(9.mkPredOccRng 9.poRange) hs export(mkPredOccRng)
mkPredOccRng :: Range -> Pred -> PredOccId -> PredScope -> PredOcc
mkPredOccRng r p i sc = PredOcc p i sc r
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% CHR Pred occurrence
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 hmtyinfer || hmtyast) hs export(CHRPredOccCxt(..))
data CHRPredOccCxt
  = CHRPredOccCxt_Scope1
      { cpocxScope			:: !PredScope			-- default, only allowed value for occurring preds
      --											-- others for solving and CHR's only
      }
  deriving (Show,Eq,Ord,Generic)

%%]

%%[(50 hmtyinfer || hmtyast) hs
deriving instance Typeable CHRPredOccCxt
%%]

%%[(9 hmtyinfer || hmtyast) hs export(CHRPredOcc'(..),CHRPredOcc,cpoScope,mkCHRPredOcc)
data CHRPredOcc' p
  =  CHRPredOcc
       { cpoPr               :: !p
       -- , cpoScope            :: !PredScope
       , cpoCxt              :: !CHRPredOccCxt
%%[[99
       , cpoRange            :: !Range
%%]]
       }
  deriving (Show,Eq,Ord,Generic)

type CHRPredOcc = CHRPredOcc' Pred

mkCHRPredOcc :: Pred -> PredScope -> CHRPredOcc
%%[[9
mkCHRPredOcc p sc = CHRPredOcc p (CHRPredOccCxt_Scope1 sc)
%%][99
mkCHRPredOcc p sc = mkCHRPredOccRng emptyRange p sc
%%]]

cpoScope :: CHRPredOcc -> PredScope
cpoScope = cpocxScope . cpoCxt
%%]

%%[(9 hmtyinfer || hmtyast) hs export(cpo2PredOcc)
cpo2PredOcc :: PredOccId -> CHRPredOcc -> PredOcc
cpo2PredOcc i o
  = mkPredOccRng
%%[[99
      (cpoRange o) 
%%]]
      (cpoPr o)
      i
      (cpoScope o)
%%]

%%[(50 hmtyinfer || hmtyast) hs
-- #if __GLASGOW_HASKELL__ >= 708
deriving instance Typeable  CHRPredOcc'
-- #else
-- deriving instance Typeable1 CHRPredOcc'
-- #endif
%%]

%%[(99 hmtyinfer || hmtyast) hs export(mkCHRPredOccRng)
mkCHRPredOccRng :: Range -> Pred -> PredScope -> CHRPredOcc
mkCHRPredOccRng r p sc = CHRPredOcc p (CHRPredOccCxt_Scope1 sc) r
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Base quantifiers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[4 hs export(tyQu_Forall,tyQu_Exists)
tyQu_Forall = TyQu_Forall metaLevVal
tyQu_Exists = TyQu_Exists metaLevVal
%%]

%%[(6 hmtyinfer || hmtyast) hs export(tyQu_KiForall,tyQu_KiExists)
tyQu_KiForall = TyQu_Forall metaLevTy
tyQu_KiExists = TyQu_Exists metaLevTy
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Properties of quantifier
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(4 hmtyinfer || hmtyast) hs export(tyquIsExists, tyquIsForall)
tyquIsExists, tyquIsForall :: TyQu -> Bool
%%]

%%[(4 hmtyinfer || hmtyast).tyQuProps hs
tyquIsForall (TyQu_Forall _)         = True
tyquIsForall _                       = False

tyquIsExists (TyQu_Exists _)         = True
tyquIsExists _                       = False
%%]

%%[(4 hmtyinfer || hmtyast) hs export(tyquMetaLev)
tyquMetaLev (TyQu_Forall l)         = l
tyquMetaLev (TyQu_Exists l)         = l
%%[[8
tyquMetaLev (TyQu_Plain  l)         = l
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type quantifier utils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(4 hmtyinfer || hmtyast) hs export(tyquExists)
tyquExists, tyquForall :: TyQu -> TyQu
%%]

%%[(4 hmtyinfer || hmtyast).tyquMisc hs
tyquForall   (TyQu_Exists l)         = TyQu_Forall l
tyquForall   q                       = q

tyquExists   (TyQu_Forall l)         = TyQu_Exists l
tyquExists   q                       = q
%%]

%%[4.showTyQu hs export(showTyQu)
showTyQu  (TyQu_Forall 0) =  "forall"
%%[[6
showTyQu  (TyQu_Forall 1) =  "forall" ++ [charKindStar]
showTyQu  (TyQu_Forall l) =  "forall" ++ [charKindStar] ++ show l
%%]]
showTyQu  (TyQu_Exists 0) =  "exists"
%%[[6
showTyQu  (TyQu_Exists 1) =  "exists" ++ [charKindStar]
showTyQu  (TyQu_Exists l) =  "exists" ++ [charKindStar] ++ show l
%%]]
%%[[8
showTyQu  (TyQu_Plain  0) =  ""
showTyQu  (TyQu_Plain  1) =  [charKindStar]
showTyQu  (TyQu_Plain  l) =  [charKindStar] ++ show l
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Debugging (20100217 AD: required it when pretty printing had a still unnoticed byg)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(99 hmtyinfer || hmtyast) hs export(tyIsA)
tyIsA :: Ty -> String
tyIsA (Ty_Con   a      ) = "CON"
tyIsA (Ty_App   a b    ) = "APP"
tyIsA (Ty_Ann   a b    ) = "ANN"
tyIsA (Ty_Var   a b    ) = "VAR"
tyIsA (Ty_Any          ) = "ANY"
tyIsA (Ty_TBind a b c d) = "QUANT"
tyIsA (Ty_Ext   a b c  ) = "EXT"
tyIsA (Ty_Pred  a      ) = "PRED"
tyIsA (Ty_Lam   a b    ) = "LAM"
tyIsA (Ty_Impls a      ) = "IMPLS"
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Ann removal, construction, addition
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(1 hmtyinfer || hmtyast) hs export(tyUnAnn)
-- | Remove TyAnn's
tyUnAnn :: Ty -> Ty
tyUnAnn = fst . appUnAnn
{-# INLINE tyUnAnn #-}
%%]
tyUnAnn (Ty_Ann _ t) = tyUnAnn t
tyUnAnn t            = t

%%[(7 hmtyinfer || hmtyast) hs export(tyRowUnAnn,tyRowExtsUnAnn)
tyRowUnAnn :: AssocL HsName Ty -> AssocL HsName Ty
tyRowUnAnn = assocLMapElt tyUnAnn

tyRowExtsUnAnn :: (Ty,AssocL HsName Ty) -> (Ty,AssocL HsName Ty)
tyRowExtsUnAnn (x,y) = (tyUnAnn x,tyRowUnAnn y)
%%]

%%[(1 hmtyinfer || hmtyast) hs export(tyCanonAnn)
-- | Canonicalize TyAnn's
tyCanonAnn :: Ty -> Ty
tyCanonAnn t
  = c [] t
  where c seen t@(Ty_Ann a ta) | a `elem` seen = c seen ta
                               | otherwise     = Ty_Ann a $ c (a:seen) ta
        c _    t                               = t
%%]

%%[(4 hmtyinfer || hmtyast) hs export(tyAnnMono)
-- | Add TyAnn
tyAnn :: TyAnn -> Ty -> Ty
tyAnn a t@(Ty_Ann a' _) | a == a' = t
tyAnn a t                         = Ty_Ann a t

-- | Add TyAnn_Mono
tyAnnMono :: Ty -> Ty
tyAnnMono = tyAnn TyAnn_Mono
%%]

%%[(4 hmtyinfer || hmtyast) hs export(tyAnnDecomposeMk)
-- | Decompose type for annotation into unannotated type + reconstruction
tyAnnDecomposeMk    :: Ty -> (Ty, [TyAnn], Ty -> Ty)
tyAnnDecomposeMk t
  = case t of
      Ty_Ann a t'       -> (ta,as,\ta' -> tyAnn a $ mk ta')
                        where (ta,as,mk) = tyAnnDecomposeMk t'
      _                 -> (t ,[],id)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Removal of non semantics, noise
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotations, empty implicits do not carry type info, but sit in the way of finding out what is underneath.

%%[(9999 hmtyinfer || hmtyast) hs export(tyUnNoiseForVarBind)
-- | un-noise with the purpose of finding out whether we end up with Ty_Var
tyUnNoiseForVarBind :: Ty -> Maybe Ty
tyUnNoiseForVarBind t
  = un t
  where un t | not (null impls) && all isNil impls
             = tv t'
             where (impls,t') = tyArrowImplsRes t
                   isNil (Ty_Impls (Impls_Nil)) = True
                   isNil _                      = False
        un t = tv t
        tv t | tyIsVar t = Just t
             | otherwise = Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Properties of type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(4 hmtyinfer || hmtyast) hs export(tyIsVar,tyIsCon)
tyIsVar :: Ty -> Bool
tyIsVar = isJust . tyMbVar

tyIsCon :: Ty -> Bool
tyIsCon = isJust . tyMbCon

tyIsQu :: Ty -> Bool
tyIsQu = isJust . tyMbQu
%%]

%%[(4 hmtyinfer || hmtyast) hs export(tvIsPlain,tyIsVarPlain)
tyIsVarPlain :: Ty -> Bool
tyIsVarPlain = maybe False (tvCatIsPlain . snd) . tyMbVar'

tvIsPlain :: TvCatMp -> TyVarId -> Bool
tvIsPlain m v = maybe False (tvCatIsPlain . tvinfoCateg) $ Map.lookup v m
%%]

%%[(10 hmtyinfer || hmtyast) hs export(tyIsEmptyRow)
tyIsEmptyRow :: Ty -> Bool
tyIsEmptyRow = maybe False (== hsnRowEmpty) . tyMbCon
%%]

Only used to steer PP:

%%[(4 hmtyinfer || hmtyast) hs export(tyIsSimple)
tyIsSimple :: Ty -> Bool
tyIsSimple t = tyIsVar t || tyIsCon t
%%]

%%[(11 hmtyinfer || hmtyast) hs export(tyIsLam)
tyIsLam :: Ty -> Bool
tyIsLam ty
  = not (null as)
  where (as,_) = tyLamArgsRes ty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% AppLike, RecLike instances
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(1 hmtyinfer || hmtyast).AppLike hs
instance {-# OVERLAPPING  #-} AppLike Ty Ty {- TyAnn () -} where
  -- AppLike
  
  app1App        = Ty_App
  appTop         = id
  appCon         = Ty_Con . mkHNm
  appPar         = id
%%[[1
  appRngVar      = appRngCon
%%][3
  appRngVar _    = panic "Ty.appRngVar"
%%]]
%%[[7
  appProdApp tyL  = recRec (zip positionalFldNames tyL)
%%]]
  -- appDflt		 = Ty_Any
  appDbg s		 = Ty_Dbg $ "*ERR: " ++ s ++ " :*"

  appMbCon (Ty_Con n) 	    = Just n
  appMbCon _            	= Nothing

  appMbApp1 (Ty_App f a) 	= Just (f,a)
  appMbApp1 _            	= Nothing

  appMbAnn1 (Ty_Ann a t) 	= Just (t, Ty_Ann a)
  appMbAnn1 _            	= Nothing

%%[[9
  appMbCanon1 t             = do (is,r) <- tyMbArrowImplsResWithLkup (const Nothing) t
                                 if not (null is) && all (maybe False implsIsEmpty . tyMbImpls) is then return (r, appArr is) else Nothing
%%]]

  appMbDbg  (Ty_Dbg s)      = Just s
  appMbDbg  _            	= Nothing

%%[[3
  appMbBind1 (Ty_TBind   v   t) = Just (t, Ty_TBind   v  )
%%][4
  appMbBind1 (Ty_TBind q v   t) = Just (t, Ty_TBind q v  )
%%][6
  appMbBind1 (Ty_TBind q v k t) = Just (t, Ty_TBind q v k)
%%]]
  appMbBind1 _            	    = Nothing
%%]

%%[(1 hmtyinfer || hmtyast) hs
instance BndLike Ty TyVarId {- TyAnn () -} where
  -- BndLike
  bndBndIn n l x = Ty_TBind (TyQu_Plain (l-1)) n x
%%]

%%[(1 hmtyinfer || hmtyast) hs
instance {-# OVERLAPPING  #-} RecLike Ty Ty {- TyAnn () -} where
  -- RecLike
%%[[7
  recRow r 		= foldl (\t (n,e) -> Ty_Ext t n e) r
  
  recMbRecRow 	= tyMbRecRowWithLkup (const Nothing)
  recUnRowExts	= tyRowExtsWithLkup (const Nothing)
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Construction of type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(1111 hmtyinfer || hmtyast).mkTyCon hs
mkTyCon :: String -> Ty
mkTyCon n = appCon (hsnFromString n)
%%]

%%[(2 hmtyinfer || hmtyast).mkTyVar hs
mkTyVar :: TyVarId -> Ty
mkTyVar tv = Ty_Var tv
%%]

%%[(3 hmtyinfer || hmtyast).mkTyVar -2.mkTyVar hs
mkTyVar :: TyVarId -> Ty
mkTyVar tv = Ty_Var tv TyVarCateg_Plain
%%]

%%[(9 hmtyinfer || hmtyast) hs export(mkTyMetaVar)
mkTyMetaVar :: TyVarId -> Ty
mkTyMetaVar tv = Ty_Var tv TyVarCateg_Meta
%%]

%%[(2 hmtyinfer || hmtyast).NewTyVar hs
mkNewTyVar :: UID -> Ty
mkNewTyVar u = let  (_,v) = mkNewUID u in mkTyVar v
%%]

%%[(2 hmtyinfer || hmtyast).NewTyVarL hs
mkNewUIDTyVarL :: Int -> UID -> ([UID],TyL)
mkNewUIDTyVarL sz u = let vs = mkNewUIDL sz u in (vs,map mkTyVar vs)

mkNewTyVarL :: Int -> UID -> TyL
mkNewTyVarL sz u = snd (mkNewUIDTyVarL sz u)
%%]

%%[(2 hmtyinfer || hmtyast).tyEnsureNonAny hs
tyEnsureNonAny :: UID -> Ty -> Ty
tyEnsureNonAny u t = if t /= Ty_Any then t else mkNewTyVar u
%%]

%%[(8888 hmtyinfer || hmtyast) hs export(mkTyThunk)
-- | (placeholder for) make type level repr of thunk (i.e. laziness)
mkTyThunk :: Ty -> Ty
mkTyThunk = appNonEvl
%%]

%%[(9 hmtyinfer || hmtyast).tyEnsureNonAnyImpl hs
tyEnsureNonAnyImpl :: UID -> Ty -> Ty
tyEnsureNonAnyImpl u t
  = if t /= Ty_Any then  t
                   else  let  [i,r] = mkNewUIDL 2 u
                         in   [mkImplsVar i] `appArr` mkTyVar r
%%]

%%[(3 hmtyinfer || hmtyast).mkTyQu hs
mkTyQu :: TyVarIdL -> Ty -> Ty
mkTyQu tvL t = foldr (\tv t -> Ty_TBind tv t) t tvL
%%]

%%[(4 hmtyinfer || hmtyast).mkTyQu -3.mkTyQu hs
mkTyQu :: TyQu -> TyVarIdL -> Ty -> Ty
mkTyQu q tvL t = foldr (\tv t -> Ty_TBind q tv t) t tvL
%%]

%%[(6 hmtyinfer || hmtyast).mkTyQu -(3.mkTyQu 4.mkTyQu) hs
mkTyQu :: TyQu -> [(TyVarId,Ty)] -> Ty -> Ty
mkTyQu q tvL t = foldr (\(tv,k) t -> Ty_TBind q tv k t) t tvL
%%]

%%[(2 hmtyinfer || hmtyast).mkTyFreshProd hs
mkTyFreshProdFrom :: UID -> Int -> Ty
mkTyFreshProdFrom uid arity =  appProdApp . map mkTyVar . mkNewUIDL arity $ uid

mkTyFreshProd :: Int -> Ty
mkTyFreshProd = mkTyFreshProdFrom uidStart
%%]

%%[(11 hmtyinfer || hmtyast) hs export(mkTyLam)
mkTyLam :: [TyVarId] -> Ty -> Ty
mkTyLam args body = foldr Ty_Lam body args
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Construction of implicitly parameterized (or predicated) type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 hmtyinfer || hmtyast) hs export(mkImplsTail,mkImplsVar,mkImplsNil)
mkImplsTail :: ImplsVarId -> Impls
mkImplsTail v = Impls_Tail v []

mkImplsVar :: ImplsVarId -> Ty
mkImplsVar v = Ty_Impls (mkImplsTail v)

mkImplsNil :: Ty
mkImplsNil = Ty_Impls Impls_Nil
%%]

%%[(9 hmtyinfer || hmtyast) hs export(mkTyImpls)
mkTyImpls :: [Pred] -> Ty -> Ty
mkTyImpls prL t = map mkTyPr prL `appArr` t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Construction of pred type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 hmtyinfer || hmtyast) hs export(mkTyPr)
mkTyPr :: Pred -> Ty
mkTyPr p
  =  case p of
       Pred_Pred t  -> t
       _            -> Ty_Pred p
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(1 hmtyinfer || hmtyast).tyInt hs
tyInt :: Ty
tyInt   = appCon hsnInt
%%]

%%[(1 hmtyinfer || hmtyast).tyChar hs
tyChar :: Ty
tyChar  = appCon hsnChar
%%]

%%[(5 hmtyinfer || hmtyast).tyString hs export(tyString)
tyString :: Ty
tyString  = appConApp hsnDataList [tyChar]
%%]

%%[(11 hmtyinfer || hmtyast).tyString -5.tyString hs
%%]

%%[(6 hmtyinfer || hmtyast) hs
kiStar :: Ty
kiStar  = appCon hsnKindStar
%%]

%%[(7 hmtyinfer || hmtyast) hs
kiRow :: Ty
kiRow       = appCon hsnKindRow
-- tyRowEmpty  = appCon hsnRowEmpty
%%]

%%[(18 hmtyinfer || hmtyast) hs export(tyIntUnboxed)
tyIntUnboxed   = appCon hsnIntUnboxed
%%]

%%[(18 hmtyinfer || hmtyast) hs export(kiUnboxed)
kiUnboxed  = appCon hsnKindUnboxed
%%]

%%[(97 hmtyinfer || hmtyast) hs export(tyInteger)
tyInteger :: Ty
tyInteger      	  = appCon hsnInteger
%%]
tyInt8Unboxed     = appCon hsnInt8Unboxed  
tyInt16Unboxed    = appCon hsnInt16Unboxed 
tyInt32Unboxed    = appCon hsnInt32Unboxed 
tyInt64Unboxed    = appCon hsnInt64Unboxed 
tyWordUnboxed     = appCon hsnWordUnboxed  
tyWord8Unboxed    = appCon hsnWord8Unboxed 
tyWord16Unboxed   = appCon hsnWord16Unboxed
tyWord32Unboxed   = appCon hsnWord32Unboxed
tyWord64Unboxed   = appCon hsnWord64Unboxed

%%[(99 hmtyinfer || hmtyast) hs
%%]
tyAddrUnboxed   = appCon hsnAddrUnboxed

%%[(11 hmtyinfer || hmtyast) hs export(tyString)
tyString :: EHCOpts -> Ty
tyString o = appCon (ehcOptBuiltin o ehbnPrelString)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Destruction & manipulation for Arrow, i.e. function types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(1 hmtyinfer || hmtyast).unMkTy.sigs.Arrow hs
-- tyArrowArgsRes  :: Ty -> (TyL,Ty)
-- tyAppFunArgs    :: Ty -> (Ty,TyL)
-- tyAppArgs       :: Ty -> TyL
-- tyArrowArgs     :: Ty -> TyL
-- tyArrowRes      :: Ty -> Ty
-- tyArrowArg      :: Ty -> Ty
%%]

Substitution aware variants

%%[(9 hmtyinfer || hmtyast) hs export(tyArrowArgResWithLkup)
tyArrowArgResWithLkup :: LookupTy -> Ty -> (Ty,Ty)
tyArrowArgResWithLkup lookup = tyVarChkVisitLift lookup appUn1Arr appUn1Arr
%%]

%%[(9 hmtyinfer || hmtyast) hs export(tyArrowImplsResWithLkup,tyArrowImplsArgResWithLkup)
tyArrowImplsArgResWithLkup :: LookupTy -> Ty -> (TyL,Ty,Ty)
tyArrowImplsArgResWithLkup lookup t
  = (i,a,r)
  where (i,t')  = tyArrowImplsResWithLkup lookup t
        (a,r)   = tyArrowArgResWithLkup   lookup t'

tyMbArrowImplsResWithLkup :: LookupTy -> Ty -> Maybe (TyL,Ty)
tyMbArrowImplsResWithLkup lookup t
  = extr t
  where extr t = case appMb1Arr t of
                   Just (a,r)
                     | isImpls a'
                       -- -> let (as,r') = extr r in (a':as,r')
                       -> case extr r of
                            Just (as,r') -> Just (a':as,r')
                            _            -> Just ([a'],r)
                     where  a' = tyUnAnn a
                            isImpls (Ty_Pred  _)  = True
                            isImpls (Ty_Impls _)  = True
                            isImpls _             = False
                   _   -> tyVarLift lookup extr (const Nothing) t

tyArrowImplsResWithLkup :: LookupTy -> Ty -> (TyL,Ty)
tyArrowImplsResWithLkup lookup t = maybe ([],t) id $ tyMbArrowImplsResWithLkup lookup t
%%]

%%[(9 hmtyinfer || hmtyast) hs export(tyArrowImplsRes,tyArrowImplsArgRes)
tyArrowImplsRes :: Ty -> (TyL,Ty)
tyArrowImplsRes = tyArrowImplsResWithLkup (const Nothing)

tyArrowImplsArgRes  :: Ty -> (TyL,Ty,Ty)
tyArrowImplsArgRes = tyArrowImplsArgResWithLkup (const Nothing)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Destruction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(1 hmtyinfer || hmtyast).unMkTy.sigs.Rest hs
tyProdArgs      :: Ty -> TyL
tyLHdAndTl      :: [Ty] -> (Ty,TyL)
%%]

%%[(6 hmtyinfer || hmtyast) hs export(tyAppFunArgsWithLkup)
-- Substitution aware
tyAppFunArgsWithLkup :: LookupTy -> Ty -> (Ty,TyL)
tyAppFunArgsWithLkup lookup = tyVarChkVisitLift lookup appUnApp appUnApp
{-# INLINE tyAppFunArgsWithLkup #-}
%%]

%%[(11 hmtyinfer || hmtyast) hs export(tyAppFunArgsMk)
tyAppFunArgsMk    :: Ty -> (Ty, TyL, Ty -> TyL -> Ty)
tyAppFunArgsMk
  =  extr []
  where  extr as t
           =  case tyUnAnn t of
                Ty_TBind q v k t  -> (f,as,\f as -> Ty_TBind q v k $ mk f as)
                                  where (f,as,mk) = tyAppFunArgsMk t
                Ty_App f a        -> extr (a:as) f
                _                 -> (t,as,\f as -> appTopApp (f:as))
%%]

%%[(1 hmtyinfer || hmtyast).unMkTy.tyProdArgs hs
tyProdArgs   = appUnAppArgs
{-# INLINE tyProdArgs #-}
%%]

%%[(1 hmtyinfer || hmtyast).unMkTy.tyLHdAndTl hs
tyLHdAndTl   = hdAndTl' Ty_Any
{-# INLINE tyLHdAndTl #-}
%%]

%%[(4 hmtyinfer || hmtyast).unMkTy.tyConNm hs export(tyMbCon,tyConNm)
tyMbCon :: Ty -> Maybe HsName
-- tyMbCon t = case tyUnAnn t of {Ty_Con nm -> Just nm ; _ -> Nothing}
tyMbCon = appMbCon -- . fst . appUnAnn
{-# INLINE tyMbCon #-}

tyConNm :: Ty -> HsName
tyConNm = maybe hsnUnknown id . tyMbCon
{-# INLINE tyConNm #-}
%%]

%%[(7 hmtyinfer || hmtyast) hs export(tyMbConWithLkup)
tyMbConWithLkup :: LookupTy -> Ty -> Maybe HsName
tyMbConWithLkup lookup = tyVarChkVisitLift lookup tyMbCon tyMbCon
{-# INLINE tyMbConWithLkup #-}
%%]

%%[(3 hmtyinfer || hmtyast).unMkTy.tyMbVar hs export(tyMbVar)
tyMbVar' :: Ty -> Maybe (TyVarId,TyVarCateg)
tyMbVar' t = case tyUnAnn t of {Ty_Var v c -> Just (v,c) ; _ -> Nothing}

tyMbVar :: Ty -> Maybe TyVarId
tyMbVar = fmap fst . tyMbVar'
{-# INLINE tyMbVar #-}
%%]

%%[(4 hmtyinfer || hmtyast) hs
tyMbQu :: Ty -> Maybe TyQu
tyMbQu t
  = case tyUnAnn t of
%%[[4
      Ty_TBind q _ _
%%][6
      Ty_TBind q _ _ _
%%]]
        -> Just q
      _ -> Nothing
%%]

%%[(3 hmtyinfer || hmtyast).unMkTy.tyVar hs export(tyVar)
tyVar :: Ty -> TyVarId
tyVar = maybe uidStart id . tyMbVar
{-# INLINE tyVar #-}
%%]

%%[(9_1 hmtyinfer || hmtyast).tyPlusTy -4_1.tyPlusTy hs
tyPlusTy :: TyPlus -> Ty
tyPlusTy (TyPlus_Ty t _) = t
%%]

%%[(7 hmtyinfer || hmtyast).unMkTy.tyProdArgs -1.unMkTy.tyProdArgs hs
tyProdArgs ty = let (t,al) = tyRecExts ty in map snd al
%%]

%%[(7 hmtyinfer || hmtyast) hs export(tyAppFunMbConNm,tyAppFunConNm)
tyAppFunMbConNm :: Ty -> Maybe HsName
tyAppFunMbConNm = tyMbCon . fst . appUnApp
{-# INLINE tyAppFunMbConNm #-}

tyAppFunConNm :: Ty -> HsName
tyAppFunConNm = tyConNm . fst . appUnApp
{-# INLINE tyAppFunConNm #-}
%%]

%%[(8 hmtyinfer || hmtyast) hs export(tyDataTyNm)
-- | The name of a data type extracted from a Ty
tyDataTyNm :: Ty -> HsName
tyDataTyNm = tyAppFunConNm . appUnArrRes
%%]

%%[(50 hmtyinfer || hmtyast) hs export(tyAllConS)
-- | All constructors occurring in a type
tyAllConS    :: Ty -> Set.Set HsName
tyAllConS t
  =  Set.unions $ (maybe Set.empty Set.singleton $ tyMbCon f) : map tyAllConS a
  where (f,a,_) = tyDecomposeMk t
%%]

%%[(9 hmtyinfer || hmtyast) hs export(tyQuant)
tyQuant :: Ty -> Ty
tyQuant t
  =  case tyUnAnn t of
       Ty_TBind _ _ _ t'  -> tyQuant t'
       _                  -> t
%%]

Substitution aware variants

%%[(9 hmtyinfer || hmtyast) hs export(tyLImplsPreds)
tyLImplsPreds :: TyL -> ([Pred],Impls)
tyLImplsPreds = foldr (\t (ps,i) -> case tyUnAnn t of {Ty_Pred p -> (p:ps,i); Ty_Impls i -> (ps,i)}) ([],Impls_Nil)
%%]

%%[(11 hmtyinfer || hmtyast) hs
tyLamArgsRes :: Ty -> ([TyVarId],Ty)
tyLamArgsRes
  =  extr
  where  extr t
           =  case tyUnAnn t of
                Ty_Lam a r  -> (a:as',r')
                            where (as',r') = extr r
                _           -> ([],t)
%%]

%%[(11 hmtyinfer || hmtyast) hs export(tyLamEtaRed)
-- Eta reduce when the full list of args can be eliminated thus, i.e. it matches with the tail of the args applied in the app (if any) of the body
tyLamEtaRed :: Ty -> Maybe Ty
tyLamEtaRed t
  | llas > 0 && rlDiff >= 0 && map mkTyVar las == rTl = Just (appTopApp (f:rHd))
  | otherwise                                         = Nothing
  where (las,r  ) = tyLamArgsRes t
        (f  ,ras) = appUnApp r
        llas      = length las
        rlas      = length ras
        rlDiff	  = rlas - llas
        (rHd,rTl) = splitAt rlDiff ras
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Construction for records/variants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(7 hmtyinfer || hmtyast) hs
-- mkTyRow :: Ty -> AssocL HsName Ty -> Ty
-- mkTyRow r = foldl (\t (n,e) -> Ty_Ext t n e) r

{-
mkTyRec :: AssocL HsName Ty -> Ty
mkTyRec al = hsnRec `appConApp` [recRowEmp `recRow` al]

mkTyRecExt :: Ty -> AssocL HsName Ty -> Ty
mkTyRecExt recd al
  =  let  (row,exts) = recUnRowExts (recUnRecRow recd)
     in   hsnRec `appConApp` [row `recRow` (exts ++ al)]
-}

-- mkTySum :: AssocL HsName Ty -> Ty
-- mkTySum al = hsnSum `appConApp` [recRowEmp `recRow` al]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Substitution awareness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(6 hmtyinfer || hmtyast) hs
tyVarChkVisitLift :: LookupTy -> (Ty -> x) -> (Ty -> x) -> Ty -> x
tyVarChkVisitLift
  = withLkupChkVisitLift tyMbVar (noVisit . tyUnAnn)
  where noVisit (Ty_TBind _ qv _ _) = Set.singleton qv
        noVisit _                   = Set.empty

tyVarLift :: LookupTy -> (Ty -> x) -> (Ty -> x) -> Ty -> x
tyVarLift = withLkupLift tyMbVar
{-# INLINE tyVarLift #-}
%%]

%%[(9 hmtyinfer || hmtyast) hs
implsTailVarLiftCyc :: (TyVarId -> Maybe Impls) -> (TyVarIdS -> Impls -> x) -> (Impls -> x) -> TyVarIdS -> Impls -> x
implsTailVarLiftCyc = withLkupLiftCyc1 implsMbVar (const Set.empty)
{-# INLINE implsTailVarLiftCyc #-}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Destruction for records
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Substitution aware variants

%%[(7 hmtyinfer || hmtyast) hs export(tyRowExtsWithLkup,tyRecExtrWithLkup,tyRecExtsWithLkup)
tyRowExtsWithLkup :: LookupTy -> Ty -> (Ty,AssocL HsName Ty)
tyRowExtsWithLkup lookup
  =  extr []
  where  extr as t
           =  case tyUnAnn t of
                (Ty_Ext r l e) -> extr ((l,e):as) r
                t'             -> tyVarLift lookup (extr as) (flip (,) as) t'

tyRecExtsWithLkup :: LookupTy -> Ty -> (Ty,AssocL HsName Ty)
tyRecExtsWithLkup lookup t
  =  case tyRecRowWithLkup lookup t of
       Ty_Any  -> (Ty_Any,[])
       row     -> tyRowExtsWithLkup lookup row

tyRecRowWithLkup :: LookupTy -> Ty -> Ty
tyRecRowWithLkup lookup = maybe Ty_Any id . tyMbRecRowWithLkup lookup

tyRowExtrWithLkup :: LookupTy -> HsName -> Ty -> Maybe (Ty,Ty)
tyRowExtrWithLkup lookup lbl t
  = extr t
  where extr t 
          = case tyUnAnn t of
              (Ty_Ext r l e) | lbl == l   -> Just (r,e)
                             | otherwise  -> maybe Nothing (\(r',e') -> Just (Ty_Ext r' l e,e')) (extr r)
              t'                          -> tyVarLift lookup extr (const Nothing) t'

tyRecExtrWithLkup :: LookupTy -> HsName -> Ty -> Maybe (Ty,Ty)
tyRecExtrWithLkup lookup lbl t
  =  case tyRowExtrWithLkup lookup lbl (tyRecRowWithLkup lookup t) of
       Nothing    -> Nothing
       Just (r,e) -> Just (hsnRec `appConApp` [r],e)

tyMbRecRowWithLkup :: LookupTy -> Ty -> Maybe Ty
tyMbRecRowWithLkup lookup t
  =  case tyAppFunArgsWithLkup lookup t of
       (f,[row])
         -> case tyMbConWithLkup lookup f of
              Just n | hsnIsRec n || hsnIsSum n -> Just row
              _                                 -> Nothing
       _                                        -> Nothing

%%]

%%[(8 hmtyinfer || hmtyast) hs
%%]

%%[(7 hmtyinfer || hmtyast) hs export(tyRowExtr,tyRecExtr,tyRecExts)
-- tyMbRecRow :: Ty -> Maybe Ty
-- tyMbRecRow = tyMbRecRowWithLkup (const Nothing)
-- {-# INLINE tyMbRecRow #-}
{-
  =  case tyAppFunArgs t of
       (Ty_Con n,[row]) | hsnIsRec n || hsnIsSum n -> Just row
       _                                           -> Nothing
-}

-- tyRecRow :: Ty -> Ty
-- tyRecRow = maybe Ty_Any id . recMbRecRow
-- {-# INLINE tyRecRow #-}

-- tyRowExts :: Ty -> (Ty,AssocL HsName Ty)
-- tyRowExts = tyRowExtsWithLkup (const Nothing)
-- {-# INLINE tyRowExts #-}

tyRecExts :: Ty -> (Ty,AssocL HsName Ty)
tyRecExts = tyRecExtsWithLkup (const Nothing)
{-# INLINE tyRecExts #-}

tyRowExtr :: HsName -> Ty -> Maybe (Ty,Ty)
tyRowExtr = tyRowExtrWithLkup (const Nothing)
{-# INLINE tyRowExtr #-}

tyRecExtr :: HsName -> Ty -> Maybe (Ty,Ty)
tyRecExtr = tyRecExtrWithLkup (const Nothing)
{-# INLINE tyRecExtr #-}
%%]

%%[(98 hmtyinfer || hmtyast) hs export(tyMbRecExts)
tyMbRecExts :: Ty -> Maybe (Ty,AssocL HsName Ty)
tyMbRecExts = fmap recUnRowExts . recMbRecRow
%%]

%%[(8 hmtyinfer || hmtyast) hs export(tyRecExts2)
tyRecExts2 :: Ty -> AssocL HsName (AssocL HsName Ty)
tyRecExts2
  = assocLMapElt (snd . tyRecExts) . snd . tyRecExts
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% General purpose decomposition + reconstruction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(11 hmtyinfer || hmtyast) hs export(tyDecomposeMk)
tyDecomposeMk    :: Ty -> (Ty, TyL, Ty -> TyL -> Ty)
tyDecomposeMk t
  = case t of
      Ty_TBind q v k t' -> (f,as,\f' as' -> Ty_TBind q v k $ mk f' as')
                        where (f,as,mk) = tyDecomposeMk t'
      Ty_App _ _        -> (f,as,\f' as' -> appTopApp (f':as'))
                        where (f,as) = appUnApp t
      Ty_Ext _ _ _      -> (r,assocLElts e,\r' e' -> recRow r' $ zip (assocLKeys e) e')
                        where (r,e) = recUnRowExts t
      _ | not (null an) -> (t2,as,\f' as' -> mk1 $ mk2 f' as')
        | otherwise     -> (t,[],const)
                        where (t1,an,mk1) = tyAnnDecomposeMk t
                              (t2,as,mk2) = tyDecomposeMk    t1
%%]

%%[(11 hmtyinfer || hmtyast) hs export(tyRecMap)
-- | Map 'f' over fields of record
tyRecMap :: (Ty -> Ty) -> Ty -> Ty
tyRecMap f r
  = mk rem (map f fs)
  where (rem,fs,mk) = tyDecomposeMk r
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Canonical ordering of fields of record
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(10 hmtyinfer || hmtyast) hs export(tyRowIsCanonOrdered)
tyRowIsCanonOrdered :: AssocL HsName a -> Bool
tyRowIsCanonOrdered = isSortedByOn rowLabCmp fst
{-# INLINE tyRowIsCanonOrdered #-}
%%]

%%[(7 hmtyinfer || hmtyast) hs export(rowExtCmp)
rowExtCmp :: (HsName,a) -> (HsName,a) -> Ordering
rowExtCmp (n1,_) (n2,_) = n1 `rowLabCmp` n2
{-# INLINE rowExtCmp #-}

-- tyRowCanonOrderBy :: (o -> o -> Ordering) -> AssocL o a -> AssocL o a
-- tyRowCanonOrderBy = rowCanonOrderBy
-- {-# INLINE tyRowCanonOrderBy #-}

-- tyRowCanonOrder :: AssocL HsName a -> AssocL HsName a
-- tyRowCanonOrder = tyRowCanonOrderBy rowLabCmp
-- {-# INLINE tyRowCanonOrder #-}
%%]

%%[(8 hmtyinfer || hmtyast) hs export(tyRowOffsetOrder)
tyRowOffsetOrder :: (a -> Int) -> AssocL HsName a -> AssocL HsName a
tyRowOffsetOrder off = sortOnLazy (off . snd)
{-# INLINE tyRowOffsetOrder #-}
%%]

%%[(8 hmtyinfer || hmtyast) hs export(tyExtsOffset)
tyExtsOffset :: HsName -> AssocL HsName a -> ((Int,Presence),Maybe a)
tyExtsOffset lbl exts
  = find 0 lbl exts
  where find o l (e@(_,a):es) = case (l,panic "Ty.tyExtsOffset") `rowExtCmp` e of
                            GT -> find (o+1) l es
                            EQ -> ((o,Present),Just a)
                            LT -> ((o,Absent),Nothing)
        find o _ []     = ((o,Absent),Nothing)

tyRecOffset :: HsName -> Ty -> Int
tyRecOffset lbl t
  = fst $ fst $ tyExtsOffset lbl $ rowCanonOrder exts
  where (_,exts) = tyRecExts t
%%]

Substitution aware

%%[(8 hmtyinfer || hmtyast) hs export(tyRecOffsetWithLkup)
tyRecOffsetWithLkup :: LookupTy -> HsName -> Ty -> Int
tyRecOffsetWithLkup lookup nm
  = tyVarLift lookup o o
  where o = tyRecOffset nm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Destruction for predicates
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 hmtyinfer || hmtyast) hs export(tyPred,predNm,tyPredNm,tyPrArrowArgsRes)
tyPred :: Ty -> Pred
tyPred t
  =  case tyUnAnn t of
       Ty_Pred pt  -> pt
       _           -> Pred_Pred t

predNm :: Pred -> HsName
predNm = tyAppFunConNm . predTy
{-# INLINE predNm #-}

tyPredNm :: Ty -> HsName
tyPredNm = predNm . tyPred
{-# INLINE tyPredNm #-}

tyPrArrowArgsRes :: Ty -> ([Pred],Pred)
tyPrArrowArgsRes tp = let (tl,t) = appUnArr tp in (map tyPred tl, tyPred t)
%%]

%%[(9 hmtyinfer || hmtyast) hs export(tyPredMatchNmArgs,predMatchNmArgs)
-- | extract class name and class args of predicate packages as Ty
tyPredMatchNmArgs :: Ty -> (HsName,[Ty])
tyPredMatchNmArgs = predMatchNmArgs . tyPred
{-# INLINE tyPredMatchNmArgs #-}

-- | extract class name and class args of predicate
predMatchNmArgs :: Pred -> (HsName,[Ty])
predMatchNmArgs p
  =  case p of
       Pred_Class t    -> (tyAppFunConNm t, appUnAppArgs t)
       Pred_Pred  t    -> predMatchNmArgs $ snd $ tyPrArrowArgsRes t
%%[[10
       Pred_Lacks _ (Label_Lab l)  -> (hsnUniqify HsNameUniqifier_LacksLabel l, [])
       Pred_Lacks _ _              -> (mkHNm "_LabVar_", [])      -- necessary? only used by CHR's
%%]]
%%[[31
       Pred_Eq t1 t2   -> (hsnEqTilde,[t1,t2])
%%]]
%%]

%%[(9 hmtyinfer || hmtyast) hs export(tyPred2DataTy,pred2DataTy)
-- | construct for a predicate its corresponding data type
pred2DataTy :: Pred -> Ty
pred2DataTy p
  = appConApp (hsnClass2Dict n) as
  where (n,as) = predMatchNmArgs p

-- | construct for a predicate packaged as a Ty its corresponding data type
tyPred2DataTy :: Ty -> Ty
tyPred2DataTy = pred2DataTy . tyPred
{-# INLINE tyPred2DataTy #-}
%%]

%%[(9 hmtyinfer || hmtyast) hs export(predTy)
predTy :: Pred -> Ty
predTy p
  =  case p of
       Pred_Class t    -> t
       Pred_Pred  t    -> t
%%[[10
       Pred_Lacks    t _  -> t
%%]]
%%[[31
       Pred_Eq t _ -> t  -- does it matter if we return the left or the right type?
%%]]
%%]

%%[(13 hmtyinfer || hmtyast) hs export(predSeqToList,predLFlatten)
predSeqToList :: PredSeq -> [Pred]
predSeqToList (PredSeq_Cons h t) = h : predSeqToList t
predSeqToList _                  = []

predLFlatten :: [Pred] -> [Pred]
predLFlatten
  = concatMap fl
  where fl (Pred_Preds s) = predSeqToList s
        fl p              = [p]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Predicates & evidence
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 hmtyinfer || hmtyast) hs export(predHasRuntimeEvidence)
-- | Is runtime evidence required for the predicate?
predHasRuntimeEvidence :: Pred -> Bool
predHasRuntimeEvidence p
  =  case p of
%%[[31
       Pred_Eq _ _ -> False
%%]]
       _           -> True
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Deconstruction for implicits
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Substitution aware

%%[(9 hmtyinfer || hmtyast) hs export(implsPredsTailWithLkup,tyImplsWithLkup,implsPrIdLWithLkup)
implsPredsTailWithLkup' :: (TyVarId -> Maybe Impls) -> PredScope -> Impls -> ([(PredOcc,[ImplsProveOcc])],Impls)
implsPredsTailWithLkup' lookup sc i
  = extr Set.empty i
  where extr vsVisited i
          = case i of
%%[[9
              Impls_Cons _ p pv ipos t
                -> ((mkPredOcc p pv sc,ipos) : p',mi)
%%][99
              Impls_Cons _ p pv prange ipos t
                -> ((mkPredOccRng prange p pv sc,ipos) : p',mi)
%%]]
                where (p',mi) = extr vsVisited t
              _ -> implsTailVarLiftCyc lookup extr ((,) []) vsVisited i

implsPredsTailWithLkup :: (TyVarId -> Maybe Impls) -> PredScope -> Impls -> ([PredOcc],Impls)
implsPredsTailWithLkup lookup sc i
  = (map fst is,t)
  where (is,t) = implsPredsTailWithLkup' lookup sc i

tyImplsWithLkup :: LookupTy -> Ty -> Impls
tyImplsWithLkup lookup = tyVarLift lookup tyImpls tyImpls
{-# INLINE tyImplsWithLkup #-}

implsPrIdLWithLkup :: (TyVarId -> Maybe Impls) -> Impls -> [PredOccId]
implsPrIdLWithLkup lookup = map poPoi . fst . implsPredsTailWithLkup lookup initPredScope
{-# INLINE implsPrIdLWithLkup #-}

%%]

%%[(9 hmtyinfer || hmtyast) hs export()
tyMbVarWithLkup :: LookupTy -> Ty -> Maybe TyVarId
tyMbVarWithLkup lookup = tyVarLift lookup tyMbVar tyMbVar
%%]

%%[(9 hmtyinfer || hmtyast) hs export(tyImpls,implsPredsTail,implsPredsMbTail,implsIsTail,tyIsImplsTail,tyImplsPreds,implsPrIdPredL,implsPrIdL)
tyMbImpls :: Ty -> Maybe Impls
tyMbImpls
  = extr . tyUnAnn
  where extr (Ty_Impls i) = Just i
        extr _            = Nothing

tyImpls :: Ty -> Impls
tyImpls = panicJust "tyImpls" . tyMbImpls
{-# INLINE tyImpls #-}

implsPredsTail' :: PredScope -> Impls -> ([(PredOcc,[ImplsProveOcc])],Impls)
implsPredsTail' = implsPredsTailWithLkup' (const Nothing)
{-# INLINE implsPredsTail' #-}

implsPredsTail :: PredScope -> Impls -> ([PredOcc],Impls)
implsPredsTail = implsPredsTailWithLkup (const Nothing)
{-# INLINE implsPredsTail #-}

implsPredsMbTail :: Impls -> ([(PredOcc,[ImplsProveOcc])],Maybe Impls)
implsPredsMbTail i =  case implsPredsTail' initPredScope i of
                        (i',t@(Impls_Tail _ _)) -> (i',Just t)
                        (i',   Impls_Nil      ) -> (i',Nothing)

tyImplsPreds :: PredScope -> Ty -> [PredOcc]
tyImplsPreds sc = fst . implsPredsTail sc . tyImpls
{-# INLINE tyImplsPreds #-}

implsIsTail :: Impls -> Bool
implsIsTail = isJust . implsMbVar
{-# INLINE implsIsTail #-}

tyIsImplsTail :: Ty -> Bool
tyIsImplsTail = implsIsTail . tyImpls
{-# INLINE tyIsImplsTail #-}

implsPrIdPredL :: Impls -> [(PredOccId,Pred)]
implsPrIdPredL i = [ (poPoi po, poPr po) | po <- fst $ implsPredsTail initPredScope i ]

implsPrIdL :: Impls -> [PredOccId]
implsPrIdL = map fst . implsPrIdPredL
{-# INLINE implsPrIdL #-}
%%]

%%[(9 hmtyinfer || hmtyast) hs export(tyMb1ArrTailVar2VarWithLkup)
-- | Is an 'Impls' the tail (last empty element) of a sequence?
implsMbTailVarWithLkup :: LookupImpls -> Impls -> Maybe ImplsVarId
implsMbTailVarWithLkup lkup (Impls_Tail iv _) = maybe (Just iv) (const Nothing) (lkup iv)
implsMbTailVarWithLkup _    _                 = Nothing
{-# INLINE implsMbTailVarWithLkup #-}

-- | Is a 'Ty' the tail of an Impls?
tyMbTailVarWithLkup :: LookupImpls -> Ty -> Maybe ImplsVarId
tyMbTailVarWithLkup lkup t = do { i <- tyMbImpls t ; implsMbTailVarWithLkup lkup i }
{-# INLINE tyMbTailVarWithLkup #-}

-- | Is 'Ty' a function type from an Impls tail to ...
tyMb1ArrTailVarWithLkup :: LookupImpls -> Ty -> Maybe (ImplsVarId,Ty)
tyMb1ArrTailVarWithLkup lkup t = do { (a,r) <- appMb1Arr t; i <- tyMbTailVarWithLkup lkup a; return (i,r) }
{-# INLINE tyMb1ArrTailVarWithLkup #-}

-- | Is 'Ty' a function type from an Impls tail to a ty var
tyMb1ArrTailVar2VarWithLkup :: LookupTy -> LookupImpls -> Ty -> Maybe (ImplsVarId,TyVarId)
tyMb1ArrTailVar2VarWithLkup lkupt lkupi t = do { (i,r) <- tyMb1ArrTailVarWithLkup lkupi t; v <- tyMbVarWithLkup lkupt r; return (i,v) }
%%]

%%[(9 hmtyinfer || hmtyast) hs export(implsMbVar,implsTailVar)
implsMbVar :: Impls -> Maybe TyVarId
implsMbVar (Impls_Tail v _)  = Just v
implsMbVar _                 = Nothing

implsTailVar :: Impls -> ImplsVarId
implsTailVar = panicJust "implsTailVar" . implsMbVar
{-# INLINE implsTailVar #-}
%%]

%%[(9 hmtyinfer || hmtyast) hs export(implsIsEmpty)
implsIsEmpty :: Impls -> Bool
%%[[9
implsIsEmpty (Impls_Cons _ _ _   _ _) = False
%%][99
implsIsEmpty (Impls_Cons _ _ _ _ _ _) = False
%%]]
implsIsEmpty _                        = True
%%]

%%[(9 hmtyinfer || hmtyast) hs export(tyIsPredicated,tyIsPredicatedWithLkup)
tyIsPredicated :: Ty -> Bool
tyIsPredicated (Ty_Impls i) = not $ implsIsEmpty i
tyIsPredicated t            = isPr a
                            where a = map tyUnAnn $ appUnArrArgs t
                                  isPr (Ty_Pred p:_) = True
                                  isPr _             = False

tyIsPredicatedWithLkup :: LookupTy -> Ty -> Bool
tyIsPredicatedWithLkup lookup = tyVarLift lookup tyIsPredicated tyIsPredicated
{-# INLINE tyIsPredicatedWithLkup #-}
%%]

%%[(10 hmtyinfer || hmtyast) hs export(labelMbVar)
labelMbVar :: Label -> Maybe TyVarId
labelMbVar (Label_Var v)  = Just v
labelMbVar _              = Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Key into TyKiGam
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[6 hs export(TyKiKey(..))
data TyKiKey
  = TyKiKey_Name    !HsName
%%[[(6 hmtyinfer || hmtyast)
  | TyKiKey_TyVar   !TyVarId
%%]]
  deriving (Eq,Ord,Generic)

instance Show TyKiKey where
  show (TyKiKey_Name  n) = show n
%%[[(6 hmtyinfer || hmtyast)
  show (TyKiKey_TyVar v) = show v
%%]]
%%]

%%[(50 hmtyinfer || hmtyast) hs
deriving instance Typeable TyKiKey
%%]

%%[6 hs export(tyKiKeyMbName)
tyKiKeyMbName :: TyKiKey -> Maybe HsName
tyKiKeyMbName (TyKiKey_Name n) = Just n
%%[[(6 hmtyinfer || hmtyast)
tyKiKeyMbName _                = Nothing
%%]]
%%]

%%[6 hs export(tyKiKeyIsName)
tyKiKeyIsName :: TyKiKey -> Bool
tyKiKeyIsName = isJust . tyKiKeyMbName
{-# INLINE tyKiKeyIsName #-}
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Context of type
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 hmtyinfer || hmtyast) hs
data TyCtxt = TyCtxt_Ty | TyCtxt_Pred | TyCtxt_Class deriving (Show,Eq)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Co/Contra variance
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Polarities, construction + inspection
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(4 hmtyinfer || hmtyast) hs export(Polarity)
type Polarity = Ty
%%]

%%[(4 hmtyinfer || hmtyast) hs export(polCovariant, polContravariant, polInvariant)
polCovariant :: Polarity
polCovariant = appCon hsnCovariant

polContravariant :: Polarity
polContravariant = appCon hsnContravariant

polInvariant :: Polarity
polInvariant = appCon hsnInvariant
%%]

%%[(17 hmtyinfer || hmtyast) hs export(mkPolNegate, mkPolVar)
mkPolNegate :: Polarity -> Polarity
mkPolNegate = appCon1App hsnPolNegation

mkPolVar :: UID -> Polarity
mkPolVar = mkTyVar
%%]

%%[(4 hmtyinfer || hmtyast) hs export(polIsCovariant, polIsContravariant, polIsInvariant)
polIs :: HsName -> Polarity -> Bool
polIs nm = maybe False (== nm) . tyMbCon

polIsCovariant, polIsContravariant, polIsInvariant :: Polarity -> Bool
polIsCovariant     = polIs hsnCovariant
polIsContravariant = polIs hsnContravariant
polIsInvariant     = polIs hsnInvariant
%%]

%%[(4 hmtyinfer || hmtyast) hs export(polOpp)
polOpp :: Polarity -> Polarity
polOpp pol | polIsCovariant     pol = polContravariant
           | polIsContravariant pol = polCovariant
           | otherwise              = polInvariant
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fitting mode (should be in FitsIn, but here it avoids mut rec modules)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(4 hmtyinfer || hmtyast).FIMode hs export(FIMode(..))
data FIMode  =  FitSubLR
             |  FitSubRL
             |  FitUnify
             deriving (Eq,Ord)
%%]

%%[(4 hmtyinfer || hmtyast) hs export(fimOpp)
fimOpp :: FIMode -> FIMode
fimOpp m
  =  case m of
       FitSubLR  -> FitSubRL
       FitSubRL  -> FitSubLR
       _         -> m
%%]

%%[(4 hmtyinfer || hmtyast) hs export(fimSwapPol)
fimSwapPol :: Polarity -> FIMode -> FIMode
fimSwapPol pol m = if polIsContravariant pol then fimOpp m else m
%%]

%%[(4 hmtyinfer || hmtyast) hs
instance Show FIMode where
  show FitSubLR  = "<="
  show FitSubRL  = ">="
  show FitUnify  = "=="
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Instantiation trace
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

An InstTo encodes the instantiation structure.
It gives evidence of instantiation is done.

%%[(4 hmtyinfer || hmtyast) hs export(InstTo(..))
data InstTo
  = InstTo_Plain        				-- a plain value
  | InstTo_Qu                           -- the fresh type (tyvar) instantiated to
      { instoQu     	:: TyQu			-- how tvar was quantified, also includes the meta level
      , instoFrom   	:: TyVarId		-- the tvar from which is instantiated
      , instoTo     	:: TyVarId		-- the new tvar to which is instantiated
%%[[6
      , instoL1     	:: Ty
%%]]
      }
{-
  | InstTo_Lam                          -- a lambda
      { instoLam    :: [InstTo]
      }
-}
  deriving Show
%%]

%%[(4 hmtyinfer || hmtyast) hs
instToIsQu :: InstTo -> Bool
%%[[4
instToIsQu (InstTo_Qu _ _ _  ) = True
%%][6
instToIsQu (InstTo_Qu _ _ _ _) = True
%%]]
instToIsQu _                   = False
%%]

%%[(4 hmtyinfer || hmtyast) hs export(instToSplitQu)
-- split of initial quantifier instantiations, to be used for Sys F generation for type parameterization
instToSplitQu :: [InstTo] -> ([InstTo],[InstTo])
instToSplitQu = span instToIsQu
%%]

%%[(6 hmtyinfer || hmtyast) hs export(instToL1AssocL)
-- get tvar -> kind bindings of instantiation
instToL1AssocL :: [InstTo] -> AssocL TyVarId (MetaLev,Ty)
instToL1AssocL l = [ (v,(tyquMetaLev q,k)) | (InstTo_Qu q _ v k) <- l ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Error
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 hmtyinfer || hmtyast) hs export(tyErr)
-- a for the time being placeholder for yet unresolved/unpropagated type
tyErr :: String -> Ty
tyErr = appDbg
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Instances: Binary
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[50 hs
instance Serialize TyKiKey
%%]

%%[5050 hs
instance Serialize TyKiKey where
--   sput (TyKiKey_Name  a) = sputWord8 0 >> sput a
-- %%[[(50 hmtyinfer || hmtyast)
--   sput (TyKiKey_TyVar a) = sputWord8 1 >> sput a
-- %%]]
--   sget = do t <- sgetWord8
--             case t of
--               0 -> liftM TyKiKey_Name  sget
-- %%[[(50 hmtyinfer || hmtyast)
--               1 -> liftM TyKiKey_TyVar sget
-- %%]]
%%]

%%[(50 hmtyinfer || hmtyast) hs
instance Binary ImplsProveOcc where
  put (ImplsProveOcc a b) = put a >> put b
  get = liftM2 ImplsProveOcc get get

instance Serialize ImplsProveOcc where
  sput = sputPlain
  sget = sgetPlain

instance Binary PredScope where
  put (PredScope_Lev   a      ) = putWord8 0  >> put a
  put (PredScope_Var   a      ) = putWord8 1  >> put a
  get = do tag <- getWord8
           case tag of
             0  -> liftM  PredScope_Lev   get
             1  -> liftM  PredScope_Var   get

instance Serialize PredScope where
  sput = sputPlain
  sget = sgetPlain

instance Binary CHRPredOccCxt where
  put (CHRPredOccCxt_Scope1 a) = put a
  get = liftM CHRPredOccCxt_Scope1 get

instance Serialize CHRPredOccCxt where
  sput = sputPlain
  sget = sgetPlain

instance Binary LabelOffset where
  put (LabelOffset_Off a) = putWord8 0 >> put a
  put (LabelOffset_Var a) = putWord8 1 >> put a
  get = do t <- getWord8
           case t of
             0 -> liftM LabelOffset_Off get
             1 -> liftM LabelOffset_Var get

instance Serialize LabelOffset where
  sput = sputPlain
  sget = sgetPlain

%%]

%%[50 hs
instance Binary TyQu where
  put (TyQu_Forall a) = putWord8 0 >> put a
  put (TyQu_Exists a) = putWord8 1 >> put a
  put (TyQu_Plain  a) = putWord8 1 >> put a
  get = do tag <- getWord8
           case tag of
             0 -> liftM  TyQu_Forall   get
             1 -> liftM  TyQu_Exists   get
             2 -> liftM  TyQu_Plain    get

instance Serialize TyQu where
  sput = sputPlain
  sget = sgetPlain
%%]

%%[(50 hmtyinfer || hmtyast) hs
instance Serialize Ty
instance Serialize TyAnn
instance Serialize Pred
instance Serialize Label
instance Serialize PredSeq
instance Serialize Impls
instance Serialize CHRPredOcc
%%]

%%[(5050 hmtyinfer || hmtyast) hs
instance Serialize Ty where
  -- sput (Ty_Con   a      ) = sputWord8 0  >> sput a
  -- sput (Ty_App   a b    ) = sputWord8 1  >> sput a >> sput b
  -- sput (Ty_Ann   a b    ) = sputWord8 2  >> sput a >> sput b
  -- sput (Ty_Var   a b    ) = sputWord8 3  >> sput a >> sput b
  -- sput (Ty_Any          ) = sputWord8 4
  -- sput (Ty_TBind a b c d) = sputWord8 5  >> sput a >> sput b >> sput c >> sput d
  -- sput (Ty_Ext   a b c  ) = sputWord8 6  >> sput a >> sput b >> sput c
  -- sput (Ty_Pred  a      ) = sputWord8 7  >> sput a
  -- sput (Ty_Lam   a b    ) = sputWord8 8  >> sput a >> sput b
  -- sput (Ty_Impls a      ) = sputWord8 9  >> sput a
  -- sput (Ty_Dbg   a      ) = sputWord8 10 >> sput a
  -- sget = do tag <- sgetWord8
  --           case tag of
  --             0  -> liftM  Ty_Con   sget
  --             1  -> liftM2 Ty_App   sget sget
  --             2  -> liftM2 Ty_Ann   sget sget
  --             3  -> liftM2 Ty_Var   sget sget
  --             4  -> return Ty_Any
  --             5  -> liftM4 Ty_TBind sget sget sget sget
  --             6  -> liftM3 Ty_Ext   sget sget sget
  --             7  -> liftM  Ty_Pred  sget
  --             8  -> liftM2 Ty_Lam   sget sget
  --             9  -> liftM  Ty_Impls sget
  --             10 -> liftM  Ty_Dbg   sget

instance Serialize TyAnn where
  -- sput (TyAnn_Empty       ) = sputWord8 0
  -- sput (TyAnn_Mono        ) = sputWord8 1
  -- sput (TyAnn_Strictness a) = sputWord8 2  >> sput a
  -- sget = do tag <- sgetWord8
  --           case tag of
  --             0 -> return TyAnn_Empty
  --             1 -> return TyAnn_Mono
  --             2 -> liftM  TyAnn_Strictness sget


instance Serialize Pred where
--   sput (Pred_Class  a  ) = sputWord8 0 >> sput a
--   sput (Pred_Pred   a  ) = sputWord8 1 >> sput a
--   sput (Pred_Lacks  a b) = sputWord8 2 >> sput a >> sput b
--   sput (Pred_Arrow  a b) = sputWord8 3 >> sput a >> sput b
-- %%[[31
--   sput (Pred_Eq     a b) = sputWord8 4 >> sput a >> sput b
-- %%]]
--   sput (Pred_Var    a  ) = sputWord8 5 >> sput a
--   sput (Pred_Preds  a  ) = sputWord8 6 >> sput a
--   sget = do tag <- sgetWord8
--             case tag of
--               0 -> liftM  Pred_Class   sget
--               1 -> liftM  Pred_Pred    sget
--               2 -> liftM2 Pred_Lacks   sget sget
--               3 -> liftM2 Pred_Arrow   sget sget
-- %%[[31
--               4 -> liftM2 Pred_Eq      sget sget
-- %%]]
--               5 -> liftM  Pred_Var     sget
--               6 -> liftM  Pred_Preds   sget

instance Serialize Label where
  -- sput (Label_Lab  a) = sputWord8 0 >> sput a
  -- sput (Label_Var  a) = sputWord8 1 >> sput a
  -- sget = do tag <- sgetWord8
  --           case tag of
  --             0 -> liftM  Label_Lab   sget
  --             1 -> liftM  Label_Var   sget

instance Serialize PredSeq where
  -- sput (PredSeq_Nil          ) = sputWord8 0
  -- sput (PredSeq_Cons  a b    ) = sputWord8 1  >> sput a >> sput b
  -- sput (PredSeq_Var   a      ) = sputWord8 2  >> sput a
  -- sget = do tag <- sgetWord8
  --           case tag of
  --             0  -> return PredSeq_Nil
  --             1  -> liftM2 PredSeq_Cons  sget sget
  --             2  -> liftM  PredSeq_Var   sget

{-
instance Binary PredSeq where
  put = putList (PredSeq_Nil ==) (\(PredSeq_Cons a b) -> (a,b))
  get = getList PredSeq_Nil PredSeq_Cons
-}

instance Serialize CHRPredOcc where
-- %%[[50
  -- sput (CHRPredOcc a b  ) = sput a >> sput b
%%[[99
  -- Range info is stripped on the fly
  sput (CHRPredOcc a b _) = sput a >> sput b
%%]]
-- %%[[50
  -- sget = liftM2 CHRPredOcc sget sget
%%[[99
  -- Range info is stripped on the fly
  sget = liftM2 (\a b -> CHRPredOcc a b emptyRange) sget sget
%%]]

instance Serialize Impls where
--   sput (Impls_Nil             ) = sputWord8 0
--   sput (Impls_Tail a b        ) = sputWord8 1  >> sput a >> sput b
-- %%[[50
--   sput (Impls_Cons a b c d e  ) = sputWord8 2  >> sput a >> sput b >> sput c >> sput d >> sput e
-- %%][99
--   sput (Impls_Cons a b c d e f) = sputWord8 2  >> sput a >> sput b >> sput c >> sput d >> sput e >> sput f
-- %%]]
--   sget = do tag <- sgetWord8
--             case tag of
--               0  -> return Impls_Nil
--               1  -> liftM2 Impls_Tail  sget sget
--               2  ->
-- %%[[50
--                     liftM5 Impls_Cons  sget sget sget sget sget
-- %%][99
--                     liftM6 Impls_Cons  sget sget sget sget sget sget
-- %%]]

%%]

%%[(50 hmtyinfer || hmtyast) hs
instance Binary TyVarCateg where
  put = putEnum8
  get = getEnum8

instance Serialize TyVarCateg where
  sput = sputPlain
  sget = sgetPlain
%%]

