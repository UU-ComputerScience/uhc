%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Grin's byte code gen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs module {%{EH}GrinCode.ToGrinByteCode}
%%]

%%[(8 codegen grin) hs import(Data.Maybe, Data.List as L, UHC.Util.Pretty, qualified UHC.Util.FastSeq as Seq, UHC.Util.Utils, qualified Data.Set as Set, qualified Data.Map as Map)
%%]

%%[(8 codegen grin) hs import({%{EH}Base.Common},{%{EH}Opts},{%{EH}Base.Builtin},qualified {%{EH}Config} as Cfg)
%%]

%%[(8 codegen grin) hs import({%{EH}Error},{%{EH}BuiltinPrims})
%%]

%%[(8 codegen grin) hs import({%{EH}GrinCode.Pretty})
%%]
%%[(8 codegen grin) hs import({%{EH}GrinByteCode}, qualified {%{EH}GrinByteCode} as GB,{%{EH}Core},{%{EH}GrinCode},{%{EH}LamInfo})
%%]
%%[(8 codegen grin) hs import({%{EH}CodeGen.ValAccess} as VA, {%{EH}CodeGen.RefGenerator})
%%]
%%[(8 codegen grin) hs import({%{EH}CodeGen.Const} as Const)
%%]

%%[(5050 codegen grin) hs import({%{EH}Ty(tyRowCanonOrder)},{%{EH}HI})
%%]

%%[(8 codegen grin) hs import({%{EH}Foreign.Extract})
%%]

%%[(8 codegen grin) ag import({GrinCode/Trf/CommonFreeVar},{GrinCode/Trf/CommonIntroName},{GrinCode/CommonForGen},{GrinCode/CommonValAccess})
%%]

Debug
%%[(8 codegen grin) hs import({%{EH}Base.Debug})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin).grinMod2ByteCodeMod hs export(grinMod2ByteCodeMod)
grinMod2ByteCodeMod :: EHCOpts -> GrModule -> (GB.Module,[Err])
grinMod2ByteCodeMod opts gmod
  =  let  t = wrap_GrAGItf  (sem_GrAGItf (GrAGItf_AGItf gmod))
                            (Inh_GrAGItf
                               {opts_Inh_GrAGItf = opts
                               })
     in   (gbMod_Syn_GrAGItf t, errs_Syn_GrAGItf t)
%%]

%%[(50 codegen grin) -8.grinMod2ByteCodeMod hs export(grinMod2ByteCodeMod)
grinMod2ByteCodeMod :: EHCOpts -> LamMp -> [HsName] -> {- [HsName] -> -} HsName2FldMpMp -> HsName2FldMp -> GrModule -> (GB.Module,[Err])
grinMod2ByteCodeMod opts lamMp allImpNmL {- impNmL -} impNmFldMpMp expNmFldMp gmod
  =  let  t = wrap_GrAGItf  (sem_GrAGItf (GrAGItf_AGItf gmod))
                            (Inh_GrAGItf
                               { expNmFldMp_Inh_GrAGItf     = expNmFldMp
                               , impNmFldMpMp_Inh_GrAGItf   = impNmFldMpMp
                               , allImpNmL_Inh_GrAGItf      = allImpNmL
                               , opts_Inh_GrAGItf           = opts
                               , lamMp_Inh_GrAGItf          = lamMp
                               })
     in   (gbMod_Syn_GrAGItf t, errs_Syn_GrAGItf t)
%%]

%%[(8 codegen grin) ag import({GrinCode/AbsSyn})
WRAPPER GrAGItf
%%]

There is a cyclic dependency:

*** UU.AG warning  ***
problem  : Direct circular dependency pattern for inherited attribute
            stkDepth and synthesized attribute i of nonterminal GrAltL
pattern  : see help
help     : The following attributes formed the cycle:
           GrExpr.Case, inherited attribute altL.stkDepth ("build/8/lib-grinc/GRIN8/GrinCode/ToGrinByteCode.ag"(line 158, column 33))
           GrAltL.Cons, inherited attribute lhs.stkDepth
           GrAltL.Cons, inherited attribute hd.stkDepth ("build/8/lib-grinc/GRIN8/GrinCode/ToGrinByteCode.ag"(line 147, column 20))
           GrAlt.Alt, inherited attribute lhs.stkDepth
           GrAlt.Alt, local attribute stkDepth ("build/8/lib-grinc/GRIN8/GrinCode/ToGrinByteCode.ag"(line 166, column 33))
           GrAlt.Alt, inherited attribute expr.stkDepth ("build/8/lib-grinc/GRIN8/GrinCode/ToGrinByteCode.ag"(line 147, column 20))
           GrExpr.App, inherited attribute lhs.stkDepth
           GrExpr.App, local attribute retIns ("build/8/lib-grinc/GRIN8/GrinCode/ToGrinByteCode.ag"(line 442, column 33))
           GrExpr.App, synthesized attribute lhs.i ("build/8/lib-grinc/GRIN8/GrinCode/ToGrinByteCode.ag"(line 483, column 33))
           GrAlt.Alt, synthesized attribute expr.i
           GrAlt.Alt, synthesized attribute lhs.i ("build/8/lib-grinc/GRIN8/GrinCode/ToGrinByteCode.ag"(line 487, column 33))
           GrAltL.Cons, synthesized attribute hd.i
           GrAltL.Cons, synthesized attribute lhs.i ("build/8/lib-grinc/GRIN8/GrinCode/ToGrinByteCode.ag"(line 476, column 30))
           GrExpr.Case, synthesized attribute altL.i
           GrExpr.Case, local attribute scrutineeStkInc ("build/8/lib-grinc/GRIN8/GrinCode/ToGrinByteCode.ag"(line 380, column 61))
           GrExpr.Case, inherited attribute altL.stkDepth ("build/8/lib-grinc/GRIN8/GrinCode/ToGrinByteCode.ag"(line 158, column 33))

but tearing apart the culprit definition hides the connection between these:

  | Case        loc         .   (valIns,valStkInc,retIsDone,scrutineeStkInc)

perhaps later...

%%[(8 codegen grin)
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Global info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllBind AllGrExpr GrModule GrAGItf
  [ opts: EHCOpts
%%[[50
    lamMp: LamMp
%%]]
  | |
  ]
%%]

%%[(8 codegen grin)
%%]
ATTR AllNTNoMod [ modNmConstInx: Int | | ]

%%[(50 codegen grin)
ATTR GrAGItf GrModule
  [ expNmFldMp: HsName2FldMp
    allImpNmL: {[HsName]}
    -- impNmL: {AssocL HsName Int}
  | |
  ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Module name map to field nr in node with imported modules
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(50 codegen grin)
ATTR GrAGItf GrModule AllBind AllGrExpr [ impNmFldMpMp: HsName2FldMpMp | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Constants
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
SEM GrExpr
  | FFI         lhs			.	constSt	    	=   @constSt3
%%]

%%[(8 codegen grin)
SEM GrBind
  | Bind        loc			.	entryNmConst	=	Just $ GB.StringConst $ show @nm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Debug info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
SEM GrExpr
  | FFI         loc         .   mbDebugStr      =   if ehcOptGenDebug @lhs.opts then Just (@impEntNm) else Nothing
  | Eval App    loc         .   mbDebugStr      =   if ehcOptGenDebug @lhs.opts then Just (show @nm) else Nothing
  | Call        loc         .   mbDebugStrNm    =   Just (if ehcOptGenDebug @lhs.opts then Just (show @nm) else Nothing, @nm)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% State
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

GBState threads commonly used admin, e.g. for labels. It is sideline
admin (not main admin like in attributes) to the codegeneration, only
occasionally used, but it is required inside utilitary functions (like
gvLd). Hence this type of info is put in a record, to be less obtrusive
when more of such similar admin is required.

%%[(8 codegen grin)
ATTR AllGrExpr AllBind [ | gbState: {GB.GBState} | ]

SEM GrModule
  | Mod         loc         .   gbState         =   GB.emptyGBState

SEM GrBind
  | Bind        expr        .   gbState         =   @lhs.gbState {GB.gbstMaxStkDepth = 0}

SEM GrExpr
  | Case        altL        .   gbState         =   @aftLblGBState
  | Seq         body        .   gbState         =   GB.gbstIncByStackState @aftLdGBState @seqStInc
  | FetchField FetchNode Throw UpdateUnit
                loc         .   aftLdGBState    =   @aftLblGBState
                lhs         .   gbState         =   @aftLdGBState
  | * - Catch Seq FetchField FetchNode Throw UpdateUnit
                lhs         .   gbState         =   GB.gbstIncByStackState @aftLdGBState @valStInc
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Labels
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
SEM GrAlt
  | Alt         (expr.gbState,loc.altLabel)     =   GB.newLabelId @lhs.gbState

SEM GrExpr
  | Case        (loc.aftLblGBState,loc.aftCaseLabel,loc.atNrAltsLabel,loc.at1stOffLabel)
                                                =   let (s1,l1) = GB.newLabelId @lhs.gbState
                                                        (s2,l2) = GB.newLabelId s1
                                                        (s3,l3) = GB.newLabelId s2
                                                    in  (s3,l1,l2,l3)
  | * - Case Catch Seq
                (loc.aftLblGBState,loc.retLocLabel)
                                                =   mkRetLabel @lhs.returnCtxt @lhs.gbState
%%]

%%[(8 codegen grin)
ATTR AllAlt [ | | altLocRefs USE {++} {[]}: {[GB.LocRef]} ]

SEM GrAlt
  | Alt         loc         .   altLocRef       =   if @lhs.nrOfAlts < 2 then GB.LocRef_Label @altLabel else GB.LocRef_CaseArm @altLabel @pat.tag
                loc         .   altLocRefs      =   [@altLocRef]

SEM GrExpr
  | Case        loc         .   aftCaseLocRef   =   GB.LocRef_EndSwitch @aftCaseLabel
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Stack state simulation: depth, GC permission, ...
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR AllGrExpr [ | stState: {GB.StackState} | ]

SEM GrBind
  | Bind        loc         .   stState         =   GB.emptyStackState

SEM GrExpr
  | Unit Store Call Eval App FFI FetchUpdate
                loc         .   valStState      =   @lhs.stState `GB.ststInc` @valStInc
  | FetchUpdate Case
                lhs         .   stState         =   @valStState
  | Unit Store Call Eval App FFI
                lhs         .   stState         =   @lhs.stState `GB.ststInc`@retStInc
  | Seq         loc         .   bodyStState     =   @expr.stState `GB.ststInc` @seqStInc
                body        .   stState         =   @bodyStState
  | Case        altL        .   stState         =   @lhs.stState `GB.ststInc` @scrutineeStInc
                loc         .   valStState      =   case @returnCtxt of
                                                      ReturnCtxt_CaseReturns _ st
                                                        -> st `GB.ststIncDep` GB.nrValWords
                                                      _ -> @altL.stState
%%]

%%[(8 codegen grin)
SEM GrAlt
  | Alt         loc         .   fetchStState    =   GB.ststFromDep @fetchDepth
                            .   exprStState     =   @lhs.stState `GB.ststInc` @fetchStState
                expr        .   stState         =   @exprStState
                loc         .   bodyStState     =   case @lhs.returnCtxt of
                                                      ReturnCtxt_CaseFallThrough
                                                        -> @expr.stState           -- scrutinee remains on stack
                                                      _ -> @lhs.stState            -- scrutinee is replaced with value of same size
                lhs         .   stState         =   @bodyStState
%%]

%%[(8 codegen grin)
SEM GrExpr
  | Unit Store Call FFI FetchUpdate Eval App Case
                loc         .   ldStState       =   @lhs.stState
  | Seq         loc         .   ldStState       =   @expr.stState
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Stack depth, derived from state
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
SEM GrExpr
  | Unit Store Call Eval App FFI FetchUpdate
                loc         .   valDepth        =   GB.ststDepth @valStState
  | Seq         loc         .   bodyStkDepth    =   GB.ststDepth @bodyStState
  | Case        loc         .   enumStkInc      =   if @altL.isAllEnum then - GB.nrValWords else 0
                            .   valDepth        =   GB.ststDepth @valStState
%%]

%%[(8 codegen grin)
SEM GrAlt
  | Alt         loc         .   fetchDepth      =   case @altFetch of
                                                      GB.AltFetch_Many ns   -> (length ns - 1) * GB.nrValWords
                                                      GB.AltFetch_One  _ _  -> GB.nrValWords
                                                      GB.AltFetch_Zero      -> 0
                            .   exprStkDepth    =   GB.ststDepth @exprStState
                loc         .   bodyStkDepth    =   GB.ststDepth @bodyStState
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Tail call info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
data ReturnCtxt
  = ReturnCtxt_Returns      Int                         -- return from function (nr of arguments)
  | ReturnCtxt_Continues                                -- don't return, leave result on stack
  | ReturnCtxt_CaseReturns  GB.LabelId GB.StackState    -- return from case alt (return destination, return stack depth)
  | ReturnCtxt_CaseFallThrough                          -- return from case with only 1 alt, so don't clean up stack
%%]

%%[(8 codegen grin)
ATTR AllGrExpr [ returnCtxt: ReturnCtxt | | ]

SEM GrBind
  | Bind        expr        .   returnCtxt      =   ReturnCtxt_Returns (length @argNmL)

SEM GrExpr
  | Seq         expr        .   returnCtxt      =   ReturnCtxt_Continues
  | Case        loc         .   returnCtxt      =   case @lhs.returnCtxt of
                                                      ReturnCtxt_Continues
                                                        | @nrOfAlts == 1 -> ReturnCtxt_CaseFallThrough
                                                        | otherwise      -> ReturnCtxt_CaseReturns @aftCaseLabel @lhs.stState
                                                      ReturnCtxt_CaseFallThrough
                                                        | @nrOfAlts == 1 -> @lhs.returnCtxt
                                                        | otherwise      -> ReturnCtxt_CaseReturns @aftCaseLabel @lhs.stState
                                                      _                  -> @lhs.returnCtxt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% BasicAnnot of following expr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR GrExpr [ patBasicAnnot: BasicAnnot | | ]

SEM GrExpr
  | Seq         expr        .   patBasicAnnot   =   nmIntroBasicAnnot @pat.nmIntro

SEM GrAlt
  | Alt         expr        .   patBasicAnnot   =   BasicAnnot_Dflt

SEM GrBind
  | Bind        expr        .   patBasicAnnot   =   BasicAnnot_Dflt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Named value access: see for hooks CommonValAccess
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
patNmL2VAGam' :: GB.StackDepth -> AssocL HsName Int -> ValAccessGamG
patNmL2VAGam' dep nmDepL = Map.fromList [ (n,Val_Local (dep+d) (GB.ValAccessAnnot_Annot basicAnnotWord)) | (n,d) <- nmDepL ]
%%]

%%[(8 codegen grin)
SEM GrBind
  | Bind        loc         .   newVaGam        =   Map.fromList [ (n,Val_Local (GB.ststDepth @stState - o) (GB.ValAccessAnnot_Annot basicAnnotWord)) | (n,o) <- zip @argNmL [GB.nrCallRetWords ..] ]

SEM GrAlt
  | Alt         loc			.   newVaGam        =   patNmL2VAGam' @exprStkDepth $ patNmL2DepL negate id @newAltNmL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% GrVal Value introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
SEM GrExpr
  | * - Unit Seq Store
  				lhs			.	grvalIntro      =   GrValIntro_None
%%]

%%[(8 codegen grin)
SEM GrVal
  | LitStr      lhs         .   grvalIntro      =   GrValIntro_Str   @str Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Delayed unit gval
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
data UnitIntro
  = UnitIntro   GrValIntro
%%]

%%[(8 codegen grin)
ATTR GrExpr [ isSeqArgCtxt: Bool | | ]

SEM GrBind
  | Bind        expr        .   isSeqArgCtxt    =   False

SEM GrAlt
  | Alt         expr        .   isSeqArgCtxt    =   False

SEM GrExpr
  | Seq         expr        .   isSeqArgCtxt    =   True
  | * - Seq     loc         .   isSeqArgCtxt    =   False
%%]

%%[(8 codegen grin)
ATTR GrExpr [ | | mbUnitIntro: {Maybe UnitIntro} ]

SEM GrExpr
  | * - Unit    lhs         .   mbUnitIntro     =   Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Expr Value introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin) hs
%%]
data EValIntro
  = EValIntro_TOS_One   { eviDepth :: GB.StackDepth }
  | EValIntro_TOS_Grp   { eviDepth :: GB.StackDepth, eviSize :: Int }
  | EValIntro_None


%%[(8 codegen grin)
%%]
ATTR GrExpr [ | | evalIntro: EValIntro ]

SEM GrExpr
  | Unit Store Call Eval App Case FFI
                lhs         .   evalIntro       =   EValIntro_TOS_One @valDepth
  | * - Unit Store Call Eval App Case Seq FFI
                lhs         .   evalIntro       =   EValIntro_None

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Expr Value codegen
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
SEM GrExpr
  | Unit        loc         .   (valIns,valStInc,retIsDone,mbUnitIntro,aftLdGBState)
                                                =   case GB.gviLd @lhs.opts (GB.defaultLoadCtxt {GB.lcxOmitTOSLd = True }) @nmEnv @ldStState @aftLblGBState @val.grvalIntro of
                                                      (GB.GrValIntroAlt_OnTOS ins inc _ _, gbState) | not @lhs.isSeqArgCtxt
                                                        -> (ins,inc,False,Nothing, gbState)
                                                      _ -> (Seq.empty,GB.ststFromDep 0,True,Just (UnitIntro @val.grvalIntro), @aftLblGBState)
  | Store       loc         .   (valIns,valStInc,retIsDone,aftLdGBState)
                                                =   case GB.gviLd @lhs.opts GB.defaultLoadCtxt @nmEnv @ldStState @aftLblGBState @val.grvalIntro of
                                                      (GB.GrValIntroAlt_OnTOS ins inc _ _, gbState)
                                                        -> (ins, inc, False, gbState)
  | Call        loc         .   (valIns,valStInc,retIsDone,aftLdGBState)
                                                =   case GB.gviLdFold @lhs.opts (GB.defaultLoadCtxt {GB.lcxDoLdTOS = True}) @nmEnv @ldStState @aftLblGBState @argL.grvalIntroL of
                                                      (GB.GrValIntroAlt_OnTOS ins inc _ _, gbState)
                                                        -> case @lhs.returnCtxt of
                                                             ReturnCtxt_Returns nrArgsOuter
                                                               -> ( ins Seq.:++: fins Seq.:++: Seq.fromList [GB.tailcall GB.InsOp_LocB_TOS nArgMine nrArgsOuter {- retOffSurr -}]
                                                                  , GB.ststFromDep 0, True, gbState2
                                                                  )
                                                               where (fins,fdep,gbState2) = GB.nmLd GB.defaultLoadCtxt @nmEnv (@ldStState `GB.ststInc` inc) gbState @nm
                                                                     nArgMine    = length @argL.grvalIntroL
                                                             _ -> (ins', inc', False, gbState2)
                                                               where (ins',inc',gbState2) = GB.gvCall @mbDebugStrNm @nmEnv ins inc @ldStState gbState @nm
  | FFI         loc         .   (valIns,valStInc,retIsDone,aftLdGBState,constSt3)
                                                =   if @optimForIntlPrim
                                                    then case gbprimMk (fromJust @mbGbPrim) @lhs.opts GB.defaultLoadCtxt @nmEnv @ldStState @aftLblGBState @argL.grvalIntroL of
                                                           (GB.GrValIntroAlt_OnTOS ins inc _ _, gbState)
                                                             -> (ins, inc, False, gbState, @constSt2)
                                                           _ -> panic ("ToGrinByteCode.mbGbPrim:" ++ show @impEntNm)
                                                    else case GB.gviLdFold @lhs.opts (GB.defaultLoadCtxt {GB.lcxDoLdTOS = True}) @nmEnv @ldStState @aftLblGBState @argL.grvalIntroL of
                                                           (GB.GrValIntroAlt_OnTOS ins inc _ basicsz, gbState)
                                                             -> ( ins Seq.:++: fins Seq.:++:
                                                                  Seq.fromList ([GB.meta' GB.AnnIdUse (@impEntNm >#< "szargs=" >|< GB.ststDepth inc >#< "basicsz=" >|< basicszStr)] ++ call)
                                                                , GB.ststFromDepPerm (basicSizeInWords patbasicsz) (grinBasicAnnotGCPermit @lhs.patBasicAnnot), False
                                                                , gbState3 `GB.gbstIncByStackState` callStState
                                                                , constSt3
                                                                )
                                                             where (gbState2,constLbl  ) = GB.newLabelId gbState
                                                                   (gbState3,callencLbl) = GB.newLabelId gbState2
                                                                   fins = Seq.fromList [GB.ldg GB.InsOp_LocB_TOS $ GB.linkChainConst constLbl $ refOfFld @constCFld]
                                                                   finc = GB.ststFromDepPerm 1 GCPermit_Not
                                                                   patbasicsz = grinBasicAnnotSize @lhs.patBasicAnnot
                                                                   basicszs = patbasicsz : basicsz
                                                                   (callencInx,constSt3) = Const.addFFICallEncWrapper basicszs @constSt2
                                                                   basicszStr = concatMap basicGrinSizeCharEncoding basicszs
                                                                   callStState = @ldStState `GB.ststInc` inc `GB.ststInc` finc
%%[[8
                                                                   call  = cl
%%][90
                                                                   call  = if forextractOptIsPtr @foreignEntInfo then [] else cl
%%]]
                                                                         where cl = [ GB.meta' GB.AnnStackDepth callStState
                                                                                    , GB.callc @mbDebugStr (callencLbl,refOfFld callencInx,basicszs) callStState (GB.ststDepth inc)
                                                                                    ]
  | FetchUpdate loc         .   (valIns,valStInc,retIsDone,aftLdGBState)
                                                =   case GB.gviLdFold @lhs.opts GB.defaultLoadCtxt @nmEnv @ldStState @aftLblGBState $ map GrValIntro_Nm $ [@src,@dst] of
                                                      (GB.GrValIntroAlt_OnTOS ins inc _ _, gbState)
                                                        -> (ins Seq.:++: Seq.fromList [GB.fetchupdate], GB.ststFromDep 0, False, gbState)
  | Eval        loc         .   (valIns,valStInc,retIsDone,aftLdGBState)
                                                =   let (ins,inc,gbState) = GB.nmLd (GB.defaultLoadCtxt {GB.lcxOmitTOSLd = True }) @nmEnv @ldStState @aftLblGBState @nm
                                                    in  case @lhs.returnCtxt of
                                                          ReturnCtxt_Returns nrArgsOuter
                                                            -> (ins Seq.:++: eins, GB.ststFromDep 0, True, gbState)
                                                            where eins       = Seq.fromList [GB.taileval @mbDebugStr GB.InsOp_LocB_TOS nrArgsOuter {- retOffSurr -}]
                                                          _ -> (ins Seq.:++: eins, inc, False, gbState)
                                                            where eins = Seq.fromList [GB.eval @mbDebugStr GB.InsOp_LocB_TOS]
  | App         loc         .   (valIns,valStInc,retIsDone,aftLdGBState)
                                                =   case GB.gviLdFold @lhs.opts GB.defaultLoadCtxt @nmEnv @ldStState @aftLblGBState @argL.grvalIntroL of
                                                      (GB.GrValIntroAlt_OnTOS ins inc _ _, gbState)
                                                        {-
                                                        -> ( ins Seq.:++: Seq.fromList [GB.ldc (length @argL.grvalIntroL)] Seq.:++: fins Seq.:++: Seq.fromList [GB.apply @mbDebugStr GB.InsOp_LocB_TOS]
                                                           , GB.ststFromDep GB.nrValWords, False, gbState2
                                                           )
                                                        -}
                                                        -> case @lhs.returnCtxt of
                                                             ReturnCtxt_Returns nrArgsOuter
                                                               -> ( ains1 Seq.:++: ains2, GB.ststFromDep 0, True, gbState2 )
                                                               where ains2 = Seq.fromList [GB.tailapply GB.InsOp_LocB_TOS nArgMine nrArgsOuter]
                                                                     nArgMine = nargs + 2 * GB.nrValWords
                                                             _ -> ( ains1 Seq.:++: ains2, GB.ststFromDep GB.nrValWords, False, gbState2 )
                                                               where ains2 = Seq.fromList [GB.apply @mbDebugStr GB.InsOp_LocB_TOS]
                                                        where (fins,_,gbState2) = GB.nmLd GB.defaultLoadCtxt @nmEnv (@ldStState `GB.ststInc` inc `GB.ststIncDep` GB.nrValWords) gbState @nm
                                                              ains1 = ins Seq.:++: Seq.fromList [GB.ldc nargs] Seq.:++: fins
                                                              nargs = length @argL.grvalIntroL
  | Case        loc         .   (valIns,valStInc,retIsDone,scrutineeStInc,aftLdGBState)
                                                =   case GB.gviLd @lhs.opts GB.defaultLoadCtxt @nmEnv @ldStState @altL.gbState @val.grvalIntro of
                                                      (GB.GrValIntroAlt_OnTOS ins inc _ _, gbState)
                                                        | @nrOfAlts == 1
                                                          -> ( ins Seq.:++: @altL.i, GB.ststFromDep GB.nrValWords, True, inc, gbState )
                                                        | otherwise
                                                          -> ( ins Seq.:++: insc Seq.:++: ins', GB.ststFromDep GB.nrValWords, True, inc `GB.ststIncDep` @enumStkInc, gbState2 )
                                                          where ins' = Seq.fromList [GB.casecall (GB.linkChainOffsets @atNrAltsLabel @nrOfAlts),GB.label (GB.LocRef_Label @at1stOffLabel)]
                                                                        Seq.:++: Seq.fromList {- inslblrefs -- -} [ GB.labelref l | l <- @altL.altLocRefs ]
                                                                        Seq.:++: @altL.i
                                                                        Seq.:++: Seq.fromList [GB.label @aftCaseLocRef]
                                                                insc = if @altL.isAllEnum then Seq.empty else Seq.fromList [GB.ldnt]
                                                                (inslblrefs,gbState2) = GB.labelref2 (map GB.lrefId @altL.altLocRefs) gbState
  | Seq         loc         .   (seqIns,seqStInc,newVaGam,aftLdGBState)
                                                =   let patupd (Just _) annot inc = GB.ststFromDepPerm (GB.ststDepth inc) (grinBasicAnnotGCPermit annot)
                                                        patupd _        _     inc = inc
                                                        nm ins incSt gbState nmIntro
                                                          = case nmIntro of
                                                              -- plain single name: put value on stack, introduce binding to it
                                                              (NmIntro_Single nm annot)
                                                                -> ( ins, incSt `GB.ststInc` GB.ststPatchDepPerm (grinBasicAnnotSizeInWords annot) (grinBasicAnnotGCPermit annot)
                                                                   , Map.fromList [(nm,Val_Local (GB.ststDepth @ldStState + inc) (GB.ValAccessAnnot_Annot annot))], gbState
                                                                   )
                                                              -- name of an enum: put on stack, possibly unpack further, introduce binding
                                                              (NmIntro_GrpTag nm)
                                                                -> (ins Seq.:++: patins,incSt `GB.ststInc` patinc,Map.fromList [(nm,Val_Local (GB.ststDepth @ldStState + inc) (GB.ValAccessAnnot_Annot BasicAnnot_Dflt))],gbState)
                                                                where (patins,patinc) = maybe (Seq.empty,GB.emptyStackState) (\(ins,_,inc) -> (ins,inc)) @pat.mbi
                                                              -- 
                                                              (NmIntro_GrpBasic nm annot)
                                                                -> (ins Seq.:++: patins,incSt {-  -}`GB.ststInc` patinc,Map.fromList [(nm,val)],gbState)
                                                                where (patins,val,patinc)
                                                                        = case (annot,@pat.mbi) of
                                                                            (BasicAnnot_Size _ _ BasicAnnotTagging_FromPtr _, Just (i,bSz,patinc))
                                                                              -> (i        ,Val_Local (GB.ststDepth @ldStState + inc)        (GB.ValAccessAnnot_Basic bSz    gcPermit), patinc              )
                                                                            (BasicAnnot_Size _ _ BasicAnnotTagging_FromPtr _, _                  )
                                                                              -> (Seq.empty,Val_Local (GB.ststDepth @ldStState + inc)        (GB.ValAccessAnnot_Annot BasicAnnot_Dflt), GB.emptyStackState  )
                                                                            (_                           , Just (i,bSz,patinc))
                                                                              -> (i        ,Val_NodeFldLocal (GB.ststDepth @ldStState + inc) (GB.ValAccessAnnot_Basic bSz    gcPermit), GB.emptyStackState  )   -- does this happen?
                                                                            (_                           , _                  )
                                                                              -> (Seq.empty,Val_NodeFldLocal (GB.ststDepth @ldStState + inc) (GB.ValAccessAnnot_Annot annot          ), GB.emptyStackState  )
                                                                        where gcPermit = grinBasicAnnotGCPermit annot
                                                              -- node fields: put node ptr on stack, then fetch fields
                                                              (NmIntro_Grp _ nmL) | not (null nmL)
                                                                -> (ins Seq.:++: fins, GB.ststFromDep (length nmL * GB.nrValWords),g,gbState)
                                                                where fins = Seq.fromList [GB.fetch GB.InsOp_LocB_TOS]
                                                                      g = patNmL2VAGam' (GB.ststDepth @ldStState + inc) $ patNmL2DepL id reverse nmL
                                                              _ -> (ins,incSt,Map.empty,gbState)
                                                          where inc = GB.ststDepth incSt 
                                                    in  case (@expr.mbUnitIntro,@pat.nmIntro) of
                                                          (Just (UnitIntro (GrValIntro_Int i)),NmIntro_Single nmp annot)
                                                            | bsz <= Cfg.sizeofGrWord
                                                              -> (Seq.empty,GB.ststFromDep 0,Map.singleton nmp (Val_Int i),@expr.gbState)
                                                              where bsz = grinBasicAnnotSizeInBytes annot
                                                          (Just (UnitIntro gvi),nmi)
                                                              -> nm ins inc gbState nmi
                                                              where (GB.GrValIntroAlt_OnTOS ins inc _ _, gbState)
                                                                      = GB.gviLd @lhs.opts GB.defaultLoadCtxt @nmEnv @ldStState @expr.gbState gvi
                                                          _   -> nm Seq.empty (GB.ststFromDep 0) @expr.gbState @pat.nmIntro
%%]

%%[(8 codegen grin) hs
mkRetLabel :: ReturnCtxt -> GB.GBState -> (GB.GBState,GB.LabelId)
mkRetLabel returnCtxt st
  = case returnCtxt of
      ReturnCtxt_CaseReturns _ _
        -> GB.newLabelId st
      _ -> (st,GB.gbstLbl st)

mkRet :: ReturnCtxt -> GB.LabelId -> GB.StackState -> GB.StackState -> (GB.InsSeq,GB.StackState)
mkRet returnCtxt retLocLbl stState incSt
  = case returnCtxt of
      ReturnCtxt_Returns nrArgsOuter
        -> (Seq.fromList [GB.retcall GB.nrValWords nrArgsOuter],dfltState)
      ReturnCtxt_CaseReturns labelId st
        -> ( Seq.fromList
               [ GB.meta' GB.AnnStackDepth stState
               , GB.retcase GB.nrValWords (stkDepth + inc - dep) (GB.linkChainOffset retLocLbl labelId)
               , GB.meta' GB.AnnStackDepth (dep + incret)
               ]
           , GB.ststFromDep incret
           )
        where incret = GB.nrValWords
              dep = GB.ststDepth st
      ReturnCtxt_CaseFallThrough
        -> (Seq.empty,dfltState)
      _ -> (Seq.empty,dfltState)
  where dfltState = GB.ststFromDep inc
        stkDepth  = GB.ststDepth stState
        inc       = GB.ststDepth incSt
%%]

%%[(8 codegen grin)
SEM GrExpr
  | Unit Store Call Eval App FFI
                (loc.retIns,loc.retStInc)       =   if @retIsDone
                                                    then (Seq.empty,@valStInc)
                                                    else mkRet @lhs.returnCtxt @retLocLabel @lhs.stState @valStInc
  | * - Unit Store Call Eval App FFI
                loc         .   retIns          =   Seq.empty
                            .   retFixOffs      =   Seq.empty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional C include files (we now assume C will be generated)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(90 codegen grin)
ATTR AllBind AllGrExpr [ | | includeS USE {`Set.union`} {Set.empty} : {Set.Set String} ]

SEM GrExpr
  | FFI         lhs         .   includeS        =   Set.fromList $ forextractIncludes @foreignEntInfo
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR GrAGItf GrModule [ | | gbMod: {GB.Module} ]

SEM GrModule
  | Mod         lhs         .   gbMod           =   GB.Module_Mod @moduleNmAlpha
%%[[50
                                                      [ (n,hsnShowAlphanumeric n) | n <- @lhs.allImpNmL ]
                                                      (offMpKeysSorted @lhs.impNmFldMpMp)
                                                      [ m | (n,_) <- sortOn snd $ Map.toList @lhs.expNmFldMp
                                                          , let m = panicJust ("ToGrinByteCode.GrModule.Mod: " ++ show n) (Map.lookup n @entryNmMp)
                                                      ]
%%]]
                                                      @entryL
                                                      (Seq.toList @i)
                                                      [ c | (c,_) <- sortOn (cfldGlobInx . snd) $ Map.toList $ conststMp @bindL.constSt ]
                                                      [ i | (i,True) <- zip [0..] @isCafL ]
                                                      (fldInx @mainEntryFld)
%%[[90
                                                      (Set.toList @bindL.includeS)
%%]]
%%]

%%[(8 codegen grin)
ATTR AllBind AllGrExpr GrPatLam [ | | i USE {Seq.:++:} {Seq.empty}: {GB.InsSeq} ]

SEM GrModule
  | Mod         loc         .   i               =   Seq.fromList
                                                       [ GB.halt	-- dummy, so linkChain won't start at 0, which is used to indicate a linkChain Nil.
                                                       ]
                                                    Seq.:++: @bindL.i


SEM GrBind
  | Bind        lhs         .   i               =   Seq.fromList
                                                       [ GB.funstart (GB.FunctionInfo (show @nm) @nm (GB.gbstMaxStkDepth @expr.gbState)
%%[[8
                                                                                      []
%%][50
                                                                                      (maybe [] (\i -> if laminfo1stArgIsStackTrace i then [GB.FunctionInfoFlag_1stArgIsStackTrace] else [])
                                                                                       $ Map.lookup @nm @lhs.lamMp)
%%]]
                                                                                      )
                                                       , GB.label (GB.LocRef_CodeEntry $ fldInx @entryFld)
                                                       , GB.meta' GB.AnnFunStart @nm
                                                       ]
                                                    Seq.:++: @expr.i

SEM GrExpr
  | Unit Store Call Eval App Case FFI FetchUpdate
                lhs         .   i               =   @valIns Seq.:++: @retIns
  | Seq         lhs         .   i               =   @expr.i Seq.:++: Seq.fromList [GB.meta' GB.AnnStackDepth @ldStState]
                                                            Seq.:++: @seqIns Seq.:++: @body.i
                                                            Seq.:++: Seq.fromList [GB.meta' GB.AnnStackDepth @bodyStState]
                                                            Seq.:++: @retIns

SEM GrAlt
  | Alt         lhs         .   i               =   let fetch = case @altFetch of
                                                                  GB.AltFetch_Many _  -> Seq.fromList [GB.fetch GB.InsOp_LocB_TOS]
                                                                  GB.AltFetch_One _ o -> Seq.fromList [GB.l2ts (o + GB.nrNodeHdrWords)]
                                                                  GB.AltFetch_Zero    -> Seq.empty
                                                    in  Seq.fromList [GB.meta' GB.AnnStackDepth @lhs.stState,GB.label @altLocRef]
                                                        Seq.:++: fetch
                                                        Seq.:++: Seq.fromList [GB.meta' GB.AnnStackDepth @exprStState]
                                                        Seq.:++: @expr.i
                                                        Seq.:++: Seq.fromList [GB.meta' GB.AnnStackDepth @bodyStState]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code generation, additional for a variable intro for a FFI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen grin)
ATTR GrPatLam [ | | mbi: {Maybe (GB.InsSeq,BasicSize,GB.StackState)} ]

SEM GrPatLam
  | BasicNode   lhs         .   mbi             =   let basicSize = grinBasicAnnotSize @annot
                                                    in  case @annot of
                                                          BasicAnnot_Size bsz _ BasicAnnotTagging_FromPtr sgn
                                                            | not @lhs.primArgForIntl
                                                              -> Just (Seq.fromList [GB.untag2 sgn {-(basicSizeIsSigned bsz)-}],basicSize,GB.ststPatchTOSGCNot)
                                                          _   -> Nothing
  | EnumNode    lhs         .   mbi             =   if @lhs.primArgForIntl
                                                    then Nothing
                                                    else Just ( Seq.fromList [GB.untag2 False]
                                                              , grinBasicAnnotSize BasicAnnot_Dflt
                                                              , GB.ststPatchTOSGCNot
                                                              )
  | * - BasicNode EnumNode
                lhs         .   mbi             =   Nothing
%%]


