%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to Code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}Core} import({%{EH}Base.Builtin},{%{EH}Base.Common},{%{EH}Base.Opts})
%%]

%%[(8 codegen) hs import ({%{EH}Base.Target}(FFIWay(..))) export(module {%{EH}Base.Target})
%%]

%%[(8 codegen) hs import(Data.Maybe,Data.Char,Data.List,EH.Util.Pretty)
%%]

%%[(8 codegen) hs export(CodeAGItf(..), CModule(..), CExpr(..), CBind(..), CMetaVal(..), CExprAnn(..), CMetaBind(..), CMetas, CBindL, CPatRest(..), CAlt(..), CAltL, CPat(..), CPatL, CPatBind(..), CPatBindL) 
%%]

%%[(8 codegen) hs import(qualified Data.Map as Map,qualified Data.Set as Set,{%{EH}Ty})
%%]

%%[(8 codegen) hs export(mkCMod)
%%]

%%[(8 codegen) hs export(CaseFailSubst)
%%]

%%[(9 codegen) hs export(cbindLNub)
%%]

%%[(20 codegen) hs export(cModMerge)
%%]

%%[(94 codegen) hs import({%{EH}Foreign}) export(module {%{EH}Foreign})
%%]

%%[(8 codegen) ag import({Core/AbsSyn})
DERIVING *     : Show, Eq
%%]

-- for debug only
%%[(8 codegen) hs import({%{EH}Base.Debug})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Abstract syntax for encoding case+pattern rewrite info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(RAlt(..),RPat(..),RPatConBind(..),RPatBind(..))
data RAlt
  = RAlt_Alt			{ rcaPats :: ![RPat], raaExpr :: !CExpr, raaFailS :: UIDS }

data RPat
  = RPat_Var			{ rcpPNm :: !RPatNm }
  | RPat_Con			{ rcpPNm :: !RPatNm, rcpTag :: !CTag, rcpBinds :: !RPatConBind }
  | RPat_Int			{ rcpPNm :: !RPatNm, rcpInt :: !Int }
  | RPat_Char			{ rcpPNm :: !RPatNm, rcpChar :: !Char }
  | RPat_Irrefutable	{ rcpPNm :: !RPatNm, rcpCBindL :: ![CBind] }
%%[[97
  | RPat_BoolExpr		{ rcpPNm :: !RPatNm, rcpExpr :: !CExpr }
%%]]

data RPatConBind
  = RPatConBind_One		{ rpcbRest :: !CPatRest, rpcbBinds :: ![RPatBind] }
  | RPatConBind_Many	{ rpcbConBinds :: ![RPatConBind] }

data RPatBind
  = RPatBind_Bind		{ rpbLbl :: !HsName, rpbOffset :: !CExpr, rpbNm :: !HsName, rpbPat :: !RPat }
%%]

%%[(8 codegen) hs export(rcaPat,raltLPatNms)
rcaPat :: RAlt -> RPat
rcaPat = head . rcaPats

raltLPatNms :: [RAlt] -> [RPatNm]
raltLPatNms = nub . sort . map (rcpPNm . rcaPat)
%%]

%%[(8 codegen) hs export(rcaTag)
rpatConTag :: RPat -> CTag
rpatConTag (RPat_Int  _ _   )  = ctagInt
rpatConTag (RPat_Char _ _   )  = ctagChar
rpatConTag p                   = rcpTag p

rcaTag :: RAlt -> CTag
rcaTag = rpatConTag . head . rcaPats
%%]

%%[(8 codegen) hs export(raltIsVar,raltIsConst)
raltIsVar :: RAlt -> Bool
raltIsVar (RAlt_Alt (RPat_Var _ : _) _ _)  = True
raltIsVar _                                = False

raltIsConst :: RAlt -> Bool
raltIsConst (RAlt_Alt (p : _) _ _)
  = c p
  where c (RPat_Int   _ _) = True
        c (RPat_Char  _ _) = True
        c _                = False
%%]

%%[(8 codegen) hs export(raltIsConMany)
raltIsConMany :: RAlt -> Bool
raltIsConMany (RAlt_Alt (RPat_Con _ _ (RPatConBind_Many _) : _) _ _) = True
raltIsConMany _                                                      = False
%%]

%%[(8 codegen) hs export(raltIsIrrefutable)
raltIsIrrefutable :: RAlt -> Bool
raltIsIrrefutable (RAlt_Alt (RPat_Irrefutable _ _ : _) _ _) = True
raltIsIrrefutable _                                         = False
%%]

%%[(97 codegen) hs export(raltIsBoolExpr)
raltIsBoolExpr :: RAlt -> Bool
raltIsBoolExpr (RAlt_Alt (RPat_BoolExpr _ _ : _) _ _)  = True
raltIsBoolExpr _                                       = False
%%]

Flatten bindings, delaying the handling of many bindings to the rewriting of case patterns.

%%[(8 codegen) hs export(rpatConBindUnFlatten)
rpatConBindUnFlatten :: RPatConBind -> [RPatConBind] -> RPatConBind
rpatConBindUnFlatten z []  = z
rpatConBindUnFlatten _ [b] = b
rpatConBindUnFlatten _ bs  = RPatConBind_Many bs
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Conversion from Rxxx -> Cxxx
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(rpat2CPat)
rpat2CPat :: RPat -> CPat
rpat2CPat p
  = case p of
      RPat_Var      n       -> CPat_Var (rpatNmNm n)
      RPat_Con      n t b   -> CPat_Con (rpatNmNm n) t r bs
                            where (r,bs) = rpatConBind2CPatConBind b
      RPat_Int      n v     -> CPat_Int (rpatNmNm n) v
      RPat_Char     n v     -> CPat_Char (rpatNmNm n) v
%%[[97
      RPat_BoolExpr n v     -> CPat_BoolExpr (rpatNmNm n) v
%%]]
%%]

%%[(8 codegen) hs export(rpatConBind2CPatConBind,rpatBind2CPatBind)
rpatConBind2CPatConBind :: RPatConBind -> (CPatRest,[CPatBind])
rpatConBind2CPatConBind b
  = case b of
  	  RPatConBind_One 	r bs 	-> (r,map rpatBind2CPatBind bs)
  	  RPatConBind_Many 	bs 		-> head (map rpatConBind2CPatConBind bs)

rpatBind2CPatBind :: RPatBind -> CPatBind
rpatBind2CPatBind (RPatBind_Bind l o n p) = CPatBind_Bind l o n (rpat2CPat p)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Tuple operator info
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(10 codegen) hs export(cTupLbl)
cTupLbl :: CExpr -> HsName
cTupLbl e
  =  case e of
         CExpr_TupIns _ _ l _ _ -> l
         CExpr_TupUpd _ _ l _ _ -> l
         CExpr_TupDel _ _ l _   -> l
%%]

%%[(10 codegen) hs export(cTupTag)
cTupTag :: CExpr -> CTag
cTupTag e
  =  case e of
         CExpr_TupIns _ t _ _ _ -> t
         CExpr_TupUpd _ t _ _ _ -> t
         CExpr_TupDel _ t _ _   -> t
%%]

%%[(10 codegen) hs export(cTupOff)
cTupOff :: CExpr -> CExpr
cTupOff e
  =  case e of
         CExpr_TupIns _ _ _ o _ -> o
         CExpr_TupUpd _ _ _ o _ -> o
         CExpr_TupDel _ _ _ o   -> o
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Utility functions for CMeta
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(cmetasDefault)
cmetasDefault :: CMetas
cmetasDefault = (CMetaBind_Plain,CMetaVal_Val)
%%]

%%[(8 codegen) hs export(cmetasVal)
cmetasVal :: CMetas -> CMetaVal
cmetasVal (_,v) = v
%%]

%%[(8 codegen) hs export(cmetasMapVal)
cmetasMapVal :: (CMetaVal -> CMetaVal) -> CMetas -> CMetas
cmetasMapVal f (b,v) = (b,f v)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Binding category, per group of bindings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(CBindingsCateg(..))
data CBindingsCateg
  = CBindings_Rec				-- mutually recursive
  | CBindings_Strict			-- strictly evaluated
  | CBindings_Plain				-- plain
  | CBindings_FFI				-- imported function
%%[[94
  | CBindings_FFE				-- exported function (not implemented yet)
%%]]
  deriving (Show,Eq)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Context: what is above/below
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(WhatExpr(..))
data WhatExpr
  = ExprIsLam | ExprIsApp | ExprIsVar HsName | ExprIsInt Int | ExprIsOther
  deriving Eq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Context: strictness as required by context
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(EvalCtx(..),isStrict)
data EvalCtx
  = EvalCtx_None         -- nothing known, no strictness required
  | EvalCtx_Eval         -- strictness (thus eval) required
  | EvalCtx_EvalUnbox    -- strictness (thus eval) + unboxing required
  deriving Eq

isStrict :: EvalCtx -> Bool
isStrict EvalCtx_Eval        = True
isStrict EvalCtx_EvalUnbox   = True
isStrict _                   = False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Properties
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(cexprIsLam)
cexprIsLam :: CExpr -> Bool
cexprIsLam (CExpr_Lam _ _ _) = True
cexprIsLam _                 = False
%%]

%%[(8 codegen) hs export(cbindNm)
cbindNm :: CBind -> HsName
cbindNm (CBind_Bind      n _ _) = n
cbindNm (CBind_FFI _ _ _ n _  ) = n
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Remove duplicate bindings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen) hs
cbindLNub :: CBindL -> CBindL
cbindLNub = nubBy (\b1 b2 -> cbindNm b1 == cbindNm b2)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Name of a pattern var/con
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(RPatNm(..))
data RPatNm
  = RPatNmOrig {rpatNmNm :: !HsName}
  | RPatNmUniq {rpatNmNm :: !HsName}
  deriving Eq

instance Ord RPatNm where
  x `compare` y = rpatNmNm x `cmpHsNameOnNm` rpatNmNm y  

instance Show RPatNm where
  show pnm = show (rpatNmNm pnm)

instance PP RPatNm where
  pp (RPatNmOrig n) = n >|< "(O)"
  pp (RPatNmUniq n) = n >|< "(U)"
%%]

%%[(8 codegen) hs export(rpatNmIsOrig)
rpatNmIsOrig :: RPatNm -> Bool
rpatNmIsOrig (RPatNmOrig _) = True
rpatNmIsOrig _              = False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Lifting to CMetaVal tupled
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(cmetaLift)
cmetaLift' :: Functor f => CMetaVal -> f x -> f (x,CMetaVal)
cmetaLift' m = fmap (\x -> (x,m))

cmetaLift :: Functor f => f x -> f (x,CMetaVal)
cmetaLift = cmetaLift' CMetaVal_Val
%%]

%%[(9 codegen) hs export(cmetaLiftDict)
cmetaLiftDict :: Functor f => f x -> f (x,CMetaVal)
cmetaLiftDict = cmetaLift' (CMetaVal_Dict Nothing)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Construction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(mkCExprAppMeta,mkCExprApp1Meta)
mkCExprApp1Meta :: CExpr -> CExpr -> CMetaVal -> CExpr
mkCExprApp1Meta f a m = CExpr_App f a m

mkCExprAppMeta :: CExpr -> [(CExpr,CMetaVal)] -> CExpr
mkCExprAppMeta f as = foldl (\f (a,m) -> mkCExprApp1Meta f a m) f as
%%]

%%[(8 codegen) hs export(mkCExprApp,mkCExprApp1)
mkCExprApp1 :: CExpr -> CExpr -> CExpr
mkCExprApp1 f a = mkCExprApp1Meta f a CMetaVal_Val

mkCExprApp :: CExpr -> [CExpr] -> CExpr
mkCExprApp f as = mkCExprAppMeta f (cmetaLift as)
%%]

%%[(8 codegen) hs export(mkCExprLamMeta,mkCExprLam1Meta)
mkCExprLam1Meta :: HsName -> CMetaVal -> CExpr -> CExpr
mkCExprLam1Meta a m e = CExpr_Lam a m e

mkCExprLamMeta :: [(HsName,CMetaVal)] -> CExpr -> CExpr
mkCExprLamMeta as e = foldr (\(n,m) e -> mkCExprLam1Meta n m e) e as
%%]

%%[(8 codegen) hs export(mkCExprLam,mkCExprLam1)
mkCExprLam1 :: HsName -> CExpr -> CExpr
mkCExprLam1 a e = mkCExprLam1Meta a CMetaVal_Val e

mkCExprLam :: [HsName] -> CExpr -> CExpr
mkCExprLam as e = mkCExprLamMeta (cmetaLift as) e
%%]

%%[(8 codegen) hs export(mkCBind1Metas)
mkCBind1Metas :: HsName -> CMetas -> CExpr -> CBind
mkCBind1Metas n m e = CBind_Bind n m e
%%]

%%[(8 codegen) hs export(mkCBind1Meta)
mkCBind1Meta :: HsName -> CMetaVal -> CExpr -> CBind
mkCBind1Meta n m e = mkCBind1Metas n (CMetaBind_Plain,m) e
%%]

%%[(8 codegen) hs export(mkCBind1)
mkCBind1 :: HsName -> CExpr -> CBind
mkCBind1 n e = mkCBind1Meta n CMetaVal_Val e
%%]

%%[(8 codegen) hs export(mkCExprTuple,mkCExprTuple')
mkCExprTuple' :: CTag -> [CExpr] -> CExpr
mkCExprTuple' t = mkCExprApp (CExpr_Tup t)

mkCExprTuple :: [CExpr] -> CExpr
mkCExprTuple = mkCExprTuple' CTagRec
%%]

%%[(8 codegen) hs export(mkCExprStrictInMeta)
mkCExprStrictInMeta :: HsName -> CMetaVal -> CExpr -> (CExpr -> CExpr) -> CExpr
mkCExprStrictInMeta nm m e mkC = CExpr_Let CBindings_Strict [mkCBind1Meta nm m e] (mkC (CExpr_Var nm))
%%]

%%[(8 codegen) hs export(mkCExprLet,mkCExprLet',mkCExprLetRec,mkCExprLetPlain,mkCExprStrictIn,mkCExprMbStrictIn)
mkCExprLet' :: Bool -> CBindingsCateg -> CBindL -> CExpr -> CExpr
mkCExprLet' merge c bs e
  = if null bs
    then e
    else case e of
           CExpr_Let c' bs' e' | merge && c' == c
             -> mk c (bs++bs') e'
           _ -> mk c bs e
  where mk CBindings_Rec bs e = CExpr_Let CBindings_Rec bs e
        mk c             bs e = foldr (\b e -> CExpr_Let c [b] e) e bs

mkCExprLet :: CBindingsCateg -> CBindL -> CExpr -> CExpr
mkCExprLet c bs e = mkCExprLet' False c bs e

mkCExprLetRec :: CBindL -> CExpr -> CExpr
mkCExprLetRec = mkCExprLet CBindings_Rec

mkCExprLetPlain ::  HsName -> CExpr -> CExpr -> CExpr
mkCExprLetPlain nm e = mkCExprLet CBindings_Plain [mkCBind1 nm e]

mkCExprStrictIn :: HsName -> CExpr -> (CExpr -> CExpr) -> CExpr
mkCExprStrictIn nm e mkC = mkCExprStrictInMeta nm CMetaVal_Val e mkC

mkCExprMbStrictIn :: Maybe HsName -> CExpr -> (CExpr -> CExpr) -> CExpr
mkCExprMbStrictIn (Just nm) e mkC = CExpr_Let CBindings_Strict [mkCBind1 nm e] (mkC (CExpr_Var nm))
mkCExprMbStrictIn _         e mkC =                                        mkC e
%%]

%%[(8 codegen) hs
mkCMod :: CExpr -> CModule
mkCMod e = CModule_Mod (hsnFromString "") e []
%%]

%%[(95 codegen) hs export(mkCIf)
mkCIf :: EHCOpts -> Maybe HsName -> CExpr -> CExpr -> CExpr -> CExpr
mkCIf opts cn c t f
  = mkCExprMbStrictIn cn c
    $ (\c -> CExpr_Case c
               [ CAlt_Alt (CPat_Con hsnUnknown (ctagFalse opts) CPatRest_Empty []) f
               , CAlt_Alt (CPat_Con hsnUnknown (ctagTrue  opts) CPatRest_Empty []) t
               ]
               (cundefined opts)
      )
%%]

%%[(99 codegen) hs export(mkCMatchChar)
mkCMatchChar :: EHCOpts -> Maybe HsName -> Char -> CExpr -> CExpr -> CExpr -> CExpr
mkCMatchChar opts cn cchar cexpr t f
  = mkCIf opts cn (ceqchar opts cchar cexpr) t f
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Inspection/deconstruction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(cexprMbVar,cexprVar)
cexprMbVar :: CExpr -> Maybe HsName
cexprMbVar (CExpr_Var n) = Just n
cexprMbVar _             = Nothing

cexprVar :: CExpr -> HsName
cexprVar = maybe hsnUnknown id . cexprMbVar
%%]

%%[(8 codegen) hs export(cexprTupFld)
cexprTupFld :: CExpr -> CExpr
cexprTupFld (CExpr_TupIns _ _ _ _ e) = e
cexprTupFld _                        = CExpr_Var hsnUnknown
%%]

%%[(8 codegen) hs export(cexprIsEvaluated)
cexprIsEvaluated :: CExpr -> Bool
cexprIsEvaluated (CExpr_Int  _) = True
cexprIsEvaluated (CExpr_Char _) = True
cexprIsEvaluated _              = False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Operator construction, expressed in terms of primitives
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(cbuiltinApp)
cbuiltinApp :: EHCOpts -> (EHBuiltinNames -> HsName) -> [CExpr] -> CExpr
cbuiltinApp opts bnmOf args = CExpr_Var (bnmOf $ ehcOptBuiltinNames opts) `mkCExprApp` args
%%]

%%[(8 codegen) hs export(caddint)
caddint :: EHCOpts -> CExpr -> Int -> CExpr
caddint opts e i
  = if i == 0
    then e
    else case e of
           CExpr_Int i' -> CExpr_Int $ i+i'
           _            -> cbuiltinApp opts ehbnPrimAddInt [e,CExpr_Int i]
%%]

%%[(8 codegen) hs export(cgtint)
cgtint :: EHCOpts -> CExpr -> Int -> CExpr
cgtint opts e i = cbuiltinApp opts ehbnPrimGtInt [e,CExpr_Int i]
%%]

%%[(99 codegen) hs
ceqchar :: EHCOpts -> Char -> CExpr -> CExpr
ceqchar opts c e = cbuiltinApp opts ehbnPrimEqChar [e,CExpr_Char c]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% String construction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(cstring)
cstring :: EHCOpts -> String -> CExpr
cstring opts m = cbuiltinApp opts ehbnPackedStringToString [CExpr_String m]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Integer construction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(97 codegen) hs export(cinteger)
cinteger :: EHCOpts -> Integer -> CExpr
cinteger opts i = cbuiltinApp opts ehbnPackedStringToInteger [CExpr_String $ show $ i]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Error
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(cerror,cundefined)
cerror :: EHCOpts -> String -> CExpr
cerror opts m = cbuiltinApp opts ehbnError [cstring opts m]

cundefined :: EHCOpts -> CExpr
cundefined opts = cbuiltinApp opts ehbnUndefined []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Tags, in general
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(caltConTag,caltIntTag) 
cpatConTag :: CPat -> CTag
cpatConTag (CPat_Con  _ t _ _)  = t
cpatConTag (CPat_Int  _ _    )  = ctagInt
cpatConTag (CPat_Char _ _    )  = ctagChar

cpatIntTag :: CPat -> Int
cpatIntTag (CPat_Con  _ t _ _)  = ctagTag t
cpatIntTag (CPat_Int  _ i    )  = i
cpatIntTag (CPat_Char _ c    )  = ord c

caltConTag :: CAlt -> CTag
caltConTag (CAlt_Alt p _) = cpatConTag p

caltIntTag :: CAlt -> Int
caltIntTag (CAlt_Alt p _) = cpatIntTag p
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Bool
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In the following, note the hardcodedness!!!!!

%%[(95 codegen) hs export(ctagTrue, ctagFalse)
ctagTrue, ctagFalse :: EHCOpts -> CTag
ctagTrue  opts = CTag (ehbnDataBool $ ehcOptBuiltinNames opts) (ehbnBoolTrue  $ ehcOptBuiltinNames opts) 1 0 0		-- this makes it hardcoded, ideally dependent on datatype def itself !!
ctagFalse opts = CTag (ehbnDataBool $ ehcOptBuiltinNames opts) (ehbnBoolFalse $ ehcOptBuiltinNames opts) 0 0 0		-- this makes it hardcoded, ideally dependent on datatype def itself !!
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% List
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In the following, note the hardcodedness!!!!!

%%[(97 codegen) hs export(ctagCons,ctagNil)
ctagCons, ctagNil :: EHCOpts -> CTag
ctagCons opts = CTag (ehbnDataList $ ehcOptBuiltinNames opts) (ehbnDataListAltCons $ ehcOptBuiltinNames opts) 0 2 2		-- this makes it hardcoded, ideally dependent on datatype def itself !!
ctagNil  opts = CTag (ehbnDataList $ ehcOptBuiltinNames opts) (ehbnDataListAltNil  $ ehcOptBuiltinNames opts) 1 0 2		-- this makes it hardcoded, ideally dependent on datatype def itself !!
%%]

%%[(99 codegen) hs export(mkCListSingleton)
mkCListSingleton :: EHCOpts -> CExpr -> CExpr
mkCListSingleton opts e
  = mkCExprApp (CExpr_Tup $ ctagCons opts) [e,CExpr_Tup $ ctagNil opts]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Var introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(CVarIntro(..),emptyCVarIntro)
data CVarIntro
  = CVarIntro
      { cviLev		:: Int		-- lexical level
      , cviMeta		:: CMetaVal	-- meta info
      }

emptyCVarIntro :: CVarIntro
emptyCVarIntro
  = CVarIntro cLevExtern CMetaVal_Val
%%]

%%[(8 codegen) hs export(CVarIntroMp,CVarIntroL,cviLookup)
type CVarIntroMp = Map.Map HsName CVarIntro
type CVarIntroL  = AssocL  HsName CVarIntro

cviLookup :: HsName -> CVarIntroMp -> CVarIntro
cviLookup n m = Map.findWithDefault emptyCVarIntro n m
%%]

%%[(8 codegen) hs export(cLevModule,cLevExtern)
cLevModule, cLevExtern :: Int
cLevModule = 0
cLevExtern = 0
%%]

%%[(20 codegen) hs export(cLevIntern)
cLevIntern :: Int
cLevIntern = 1
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replacement in general
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(CVarRepl(..))
data CVarRepl r
  = CVarRepl
      { cvrRepl		:: r		-- replacement
      , cvrMeta		:: CMetaVal	-- meta info
      }
%%]

%%[(8 codegen) hs export(CVarReplMp)
type CVarReplMp  r = Map.Map HsName (CVarRepl r)
type CVarReplAsc r = AssocL  HsName (CVarRepl r)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Replacement with HsName
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(CVarReplNm,emptyCVarReplNm)
type CVarReplNm = CVarRepl HsName

emptyCVarReplNm :: CVarReplNm
emptyCVarReplNm = CVarRepl hsnUnknown CMetaVal_Val
%%]

%%[(8 codegen) hs export(CVarReplNmMp,CVarReplNmL)
type CVarReplNmMp = CVarReplMp  HsName
type CVarReplNmL  = CVarReplAsc HsName
%%]

%%[(8 codegen) hs export(cvrFromCvi)
cvrFromCvi :: CVarIntro -> CVarReplNm
cvrFromCvi i
  = emptyCVarReplNm
      { cvrMeta 	= cviMeta i
      }
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Support for transformations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(fvLev,fvsLev)
fvLev :: HsName -> CVarIntroMp -> Int
fvLev n m = cviLev $ cviLookup n m

fvsLev :: CVarIntroMp -> Int -> FvS -> Int
fvsLev lm lDflt fvs = foldr (\n l -> fvLev n lm `max` l) lDflt $ Set.toList $ fvs
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Known function arity
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(CArityMp)
type CArityMp = Map.Map HsName Int
%%]

%%[(8 codegen) hs export(arityMpLookupLam,arityMpLookupCaf)
arityMpLookupLam :: HsName -> CArityMp -> Maybe Int
arityMpLookupLam n m
  = case Map.lookup n m of
      j@(Just a) | a > 0 -> j
      _                  -> Nothing

arityMpLookupCaf :: HsName -> CArityMp -> Maybe Int
arityMpLookupCaf n m
  = case Map.lookup n m of
      j@(Just a) | a == 0 -> j
      _                   -> Nothing
%%]

%%[(8 codegen) hs export(arityMpFilterLam,arityMpFilterCaf)
arityMpFilterLam :: CArityMp -> CArityMp
arityMpFilterLam = Map.filter (>0)

arityMpFilterCaf :: CArityMp -> CArityMp
arityMpFilterCaf = Map.filter (==0)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Name to offset (in a record)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(20 codegen) hs export(HsName2OffsetMp,HsName2OffsetMpMp)
type HsNameOffset      = Int
type HsName2OffsetMp   = Map.Map HsName HsNameOffset
type HsName2OffsetMpMp = Map.Map HsName (Int,HsName2OffsetMp)
%%]

%%[(20 codegen) hs export(offMpMpKeysSet)
offMpMpKeysSet :: HsName2OffsetMpMp -> Set.Set HsName
offMpMpKeysSet m = Set.unions [ Map.keysSet m' | (_,m') <- Map.elems m ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Hole construction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen) hs export(mkCExprPrHole,mkCExprHole,mkCExprLetHole)
mkCExprHole :: EHCOpts -> UID -> CExpr
mkCExprHole opts = CExpr_Var . mkHNm

mkCExprPrHole :: EHCOpts -> PredOccId -> CExpr
mkCExprPrHole opts = mkCExprHole opts . poiId

mkCExprLetHole :: UID -> CExpr -> CExpr
mkCExprLetHole i b = i `CExpr_HoleLet` b
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Module merge
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(20 codegen) hs
cModMerge :: [CModule] -> CModule
cModMerge mL
  = foldr1 cmb mL
  where get (CExpr_Let c b e) = CExpr_Let c b . get e
        get  _                = id
        cmb (CModule_Mod m1 e1 t1) (CModule_Mod m2 e2 t2)
          = CModule_Mod m2 (get e1 e2) (t1++t2)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Subst to replace CaseAltFail
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs
type CaseFailSubst = Map.Map UID CExpr
%%]



