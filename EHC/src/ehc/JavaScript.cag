%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell importable interface to JavaScript/AbsSyn
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 javascript) hs module {%{EH}JavaScript} import({%{EH}Base.Common})
%%]

%%[(8 javascript) hs export(JavaScriptModule(..), Stat(..), StatL, NmExpr, NmExprL, Expr(..), ExprL, MbExpr, AGItf(..)) 
%%]

%%[(8 javascript) hs import({%{EH}Gam.DataGam})
%%]

%%[(8 javascript) hs import({%{EH}CodeGen.CVar})
%%]

%%[(8 javascript) hs import({%{EH}CodeGen.GenJavaLike})
%%]

%%[(8 javascript) hs export(Alt(..), AltL) 
%%]

%%[(8 javascript) ag import({JavaScript/AbsSyn})
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Instances
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 javascript) hs
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Names
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 javascript) hs
nmFunN   n  = mkHNm ("_F" {- ++ nmFunSuff n -} ++ "_")
nmAppN   n  = "_A" {- ++ nmFunSuff n -} ++ "_"
nmFunSuff :: Int -> String
nmFunSuff n | n >  5    = "N"
            | n >= 0    = show n
            | otherwise = ""
nmApplyN n  = "_a" ++ nmFunSuff n ++ "_"
nmApply     = nmApplyN (-1)
nmEvalN  n  = "_e" ++ nmFunSuff n ++ "_"
nmEval      = nmEvalN (-1)
nmFunEvNFld = mkHNm "__evN__"
%%]

%%[(8 javascript) hs export(nmTag)
nmTag       = mkHNm "_tag_"
%%]

%%[(8 javascript) hs export(hsnJavaScriptVar)
-- hsnJavaScriptVar :: Bool -> HsName -> HsName -> HsName -> HsName
hsnJavaScriptVar :: CVarNmModuleCfg -> Bool -> HsName -> HsName
%%[[8
hsnJavaScriptVar = hsnJavaLikeVar (\_ -> id, id, id)
%%][50
hsnJavaScriptVar = hsnJavaLikeVar (\isglob -> if isglob then id else hsnQualified, hsnPrefix "$", ('$':))
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Variable bindings for other than global
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 javascript) hs export(CVarInfo, CVarMp)
type CVarInfo = CVarInfo' () HsName Int
type CVarMp   = CVarMp'   () HsName Int
%%]

%%[(8 javascript) hs export(tyDefault)
tyDefault = ()
%%]

%%[(8 javascript) hs export(ref)
ref :: CVarMp -> CVarInfo -> Expr
ref
  = cvarToRef
      ( \_       -> Expr_This
      , \_ o     -> var o
      , \_ _ f   -> var f
      , \_ e _ f -> Expr_ObjFld e (mkHNm f)
      , \  e o   -> Expr_ArrInx e o
      , intConst
      )
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Dealing with >5 args
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 javascript) hs export(argsPack, argsUnpack)
-- | pack > 5 args into tuple, otherwise normal
argsPack :: [Expr] -> (String,(),[Expr])
argsPack = javalikeArgsPack (-1) ((),(),arr,nmAppN)

-- | unpack > 5 args from tuple, otherwise normal
argsUnpack :: ([HsName]->[HsName]) -> [HsName] -> ([(HsName,())],[(Expr,())],[(HsName,CVarInfo)])
argsUnpack toRef = javalikeArgsUnpack maxBound ((), (), (), toRef, intConst, \_ a -> a, \n -> take n hsnLclSupply)
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Smart constructors
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 javascript) hs export(localVarDecl)
-- | declare a local var
localVarDecl :: HsName -> Maybe Expr -> Stat
localVarDecl n me = Stat_VarDecl n me
%%]

%%[(8 javascript) hs export(varDecl)
-- | declare a var, or a field in object, depending on name being qualified
varDecl :: HsName -> Expr -> Stat
%%[[8
varDecl n e = localVarDecl n (Just e)
%%][50
varDecl n e
  = case hsnQualifier n of
      Just _ -> Stat_Assign (Expr_Var n) e
      _      -> localVarDecl n (Just e)
%%]]
%%]

%%[(8 javascript) hs export(op)
-- | Operator expression
op :: String -> [Expr] -> Expr
op o (l:r:_) = Expr_Op    (mkHNm o) l r
op o (e  :_) = Expr_PreOp (mkHNm o) e
%%]

%%[(8 javascript) hs export(empty)
-- | Placeholder for empty
empty :: Expr
empty = Expr_Empty
%%]

%%[(8 javascript) hs export(vardecl)
vardecl :: HSNM n => n -> Maybe Expr -> Stat
vardecl nm mbe = Stat_VarDecl (mkHNm nm) mbe
%%]

%%[(8 javascript) hs export(arr, newTup)
-- | Construct array
arr ::[Expr] -> Expr
arr = Expr_Arr

-- new tuple
newTup :: [Expr] -> Expr
newTup = arr
%%]

%%[(8 javascript) hs export(dataFldNames, newDataConstr, newTupOrDataConstr)
-- | field names used for data constructors, either as provided by program, or made up here
--   20101012 AD, note: internally generated datatypes not yet have correct meta info, so fill up names as needed, as temporary hack
dataFldNames :: TagLike t => DataGam -> t -> [HsName]
dataFldNames dataGam tag
  = map (hsnSafeJavaLike . hsnQualified) nms ++ hsnLclSupply
  where nms  = maybe [] (\(_,dti) -> map fldNm $ dtiFldRefL dti) $ dataGamTagLookup tag dataGam

-- new data constructor
newDataConstr :: Int -> [NmExpr] -> Expr
newDataConstr tag as = Expr_Obj $ ((nmTag, intConst tag):) as

-- either new data constructor or tuple
newTupOrDataConstr :: TagLike t => DataGam -> t -> [Expr] -> Expr
newTupOrDataConstr dataGam tag as
  | tagIsData tag
      = newDataConstr (tagDataTag tag) (zip (dataFldNames dataGam tag) as)
  | tagIsTup tag
      = newTup as
%%]

%%[(8 javascript) hs export(intConst, evl, apl, var, call, callv, ret', ret, assign)
-- | Int constant
intConst :: Integral x => x -> Expr
intConst i = Expr_Int $ fromIntegral i

-- | call, function is an expr
call :: Expr -> [Expr] -> Expr
call = Expr_Call

-- | call, function is a name
callv :: HSNM n => n -> [Expr] -> Expr
callv f = call (var $ mkHNm f)

-- | force evaluation
evl :: Expr -> Expr
evl x = callv nmEval [x]

-- | force application
apl :: Expr -> [Expr] -> Expr
apl f as = callv nmApply [f, arr as]

-- | var
var :: HSNM x => x -> Expr
var nm = Expr_Var $ mkHNm nm

-- | return
ret' :: Maybe Expr -> Stat
ret' e = Stat_Ret e

-- | return
ret :: Expr -> Stat
ret e = ret' (Just e)

-- assign
assign :: HSNM x => x -> Expr -> Stat
assign n e = Stat_Assign (var $ mkHNm n) e

%%]

%%[(8 javascript) hs export(app, fun', fun, funFld)
-- apply
app :: Expr -> [Expr] -> Expr
app f as
  = Expr_New $ callv nm (f : as')
  where (nm,_,as') = argsPack as
        nArgs      = length as'

-- lam
fun' :: HsName -> Int -> Expr -> Expr
fun' fNm nArgs e
  = Expr_New $ callv (nmFunN nArgs) (extra ++ [e])
  where 
%%[[8
        extra = [Expr_Str $ show fNm]
%%][100
        extra = []
%%]]

fun :: HsName -> [HsName] -> [Stat] -> Expr
fun fNm as stats
  = fun' fNm (length as) (Expr_Fun Nothing as stat)
  -- = Expr_New $ callv (nmFunN $ length as) (extra ++ [Expr_Fun Nothing as stat])
  where stat = Stat_Block stats

-- | Extract field which holds actual JS function
funFld :: Expr -> Expr
funFld f = Expr_Sel f (var nmFunEvNFld)
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Observations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 javascript) hs export(exprMbVar)
exprMbVar :: Expr -> Maybe HsName
exprMbVar (Expr_Var n) = Just n
exprMbVar _            = Nothing
%%]
